<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Skyrats">
  <link rel="shortcut icon" href="../../../img/favicon.ico">
  <title>Em C++ - Knowledge Base - Skyrats</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Em C++";
    var mkdocs_page_input_path = "Software/POO/oo_c++.md";
    var mkdocs_page_url = "/knowledge_base/Software/POO/oo_c++/";
  </script>
  
  <script src="../../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/c.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/cpp.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/xml.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/matlab.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../../.." class="icon icon-home"> Knowledge Base - Skyrats</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../../..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../../about/">About</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Geral</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../Geral/Instalacao/">Instalações</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../Geral/formulario/">Formulário(Linux, ROS, Gazebo)</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../Geral/preflightcheck/">Protocolo de Segurança</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Hardware</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../Hardware/introHW/">Introdução ao Hardware para Drones</a>
                </li>
                <li class="">
                    
    <span class="caption-text">Componentes</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <span class="caption-text">Rádio Controles</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../../Hardware/Componentes/RCs/TaranisQX7/">Taranis QX7</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../Hardware/Componentes/ESCs/">Guia de Escolha de ESCs</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">Firmware</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../Hardware/Firmware/Introdução ao MAVLink/">Introdução ao MAVLink</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../../Hardware/Firmware/IntroPX4/">Introdução ao PX4</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">4G</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../../Hardware/4G/TransArqv/">Transferência de Arquivos</a>
                </li>
    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Software</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../Convencoes-de-Codigo/">Convenções de Código</a>
                </li>
                <li class=" current">
                    
    <span class="caption-text">Programação Orientada a Objetos</span>
    <ul class="subnav">
                <li class="toctree-l3 current">
                    
    <a class="current" href="./">Em C++</a>
    <ul class="subnav">
            
    <li class="toctree-l4"><a href="#workshop-de-programacao-orientada-a-objetos">Workshop de Programação Orientada a Objetos</a></li>
    
        <ul>
        
            <li><a class="toctree-l5" href="#1-paradigmas-de-programacao">1 Paradigmas de Programação</a></li>
        
            <li><a class="toctree-l5" href="#2-basicos-de-c">2 Básicos de C++</a></li>
        
            <li><a class="toctree-l5" href="#3-conceitos-basicos-de-oo">3 Conceitos Básicos de OO</a></li>
        
            <li><a class="toctree-l5" href="#4-encapsulamento">4 Encapsulamento</a></li>
        
            <li><a class="toctree-l5" href="#5-getters-e-setter">5 Getters e Setter</a></li>
        
            <li><a class="toctree-l5" href="#6-construtor-e-destrutor">6 Construtor e Destrutor</a></li>
        
            <li><a class="toctree-l5" href="#7-vetor-de-objetos">7 Vetor de Objetos</a></li>
        
            <li><a class="toctree-l5" href="#8-heranca-e-polimorfismo">8 Herança e Polimorfismo</a></li>
        
            <li><a class="toctree-l5" href="#9-informacoes-a-mais">9 Informações a mais</a></li>
        
        </ul>
    

    </ul>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../../Gazebo/">Gazebo</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Mecânica</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../..">Nada ainda aqui :c</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Comunicação</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../..">Nada ainda aqui :c</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="https://github.com/SkyRats/knowledge_base/issues">Issue Tracker</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../..">Knowledge Base - Skyrats</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../..">Docs</a> &raquo;</li>
    
      
        
          <li>Programação Orientada a Objetos &raquo;</li>
        
      
        
          <li>Software &raquo;</li>
        
      
    
    <li>Em C++</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/SkyRats/knowledge_base/edit/main/docs/Software/POO/oo_c++.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="workshop-de-programacao-orientada-a-objetos">Workshop de Programação Orientada a Objetos</h1>
<p>SOMOS O FELIPE E O BENTO E ESTAMOS DE REC NA MATERIA QUE VAMOS DAR PARA VOCES!</p>
<p>TEMOS QUE FALAR UM POUCO DE COMO CRIAR UMA MAIN EU ACHO.</p>
<h2 id="1-paradigmas-de-programacao">1 Paradigmas de Programação</h2>
<p>Paradigma é o jeito que a linguagem de programação é programada, por exemplo, o que vocês viram no workshop de introdução era o paradigama imperativo, onde você manda um "passo a passo" para o programa rodar.</p>
<p>Agora, o que vamos aprender é o paradigma de orientação a objetos, em que vai surgir a ideia de classes e objetos, que vão ser um nível de abstração a mais!</p>
<h2 id="2-basicos-de-c">2 Básicos de C++</h2>
<p>Depois do workshop de introdução a programação vocês já devem estar brabos em C e python hehe então aqui temos umas novidades da linguagem C++ (que é o C com MAIS MAIS coisas).</p>
<h3 id="21-cin-e-cout">2.1 CIN e COUT</h3>
<p>Essas são as funções de impressão e leitura do C++! </p>
<p>Em C para usar os famosos printf e scanf era necessário dar o #include <stdio.h>, agora aqui em C++ para usar o cin (C in) e cout (C out), de #include <iostream>.</p>
<p>A função cin substitui o scanf, com ela podemos pegar dados do nosso teclado e atribui-los a uma variável.</p>
<p>A função cout substitui o printf, com ela podemos imprimir coisas no monitor.</p>
<p>Mas pera ai, se o C++ é um complemento do C, eu ainda posso usar o printf e scanf?? </p>
<p>Sim!! Você pode continuar usando, mas os desenvolvedores criaram essas novas funções para serem mais intuitvas, pois nelas o fluxo que o dado percorre é mostrado com o "&lt;&lt;".</p>
<ul>
<li>Obs: o "endl" (end line) pula uma linha, assim como o "\n".</li>
</ul>
<p>Exemplo:</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

int main(){
    int minhaIdade;
    cin &gt;&gt; minhaIdade;
    cout &lt;&lt; &quot;Tenho &quot; &lt;&lt; minhaIdade &lt;&lt; &quot; anos!&quot; &lt;&lt; endl;
}

&gt;&gt;&gt; ./SkyratsIostream.exe
&gt;&gt;&gt; 19  //deixar de outra cor eh o fuco
&gt;&gt;&gt; Tenho 19 anos!
&gt;&gt;&gt; 
</code></pre>

<h3 id="22-string">2.2 String</h3>
<p>Existe uma biblioteca chamada <string.h>, com ela você pode representar palavras, frases ou textos, sem ter que usar o tal do Char. A string é como se fosse um vetor de caracteres, mas muito mais simples, por exemplo, o programa a seguir:</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main(){
    string frase = &quot;A skyrats é a melhor equipe da POLI!&quot;;
    cout &lt;&lt; frase &lt;&lt; endl;
}

Vai ter como saída isso:
&gt;&gt;&gt; ./SkyratsString.exe
&gt;&gt;&gt; A skyrats é a melhor equipe da POLI!
&gt;&gt;&gt;
</code></pre>

<ul>
<li>Obs: Para usar o "cin e cout" e as "strings" é necessaário além da inclusão das respectivas bibliotecas o uso do namespaece "std" que será explicado mais pra frente do porquê.</li>
</ul>
<h2 id="3-conceitos-basicos-de-oo">3 Conceitos Básicos de OO</h2>
<p>A programação orientada a objeto veio para abstrair a realidade! Nela transformamos conceitos da vida real em classes e métodos, visando simplificar a implementação de algumas coisas. </p>
<p>Pra você que ta criando o código, o trampo ainda é grande, mas quem for usar ele vai te agradecer bastante.</p>
<h3 id="31-classe">3.1 Classe</h3>
<p>A classe vai ser um molde com diversas caracteristicas.
Por exemplo, podemos criar a classe pizza que terá um atributo que indica o seu sabor e outro que indica a quantidade de fatias que ela tem.</p>
<h3 id="32-objetos">3.2 Objetos</h3>
<p>O objeto é a instância da classe, ou seja, se usarmos o molde(classe) da pizza, podemos criar diversas pizzas(objeto) e todas elas terão um sabor(atributo) e uma quantidade de fatias(atributo).</p>
<h3 id="33-atributos">3.3 Atributos</h3>
<p>São as propriedades e estados de uma classe.</p>
<h3 id="34-metodos">3.4 Métodos</h3>
<p>São a implementação dos serviços disponibilizados pelos objetos.
Podemos criar para a classe pizza o metódo "retirar_fatia()", agora podemos diminuir o numero de fatias que ela tem por meio de um método! </p>
<pre><code class="cpp">#include &lt;string&gt;
using namespace std;

class Pizza{//Classe
public:
    void retirar_fatia(){ //Método
        fatias--;
    }

private:
    string sabor;//Atributo
    int fatias;//Atributo
};

  int main(){
      Pizza *pizza1;//Criação de um objeto Pizza
  }
</code></pre>

<h3 id="34-revisao-de-ponteiros-ou-e-null">3.4 Revisão de Ponteiros ("-&gt;" ou "."?, e NULL)</h3>
<p>O ponteiro é uma variável que guarda um endereço de memória. Por exemplo, um ponteiro para o "int valor", será algo parecido com 0x6453.
Para declarar um ponteiro, é so colocar um "*", desse jeito:</p>
<pre><code class="cpp">int *x;
cout &lt;&lt; x &lt;&lt; endl;

Saída:
&gt;&gt;&gt; ./Ponteiro.exe
&gt;&gt;&gt; 0x32a57c
&gt;&gt;&gt;
</code></pre>

<p>E se quisermos pegar o endereço de uma variável ja existente? Usa o "&amp;", desse jeito:</p>
<pre><code class="cpp">int x = 10;
cout &lt;&lt; &amp;x &lt;&lt; &quot; - &quot; &lt;&lt; x &lt;&lt; endl;

Saída:
&gt;&gt;&gt; ./Ponteiro2.exe
&gt;&gt;&gt; 0x7b65d2 - 10
&gt;&gt;&gt;
</code></pre>

<p>Mas e agora, e se quisermos ir até a variável tendo o endereço dela? Usaremos também o "*", desse jeito:</p>
<pre><code class="cpp">int x = 10;
int* y = &amp;x;
cout &lt;&lt; x &lt;&lt; &quot; - &quot; &lt;&lt; *y &lt;&lt; endl;

Saída:
&gt;&gt;&gt; ./Ponteiro3.exe
&gt;&gt;&gt; 10 - 10
&gt;&gt;&gt;
</code></pre>

<p>Certo, sabendo disso podemos agora falar como isso tudo de ponteiros interfere em objetos.</p>
<p>Um objeto não deixa de ser uma variável, ele só possui um nível de abstração a mais. Logo, podemos criar variáveis para guardar objetos e pegar seus endereços guardando em ponteiros.</p>
<p>Tome cuidado, pois ao mesmo tempo que existe coisas para facilitar, de começo pode confundir um pouco.</p>
<p>Quando vamos criar uma variável para guardar um objeto, fazemos igual em um INT, por exemplo:
 <code>cpp
 Carro celtinha;</code>
 Desse jeito eu criei uma variável do tipo carro com o nome celtinha.</p>
<p>Mas tem uma coisa, objetos funcionam igual variáveis, certo? </p>
<p>SIM! Então saindo de algum escopo ele também deixa de existir? </p>
<p>SIM! Mas temos como resolver isso, que é através dos ponteiros! Pois se usarmos continuamente o endereço na qual o objeto está ele não vai deixar de existir, e assim podemos trabalhar de uma forma mais ampla com ele, podemos fazer assim: 
  <code>cpp
  Carro* celtinha;</code>
  E nesse ponteiro celtinha, vamos guardar o ponteiro que aponta para o objeto, MAS PRESTE ATENÇÃO!!! Devemos tomar MUITO cuidado em como vamo chamar os métodos e atributos. Assim, se temos apenas um objeto("Carro celtinha;), chamamos os métodos e atributos usando ".", por exemplo:</p>
<pre><code class="cpp">Carro celtinha = Carro(); //Esse método é um construtor, não se preocupe com ele agora, vamos explicar mais para a frente, apenas saiba que estamos colocando um objeto do tipo Carro na variável
celtinha.buzinar(); // Esse método retorna no terminal a buzina
cout &lt;&lt; &quot;Ano do carro: &quot; &lt;&lt; celtinha.ano &lt;&lt; endl; // Aqui ele chama o atributo que guarda o ano do carro

Saída:
&gt;&gt;&gt; ./PonteiroCeltinha.exe
&gt;&gt;&gt; Biiii Biiiiiii
&gt;&gt;&gt; Ano do carro: 2006
&gt;&gt;&gt;
</code></pre>

<p>Mas agora, se vamos guardar um objeto numa variável de ponteiro, teremos que chamar os métodos e atributos desreferenciando o ponteiro, assim: </p>
<pre><code class="cpp">(*celtinha).buzinar(); 
</code></pre>

<p>Mas em C++ existe uma coisa que facilita muito mais do que ficar desreferenciando o ponteiro toda hora, que é so usar uma setinha("-&gt;"), assim, podemos chamar o método desse jeito:</p>
<pre><code class="cpp">celtinha-&gt;buzinar();
</code></pre>

<p>Exemplo completo:</p>
<pre><code class="cpp">Carro celtinha = Carro();
Carro *ponteiroCeltinha = &amp;celtinha;

(*ponteiroCeltinha).buzinar();
ponteiroCeltinha-&gt;buzinar();

cout &lt;&lt; &quot;Ano do carro: &quot; &lt;&lt; (*ponteiroCeltinha).ano &lt;&lt; endl;
cout &lt;&lt; &quot;Ano do carro: &quot; &lt;&lt; ponteiroCeltinha-&gt;ano &lt;&lt; endl;

Saída:
&gt;&gt;&gt; ./PonteiroCeltinha.exe
&gt;&gt;&gt; Biiii Biiiiiii
&gt;&gt;&gt; Biiii Biiiiiii
&gt;&gt;&gt; Ano do carro: 2006
&gt;&gt;&gt; Ano do carro: 2006
&gt;&gt;&gt;
</code></pre>

<p>E mais uma última coisa! E se quisermos guardar um "nada" dentro de um ponteiro, como fazemos?</p>
<p>Usamos "NULL", assim o ponteiro não estará apontando para nenhum lugar.</p>
<pre><code class="cpp">Carro *ponteiroCeltinha = NULL;
ponteiroCeltinha-&gt;buzinar();
Saída:
&gt;&gt;&gt; ./PonteiroCeltinha.exe
&gt;&gt;&gt;
</code></pre>

<h2 id="4-encapsulamento">4 Encapsulamento</h2>
<p>Encapsulamento é indicar quem tem acesso a um método ou atributo.</p>
<h3 id="41-private">4.1 Private</h3>
<p>Os atributos e métodos "encapsulados" dentro do "private", só podem ser acessados dentro de métodos da própria classe, nem mesmo de classes filhas, coisas que veremos mais para a frente.</p>
<h3 id="42-public">4.2 Public</h3>
<p>Os atributos e métodos "encapsulados" dentro do "public", podem ser acessados em qualquer lugar, seja na main, em métodos de outras classes, etc...</p>
<h3 id="43-protected">4.3 Protected</h3>
<p>Os atributos e métodos "encapsulados" dentro do "protected", tem acesso parecido com os encapsulados em "private", mas neste, métodos e atributos podem ser acessados apenas por ela mesma e por classes filhas (explicadas mais para frente). </p>
<h3 id="44-headersh-e-hpp-e-sourcescpp">4.4 Headers(.h e .hpp) e Sources(.cpp)</h3>
<p>Uma das grandes vantagens da OO é a modularização dos códigos, ou seja, cada parte pode ser compilada individualmente. Na prática isso significa que caso seja feito uma pequena alteração, só precisamos compilar o código modificado. </p>
<p>Além disso, uma boa prática é criar arquivos diferentes para a definição e implementação de uma classe.</p>
<p>O arquivo de definição é o Header (.h) e (.hpp).</p>
<p>O arquivo de implementação é o Source (.cpp)</p>
<p>Ex: Relógio.h</p>
<pre><code class="cpp">class Relogio{
    private:
        int hora;
        int minuto;
    public:
        int getHora();
        int getMinuto();
};

</code></pre>

<p>Ex: Relógio.cpp</p>
<pre><code class="cpp">#include &quot;Relogio.h&quot;

int Relogio::getHora(){
    return hora;
}

int Relogio::getMinuto(){
    return minuto;
}

</code></pre>

<h3 id="45-ifndef-endif-e-define">4.5 "#ifndef - #endif" e "#define"</h3>
<p>Quando programamos é normal incluirmos varios arquivos no inicio do programa, porém no meio desse monte de inclusão é muito fácil acabarmos incluindo o mesmo Header mais de uma vez, pois dentro de classes incluimos outras classes, o que pode ocasionar em um erro de definirmos multiplas vezes a mesma coisa. </p>
<p>Para evitar isso, é recomendado que sempre que criarmos um Header usarmos o modelo:</p>
<pre><code class="cpp">#ifndef CLASSE_H        // Se a classe não estiver definida
#define CLASSE_H        // Define a classe

class Classe{
    ...
};

#endif                  //Fim do ifndef
</code></pre>

<h2 id="5-getters-e-setter">5 Getters e Setter</h2>
<p>Normalmente na programação orientada a objetos, os atributos serão privados por uma questão de segurança, e para outras classes poderem acessa-los usaremos os métodos (normalmente públicos) getters e setters.</p>
<p>Os getter sãos métodos usados para retornar valores de atributos, e os setters para aplicar valores neles. Como é bem simples, com o exemplo é entendível sua utilidade:</p>
<pre><code class="cpp">class Carro{
    public:
        int getCombustivel(){
            return combustivel;
        }
        void setCombustivel(int valor){
            combustivel = valor;
        }
    private:
        int combustivel;
};

int main() {
    Carro Celtinha = Carro();
    Celtinha.setCombustivel(30);
    cout &lt;&lt; &quot;Combustivel: &quot; &lt;&lt; Celtinha.getCombustivel() &lt;&lt; endl;
}    

Tem como saída:
&gt;&gt;&gt; ./Celtinha.exe
&gt;&gt;&gt; Combustível: 30
</code></pre>

<h2 id="6-construtor-e-destrutor">6 Construtor e Destrutor</h2>
<h3 id="61-construtor">6.1 Construtor</h3>
<p>O construtor é a primeira função que é executada quando instanciamos um objeto, nela serão iniciadas alguns atributos.
Existem duas principais formas de fazer esse processo:</p>
<p>Alocação Dinâmica: </p>
<pre><code class="cpp">Carro* Celtinha = new Carro();
</code></pre>

<p>Ele cria um objeto e atribui seu "Ponteiro" dinamicamente, ou seja, a variável será mantida mesmo depois do fechamento de escopo, assim, precisa ser desalocada manualmente. </p>
<p>Alocação Estática:</p>
<pre><code class="cpp">Carro* Celtinha = &amp;(Carro());
</code></pre>

<p>Aqui a o ponteiro do objeto construído é atribuído à variável Celtinha, e por ser alocação estática, ele não precisa ser destruído manualmente, embora seja possível.</p>
<p>Quando estamos fazendo a classe podemos escrever um código para o construtor, e nisso podemos setar valores, criar variáveis, dar uns couts, uns cins, e fazer todo o possível para uma função normal, para isso devemos criar um método com o nome da própria classe.</p>
<ul>
<li>Obs: Usamos o "this-&gt;" para nos referirmos a um atributo ou método do objeto que o chamou. Podemos assim diferenciar coisas com o mesmo nome.</li>
</ul>
<pre><code class="cpp">class carro{
    public:
        carro(string nome, int ano){
            this-&gt;nome = nome; //O &quot;this-&gt;nome&quot; se refere ao atributo da classe.
            this-&gt;ano = ano;
            cout &lt;&lt; &quot;Carro &quot; &lt;&lt; nome &lt;&lt; &quot; do ano &quot; &lt;&lt; ano &lt;&lt; &quot; construído!!!&quot; &lt;&lt; endl;
        }

    private:
        string nome; //Atributo
        int ano;
};

int main() {
    carro Celtinha = carro(&quot;Celta&quot;, 2006);
}  

Saída:
&gt;&gt;&gt; ./ConstrutorDoCeltinha.exe
&gt;&gt;&gt; Carro Celta do ano 2006 construído!!!
</code></pre>

<h3 id="62-destrutor">6.2 Destrutor</h3>
<p>Se você criou um objeto, ele vai ocupar espaço na memória! Portanto, é bom sabermos que podemos destruí-los, e para isso usamos o comando "delete", e esse comando chama o destrutor, uma função bemmm parecida com o construtor, só que com um til atrás, "~NomeDaClasse()", ele funciona assim:</p>
<pre><code class="cpp">class Comida{
    public:
        Comida(string nome, bool vencida){
            this-&gt;nome = nome;
            this-&gt;vencida = vencida;
        }
        ~Comida(){
            if(vencida == true)
                cout &lt;&lt; &quot;Parabéns!, você jogou sua(seu) &quot; &lt;&lt; nome &lt;&lt; &quot; vencida(o) fora!&quot; &lt;&lt; endl;
            else
                cout &lt;&lt; &quot;Que feio! você jogou sua(seu) &quot; &lt;&lt; nome &lt;&lt; &quot; nova(o) fora! Não desperdice comida &gt;:&quot;
        }
    private:
        string nome;
        bool vencida;
}

int main(){
    Comida* cenoura = new Comida(&quot;Cenoura&quot;, true);
    Comida* beringela = new Comida(&quot;Beringela&quot;, false);
    delete cenoura;
    delete beringela;
}

Saída:
&gt;&gt;&gt; ./Comida.exe
&gt;&gt;&gt; Parabéns!, você jogou sua(seu) Cenoura vencida(o) fora!
&gt;&gt;&gt; Que feio! você jogou sua(seu) Beringela nova(o) fora! Não desperdice comida &gt;:
</code></pre>

<h2 id="7-vetor-de-objetos">7 Vetor de Objetos</h2>
<p>Em C++, podemos criar vetores de variáveis simples, como: INTs, FLOATs... e PONTEIROS! Mas também podemos criar um vetor de objetos, guardando em cada posição do vetor um ponteiro para esse objeto, e podemos fazer isso de duas formas, estáticamente ou dinamicamente:</p>
<pre><code class="cpp">Construcao* predios[tamanho]; //Estática
predios[2] = PredioAzul;
if(predios[2] == PredioAzul) cout &lt;&lt; &quot;Deu certo!&quot; &lt;&lt; endl;

Construcao** predios2 = new Construcao*[tamanho];
predios2[2] = PredioAzul;
if(predios2[2] == PredioAzul) cout &lt;&lt; &quot;Deu certo!&quot; &lt;&lt; endl;

&gt;&gt;&gt; ./Predios.exe
&gt;&gt;&gt; Deu certo!
&gt;&gt;&gt; Deu certo!
&gt;&gt;&gt; 
</code></pre>

<p>Obs: Para destruir vetores dinâmicos, já que ele não deixa de ser um tipo de objeto, você usa o "delete[] nomeDoVetor;".</p>
<h2 id="8-heranca-e-polimorfismo">8 Herança e Polimorfismo</h2>
<h3 id="81-o-que-e-um-filho">8.1 O que é um filho</h3>
<p>Ter filhos... É quando você cria uma classe a partir de outra, lógico...</p>
<p>Lembrem-se: USEM PROTEÇÃO!!! Coloquem os atributos em private...</p>
<p>Quando você cria uma classe filha de uma outra, essa classe filha vai herdar todas as características da classe pai, métodos, atributos, etc... E além disso você pode colocar mais coisas ainda. É mais fácil de entender com exemplo:</p>
<pre><code class="cpp">#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace std;

    class Pessoa {
        public:
            Pessoa(string nome, int idade){
                this-&gt;nome = nome;
                this-&gt;idade = idade;
            }
        protected:
            string nome;
            int idade;
    };

    class Bento : public Pessoa { //Para indicarmos que a classe é Bento é filha de Pessoa
        public:
            Bento(string nome, int idade, bool Politreco) : Pessoa(&quot;Bento&quot;, idade) { // Colocamos o &quot;:&quot; e chamamos o construtor da classe Pai e mandamos nesse construtor os atributos que vão para a classe Pai
                this-&gt;Politreco = Politreco;
            }
            void bentoPolitreco() {
                if(Politreco)
                    cout &lt;&lt; &quot;Bento eh politreco&quot; &lt;&lt; endl;
                else
                    cout &lt;&lt; &quot;Bento nao eh politreco&quot; &lt;&lt; endl;
            }
        private:
            bool Politreco;
    };

    int main() {
        Bento* bento = new Bento(&quot;Bento&quot;, 19, true);
        bento-&gt;bentoPolitreco();
    }

Saída:
&gt;&gt;&gt; ./Bento.exe
&gt;&gt;&gt; Bento eh politreco
&gt;&gt;&gt;
</code></pre>

<h3 id="82-principio-da-substituicao">8.2 Princípio da Substituição</h3>
<p>Se F é filha de P, os objetos  do tipo F devem se comportar com P caso sejam tratados como P.</p>
<p>Ou seja, o filho tem tudo que o pai tem, então se usarmos o filho tratando ele como pai, deve se comportar como pai.</p>
<p>Pensa assim, se você usar o C++ pensando que ta programando em C, ele vai se comportar igualzinho como C!</p>
<h3 id="83-protected">8.3 Protected</h3>
<p>Agora que sabemos o que são filhos e pais no meio do OO, podemos entender o encapsulamento Protected, que como explicado antes, funciona igual o "Private", mas a diferença é que ele pode ser acessado pelos filhos, por exemplo, se eu tenho uma classe Pai, com um atributo Private Nome e um Protected Idade, e uma classe Filha de Pai, se nela chamarmos o atributo Nome, daria erro de compilação, ja se chamassemos o atributo Idade não, por outro lado, se estivessemos em uma outra classe, sem relação com as duas, daria erro de compilação se chamassemos os dois atributos.</p>
<pre><code class="cpp">class Pai{               //01
    private:             //02
        string Nome;     //03
    protected:           //04
        int Idade;       //05
    };                   //06
class Filho{             //07
    public:              //08
        int getIdade{    //09
            return idade;//10
        }                //11
        string getNome{  //12
            return nome; //13
        }                //14
    };                   //15
int main(){              //16
    Pai pai = Pai();     //17
    cout &lt;&lt; pai.Nome &lt;&lt; endl; //18
    cout &lt;&lt; pai.Idade &lt;&lt; endl;//19
    return 0;            //20
}
Saída:
&gt;&gt;&gt; gcc -c Protected.c
&gt;&gt;&gt; Erro nas linhas 10, 18 e 19
&gt;&gt;&gt;
</code></pre>

<h2 id="9-informacoes-a-mais">9 Informações a mais</h2>
<h3 id="91-const">9.1 Const</h3>
<p>É possivel criar constantes em C++! Isso pode evitar que durante a implementação de um programa alguem mude algo indevidamente.
Ex:</p>
<pre><code class="cpp">const float pi = 3.14

ou

const Lampada *L1 = new Lampada(&quot;Branca&quot;);
</code></pre>

<p>Dessa forma, caso mudem o valor de PI ou a cor da lampada, um erro de compilação será gerado.</p>
<h3 id="92-virtual">9.2 Virtual</h3>
<p>Quando declaramos um método como virtual, o código, no momento da execução, decide se o método chamado vai ser da classe pai, filho, etc...</p>
<p>O programa executa o método com base no tipo
específico do objeto!</p>
<ul>
<li>Obs: É sempre bom declarar todos os métodos como virtuais, e como obrigação declarar todos os destrutores como virtuais, por que tem casos em que certos destrutores não são chamados.</li>
</ul>
<p>Exemplo:</p>
<pre><code class="cpp">    class Passaro {
        public: virtual void canta() { cout &lt;&lt; &quot;Piuu Piuuu&quot; &lt;&lt; endl;}
    };
    class Arara : public Passaro {
        public: virtual void canta() { cout &lt;&lt; &quot;Araraaa Araraa&quot; &lt;&lt; endl;}
    };
    int main(){
        Passaro* passaro = new Passaro();
        Arara* arara = new Arara();
        passaro-&gt;canta();
        arara-&gt;canta();
        return 0;
    }
Saída:
&gt;&gt;&gt; ./Passaros.exe
&gt;&gt;&gt; Piuu Piuuu
&gt;&gt;&gt; Araraaa Araraa
&gt;&gt;&gt; 
</code></pre>

<h3 id="93-namespace-e-std">9.3 Namespace e STD</h3>
<p>Namespaces são jeitos de não se repetirem nomes ao usar variáveis, por exemplo, se você cria um namespace para uma class X, toda vez que você for usar alguma coisa dessa classe, você terá que indicar o namespace, por exemplo:</p>
<pre><code class="cpp">namespace UM {
    class UM {
        void metodoUm(){}
    }
}
***Em outro arquivo...***
#include &quot;UM.h&quot;

using namespace UM; //Aqui você indica o namespace usado com o &quot;using&quot;

int main(){
    metodoUm();
    return 0;
}
***Em outro arquivo...***
#include &quot;UM.h&quot;

int main(){
    UM::metodoUm(); //Aqui você indica o namespace usado com o &quot;::&quot;
    return 0;
}
</code></pre>

<p>Por isso que temos que usar o "using namespace std;" pois assim não precisamos escrever em cada COUT ou String o "std::" antes, apenas para facilitar.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../Gazebo/" class="btn btn-neutral float-right" title="Gazebo">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../../Convencoes-de-Codigo/" class="btn btn-neutral" title="Convenções de Código"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/SkyRats/knowledge_base/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../../Convencoes-de-Codigo/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../Gazebo/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>

</body>
</html>
