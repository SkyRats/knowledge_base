{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Skyrats Knowledge Base Reposit\u00f3rio para a organiza\u00e7\u00e3o e disponibiliza\u00e7\u00e3o de conhecimentos da equipe Skyrats. Neste reposit\u00f3rio, temos os seguintes tipos de conte\u00fados: Guias : tutoriais passo a passo, como uma instala\u00e7\u00e3o ou a realiza\u00e7\u00e3o de algum tipo espec\u00edfico de tarefa; Documenta\u00e7\u00f5es : explica\u00e7\u00f5es sobre o que \u00e9/como funciona uma determinada plataforma/conceito/atividade (equivalentes a \"mini workshops\"); Solu\u00e7\u00e3o de erros : descri\u00e7\u00e3o de um erro obtido, junto a uma poss\u00edvel solu\u00e7\u00e3o. Fica presente na aba de issues .","title":"Home"},{"location":"about/","text":"ola amiguinhos","title":"About"},{"location":"Geral/FlightReview/","text":"An\u00e1lise de logs de voo \u00c9 muito importante conseguir analisar o voo do drone ap\u00f3s ele ser realizado para detectar problemas que n\u00e3o s\u00e3o vis\u00edveis apenas olhando ele voar. Nesse guia vamos mostrar algumas ferramentas para isso. O que \u00e9 um log de voo? O que tem nele, onde \u00e9 gerado e como obter PX4 Flight Review Mostrar o site, como subir um log e como navegar no site e nos gr\u00e1ficos Vibra\u00e7\u00e3o O que \u00e9, como ver nos gr\u00e1ficso e como resolver Sa\u00eddas de atuadores O que \u00e9, como ver nos gr\u00e1ficos e como resolver Problemas no GPS O que \u00e9, como ver e como resolver Thrust e campo magn\u00e9tico O que \u00e9, como ver e como resolver Estimator Watchdog O que \u00e9, como ver e como resolver Sampling Regularity of Sensor Data O que \u00e9, como ver e como resolver Logged messages Talvez colocar mais em cima?","title":"An\u00e1lise de logs de voo"},{"location":"Geral/FlightReview/#analise-de-logs-de-voo","text":"\u00c9 muito importante conseguir analisar o voo do drone ap\u00f3s ele ser realizado para detectar problemas que n\u00e3o s\u00e3o vis\u00edveis apenas olhando ele voar. Nesse guia vamos mostrar algumas ferramentas para isso.","title":"An\u00e1lise de logs de voo"},{"location":"Geral/FlightReview/#o-que-e-um-log-de-voo","text":"O que tem nele, onde \u00e9 gerado e como obter","title":"O que \u00e9 um log de voo?"},{"location":"Geral/FlightReview/#px4-flight-review","text":"Mostrar o site, como subir um log e como navegar no site e nos gr\u00e1ficos","title":"PX4 Flight Review"},{"location":"Geral/FlightReview/#vibracao","text":"O que \u00e9, como ver nos gr\u00e1ficso e como resolver","title":"Vibra\u00e7\u00e3o"},{"location":"Geral/FlightReview/#saidas-de-atuadores","text":"O que \u00e9, como ver nos gr\u00e1ficos e como resolver","title":"Sa\u00eddas de atuadores"},{"location":"Geral/FlightReview/#problemas-no-gps","text":"O que \u00e9, como ver e como resolver","title":"Problemas no GPS"},{"location":"Geral/FlightReview/#thrust-e-campo-magnetico","text":"O que \u00e9, como ver e como resolver","title":"Thrust e campo magn\u00e9tico"},{"location":"Geral/FlightReview/#estimator-watchdog","text":"O que \u00e9, como ver e como resolver","title":"Estimator Watchdog"},{"location":"Geral/FlightReview/#sampling-regularity-of-sensor-data","text":"O que \u00e9, como ver e como resolver","title":"Sampling Regularity of Sensor Data"},{"location":"Geral/FlightReview/#logged-messages","text":"Talvez colocar mais em cima?","title":"Logged messages"},{"location":"Geral/Instalacao/","text":"Instala\u00e7\u00e3o 1. Objetivo Instala\u00e7\u00e3o dos seguintes programas: ROS Melodic Gazebo 9 MAVROS Firmware PX4 QGroundControl 2. Requisitos Computador com Ubuntu 18.04 3. Passo a passo Execute os seguintes comandos em sequ\u00eancia em um terminal. 3.1. ROS e Gazebo # Configura sources.list sudo sh -c 'echo deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main /etc/apt/sources.list.d/ros-latest.list' # Configura keys sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 sudo apt update # Instala o ROS e o Gazebo sudo apt install ros-melodic-desktop-full -y # Vari\u00e1veis de ambiente source /opt/ros/melodic/setup.bash echo source /opt/ros/melodic/setup.bash ~/.bashrc # Instala outras dependencias sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential Para criar um workspace na pasta ~/catkin_ws : # Cria a pasta cd mkdir -p ~/catkin_ws/src # Inicializa o workspace cd ~/catkin_ws/src catkin_init_workspace # Compila o workspace sudo apt install python-catkin-tools cd .. catkin build # Adiciona ao .bashrc echo source ~/catkin_ws/devel/setup.bash ~/.bashrc 3.2. MAVROS # Instala MAVROS sudo apt-get install ros-melodic-mavros ros-melodic-mavros-extras # Instala geographiclib wget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh sudo bash ./install_geographiclib_datasets.sh rm ./install_geographiclib_datasets.sh 3.3. Firmware PX4 cd mkdir ~/src cd ~/src # Clona o firmware git clone https://github.com/Skyrats/Firmware.git --recursive # SE DER O ERRO (*****S\u00d3 SE DER O ERRO*****): server certificate failed # Dar o comando p consert\u00e1-lo: git config --global http.sslverify false # Executa o ubuntu.sh (demora pra caramba) cd ~/src/Firmware/Tools/setup ./ubuntu.sh Isso apenas baixa o Firmware e instala suas depend\u00eancias. Se voc\u00ea quiser us\u00e1-lo em um drone ou em uma simula\u00e7\u00e3o, voc\u00ea vai precisar compilar. Isso demora bastante, ent\u00e3o eu recomendo fazer logo o que voc\u00ea for usar. # Todos os comandos devem ser executados nessa p\u00e1gina cd ~/src/Firmware # Compilar para simula\u00e7\u00e3o (vai abrir o gazebo no final) make px4_sitl gazebo # Pixhawk 4 make px4_fmu-v5_default 3.3. Firmware ARDUPILOT cd ~/src # Clona o firmware git clone https://github.com/SkyRats/ardupilot.git --recursive 3.4. QGroundControl sudo usermod -a -G dialout $USER sudo apt-get remove modemmanager -y sudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav gstreamer1.0-gl -y # Precisa dar logout e login para prosseguir # Baixa o QGC (um execut\u00e1vel) para a home cd wget https://s3-us-west-2.amazonaws.com/qgroundcontrol/latest/QGroundControl.AppImage # D\u00e1 permiss\u00e3o de execu\u00e7\u00e3o chmod +x QGroundControl.AppImage 4. Verificando a instala\u00e7\u00e3o Pra testar se as coisas foram instaladas corretamente, voc\u00ea pode seguir os passos a seguir. S\u00e3o testes simples s\u00f3 pra ver se o b\u00e1sico funciona. 4.1. ROS Abra um terminal e digite o comando seguinte roscore Se aparecer uma parede de texto t\u00e1 tudo certo, se der algum erro de comando n\u00e3o encontrado alguma coisa deu ruim. Pra interrompe, aperte Ctrl+C. 4.2. MAVROS Se estiver instalado, o ROS deve conseguir achar a MAVROS com roscd mavros Comando b\u00e1sico pra ir at\u00e9 o diret\u00f3rio em que t\u00e1 instalado. Se n\u00e3o apareceu nada t\u00e1 tudo certo, o problema \u00e9 se reclamar que n\u00e3o encontrou. 4.3. Gazebo O Gazebo \u00e9 um aplicativo, voc\u1ebd deve encontrar ele dentre os outros aplicativos ou colocando gazebo em qualquer terminal. Basta checar que ele existe e abre. 4.4. Firmware PX4 Uma forma simples de ver se est\u00e1 funcionando \u00e9 tentar abrir a simula\u00e7\u00e3o com o gazebo, como explicado no final de 3.3. 4.5. QGroundControl Esse tbm \u00e9 um aplicativo, mas n\u00e3o aparece na lista de aplicativos instalados. A gente baixou ele direto na home, s\u00f3 precisa clicar duas vezes no \u00edcone e ele abre. 5. Refer\u00eancias http://wiki.ros.org/melodic/Installation/Ubuntu https://github.com/SkyRats/workshops/tree/ros_basics https://dev.px4.io/master/en/ros/mavros_installation.html https://dev.px4.io/master/en/setup/dev_env_linux_ubuntu.html https://docs.qgroundcontrol.com/master/en/getting_started/download_and_install.html","title":"Instala\u00e7\u00f5es"},{"location":"Geral/Instalacao/#instalacao","text":"","title":"Instala\u00e7\u00e3o"},{"location":"Geral/Instalacao/#1-objetivo","text":"Instala\u00e7\u00e3o dos seguintes programas: ROS Melodic Gazebo 9 MAVROS Firmware PX4 QGroundControl","title":"1. Objetivo"},{"location":"Geral/Instalacao/#2-requisitos","text":"Computador com Ubuntu 18.04","title":"2. Requisitos"},{"location":"Geral/Instalacao/#3-passo-a-passo","text":"Execute os seguintes comandos em sequ\u00eancia em um terminal.","title":"3. Passo a passo"},{"location":"Geral/Instalacao/#31-ros-e-gazebo","text":"# Configura sources.list sudo sh -c 'echo deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main /etc/apt/sources.list.d/ros-latest.list' # Configura keys sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 sudo apt update # Instala o ROS e o Gazebo sudo apt install ros-melodic-desktop-full -y # Vari\u00e1veis de ambiente source /opt/ros/melodic/setup.bash echo source /opt/ros/melodic/setup.bash ~/.bashrc # Instala outras dependencias sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential Para criar um workspace na pasta ~/catkin_ws : # Cria a pasta cd mkdir -p ~/catkin_ws/src # Inicializa o workspace cd ~/catkin_ws/src catkin_init_workspace # Compila o workspace sudo apt install python-catkin-tools cd .. catkin build # Adiciona ao .bashrc echo source ~/catkin_ws/devel/setup.bash ~/.bashrc","title":"3.1. ROS e Gazebo"},{"location":"Geral/Instalacao/#32-mavros","text":"# Instala MAVROS sudo apt-get install ros-melodic-mavros ros-melodic-mavros-extras # Instala geographiclib wget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh sudo bash ./install_geographiclib_datasets.sh rm ./install_geographiclib_datasets.sh","title":"3.2. MAVROS"},{"location":"Geral/Instalacao/#33-firmware-px4","text":"cd mkdir ~/src cd ~/src # Clona o firmware git clone https://github.com/Skyrats/Firmware.git --recursive # SE DER O ERRO (*****S\u00d3 SE DER O ERRO*****): server certificate failed # Dar o comando p consert\u00e1-lo: git config --global http.sslverify false # Executa o ubuntu.sh (demora pra caramba) cd ~/src/Firmware/Tools/setup ./ubuntu.sh Isso apenas baixa o Firmware e instala suas depend\u00eancias. Se voc\u00ea quiser us\u00e1-lo em um drone ou em uma simula\u00e7\u00e3o, voc\u00ea vai precisar compilar. Isso demora bastante, ent\u00e3o eu recomendo fazer logo o que voc\u00ea for usar. # Todos os comandos devem ser executados nessa p\u00e1gina cd ~/src/Firmware # Compilar para simula\u00e7\u00e3o (vai abrir o gazebo no final) make px4_sitl gazebo # Pixhawk 4 make px4_fmu-v5_default","title":"3.3. Firmware PX4"},{"location":"Geral/Instalacao/#33-firmware-ardupilot","text":"cd ~/src # Clona o firmware git clone https://github.com/SkyRats/ardupilot.git --recursive","title":"3.3. Firmware ARDUPILOT"},{"location":"Geral/Instalacao/#34-qgroundcontrol","text":"sudo usermod -a -G dialout $USER sudo apt-get remove modemmanager -y sudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav gstreamer1.0-gl -y # Precisa dar logout e login para prosseguir # Baixa o QGC (um execut\u00e1vel) para a home cd wget https://s3-us-west-2.amazonaws.com/qgroundcontrol/latest/QGroundControl.AppImage # D\u00e1 permiss\u00e3o de execu\u00e7\u00e3o chmod +x QGroundControl.AppImage","title":"3.4. QGroundControl"},{"location":"Geral/Instalacao/#4-verificando-a-instalacao","text":"Pra testar se as coisas foram instaladas corretamente, voc\u00ea pode seguir os passos a seguir. S\u00e3o testes simples s\u00f3 pra ver se o b\u00e1sico funciona.","title":"4. Verificando a instala\u00e7\u00e3o"},{"location":"Geral/Instalacao/#41-ros","text":"Abra um terminal e digite o comando seguinte roscore Se aparecer uma parede de texto t\u00e1 tudo certo, se der algum erro de comando n\u00e3o encontrado alguma coisa deu ruim. Pra interrompe, aperte Ctrl+C.","title":"4.1. ROS"},{"location":"Geral/Instalacao/#42-mavros","text":"Se estiver instalado, o ROS deve conseguir achar a MAVROS com roscd mavros Comando b\u00e1sico pra ir at\u00e9 o diret\u00f3rio em que t\u00e1 instalado. Se n\u00e3o apareceu nada t\u00e1 tudo certo, o problema \u00e9 se reclamar que n\u00e3o encontrou.","title":"4.2. MAVROS"},{"location":"Geral/Instalacao/#43-gazebo","text":"O Gazebo \u00e9 um aplicativo, voc\u1ebd deve encontrar ele dentre os outros aplicativos ou colocando gazebo em qualquer terminal. Basta checar que ele existe e abre.","title":"4.3. Gazebo"},{"location":"Geral/Instalacao/#44-firmware-px4","text":"Uma forma simples de ver se est\u00e1 funcionando \u00e9 tentar abrir a simula\u00e7\u00e3o com o gazebo, como explicado no final de 3.3.","title":"4.4. Firmware PX4"},{"location":"Geral/Instalacao/#45-qgroundcontrol","text":"Esse tbm \u00e9 um aplicativo, mas n\u00e3o aparece na lista de aplicativos instalados. A gente baixou ele direto na home, s\u00f3 precisa clicar duas vezes no \u00edcone e ele abre.","title":"4.5. QGroundControl"},{"location":"Geral/Instalacao/#5-referencias","text":"http://wiki.ros.org/melodic/Installation/Ubuntu https://github.com/SkyRats/workshops/tree/ros_basics https://dev.px4.io/master/en/ros/mavros_installation.html https://dev.px4.io/master/en/setup/dev_env_linux_ubuntu.html https://docs.qgroundcontrol.com/master/en/getting_started/download_and_install.html","title":"5. Refer\u00eancias"},{"location":"Geral/formulario/","text":"F\u00f3rmul\u00e1rio Linux B\u00e1sico Mostrar o caminho atual pwd Listar os arquivos no diret\u00f3rio atual ls Mudar de diret\u00f3rio cd caminho do diret\u00f3rio Mostar o conte\u00fado de um arquivo cat arquivo Abrir um arquivo em um editor de texto nano nome do arquivo Manipulando arquivos e diret\u00f3rios Criar arquivo em branco touch arquivo Copiar arquivos cp arquivo opiado diret\u00f3rio de destino Mover arquivos mv arquivo destino Renomear arquivos mv nome atual do arquivo novo nome Deletar arquivos rm arquivo Criar diret\u00f3rio mkdir nome do diret\u00f3rio Deletar diret\u00f3rios vazios rmdir diret\u00f3rio Deletar diret\u00f3rios com arquivos rm -r diret\u00f3rio Modificar as permiss\u00f5es de um arquivo Todo arquivo pode possuir 8 tipos de permiss\u00f5es diferentes: 0 - Sem permiss\u00e3o 1 - Permiss\u00e3o para executar 2 - Permiss\u00e3o para escrever 3 - Permiss\u00e3o para escrever e executar 4 - Permiss\u00e3o para ler 5 - Permiss\u00e3o para ler e executar 6 - Permiss\u00e3o para ler e escrever 7 - Permiss\u00e3o para ler, escrever e executar Essa permiss\u00e3o pode ser dada para interagir com 3 tipos de usu\u00e1rios: O dono - representa o usu\u00e1rio dono do arquivo no computador. Grupos - Grupos de mais de um usu\u00e1rio. Todos - Todos os usu\u00e1rios naquele computador. Para alterar as permiss\u00f5es de um arquivo, \u00e9 necess\u00e1rio utilizar o comando chmod seguido de um n\u00famero de 3 algarimso, onde o primeiro representa as permiss\u00f5es para o usu\u00e1rio dono do arquivo, o segundo, do grupo de usu\u00e1rios e o terceiro, de todos os usu\u00e1rios e, por \u00faltimo, o nome do arquivo que queremos alterar as permiss\u00f5es. Por exemplo, se quisermos dar permiss\u00e3o para o arquivo 'EP 1' ler, escrever e executar arquivos do usu\u00e1rio dono do arquivo, ler e escrever arquivos do grupo de usu\u00e1rios e de todos os usu\u00e1rios, n\u00f3s devemos fazer o seguinte: chmod 766 'EP 1' Manipulando o sistema Executar como Super Usu\u00e1rio sudo comando a ser executado Procurar o caminho para um arquivo locate nome do arquivo Exibir os processos em execu\u00e7\u00e3o ps Parar um processo kill ID do processo Manipulando pacotes (Apenas para distribui\u00e7\u00f5es baseadas no Debian) Instalando pacotes apt-get install nome do pacote. Removendo pacotes apt-get remove nome do pacote Removendo pacote e seus arquivos de configura\u00e7\u00e3o apt-get purge nome do pacote Atualizando pacotes apt-get -u upgrade Removendo pacotes que n\u00e3o ser\u00e3o mais utilizados apt-get clean apt-get autoclean Adicionando novos reposit\u00f3rios de pacotes Utilize o comando sudo nano /etc/apt/sources.list Com o editor de texto Nano escreva, no final do arquivo, o nome do reposit\u00f3rio que deseja adicionar. Atualizando o \u00edndice de resposit\u00f3rios apt-get update Comandos \u00fateis (e legais) Comparar a diferen\u00e7a entre dois c\u00f3digos linha por linha diff c\u00f3digo 1 c\u00f3digo 2 Procurar express\u00f5es dentro de arquivos grep express\u00e3o arquivo Mostrar o manual de um comando man comando YES yes Firmware Simula\u00e7\u00e3o/Gazebo Iniciar gazebo O comando abaixo abre o gazebo gazebo op\u00e7\u00f5es de inicializa\u00e7\u00e3o Mas tamb\u00e9m da para abr\u00ed-lo com mais condi\u00e7\u00f5es. Pode abrir diretamente um mundo usando o mesmo comando colocando o caminho para o .world , ou colocando o nome do arquivo estando na pasta world. Por exemplo: gazebo exemplo.world Mais uma explica\u00e7\u00e3o ou informa\u00e7es de uso sobre o comando ou codigo Tamb\u00e9m pode iniciar o gazebo fazendo a simula\u00e7\u00e3o da PX4. Estando na raiz do Firmware d\u00ea o comando: make px4_sitl gazebo E tamb\u00e9m pode inciar o Gazebo junto com o ROS usando o roslaunch, e \u00e9 bom por que da para abrir rosnodes, packages e outras fun\u00e7\u00f5es do ros junto. roslaunch gazebo_ros exemplo.launch No roslaunch pode colocar v\u00e1rios argumentos de incializa\u00e7\u00e3o, clique aqui para ver Tutorial de inicializa\u00e7\u00e3o do gazebo ROS Terminal Esses s\u00e3o os mais comuns. Se voc\u00ea digitar s\u00f3 o in\u00edcio do comando (tipo rostopic ) ele deve te dar a lista de todos. Colocar -h no final pede ajuda sobre a sintaxe. Topics * Lista todos os t\u00f3picos ativos rostopic list * Informa\u00e7\u00f5es sobre um t\u00f3pico rostopic info [t\u00f3pico] * V\u00ea o que t\u00e1 sendo publicado no t\u00f3pico rostopic echo [t\u00f3pico] * V\u00ea a frequ\u00eancia com que est\u00e3o publicando no t\u00f3pico rostopic hz [t\u00f3pico] * Publica no t\u00f3pico rostopic pub [t\u00f3pico] [tipo de mensagem] [args...] Messages * Lista todas os tipos de mensagem (s\u00e3o muitos kkk) rosmsg list * Informa\u00e7\u00f5es sobre um tipo de mensagem rosmsg show [mensagem] Services * Lista todos os servi\u00e7os rosservice list * Informa\u00e7\u00f5es sobre um servi\u00e7o rosservice info [servi\u00e7o] * Chama um servi\u00e7o rosservice call [servi\u00e7o] [args...] Nodes * Lista todos os nodes rosnode list * Informa\u00e7\u00f5es sobre um node rosnode info [node] Params * Lista todos os par\u00e2metros rosparam list * L\u00ea um par\u00e2metro rosparam get [param] * Escreve em um par\u00e2metro rosparam set [param] [valor] Execu\u00e7\u00e3o * Inicia o ROS roscore * Executa um node rosrun [package] [node] * Executa um launchfile (n\u00e3o requer roscore) roslaunch [package] [arquivo .launch] [argumento:=valor ...] ROS Bags * Grava os t\u00f3picos 1, 2 e 3 rosbag record [topico1] [topico2] [topico3] e 3 * Grava todos os t\u00f3picos rosbag record -a * Executa um rosbag rosbag play [nome_da_rosbag].bag Outros * Acha um package e d\u00e1 cd pra ele roscd [package] * Grafo dos t\u00f3picos rqt_graph * RViz (visualiza\u00e7\u00e3o de mensagens) rviz Catkin * Cria o workspace (deve ser executado DENTRO DA PASTA SRC DO WORKSPACE) catkin_init_workspace * Compila o workspace catkin build * Limpa o workspace (n\u00e3o apaga os packages) catkin clean * Deinicializa o workspace catkin clean --deinit * Cria um package (execute dentro da src) catkin_create_pkg [nome no package] [dependencias...] Python Os comandos n\u00e3o est\u00e3o em ordem pra serem executados em um programa, apenas listados. # Essa linha precisa ser a primeira de todo c\u00f3digo #!/usr/bin/env python # Tudo que vc faz passa por aqui, precisa importar import rospy # Declara que o programa \u00e9 um node (NECESS\u00c1RIO) rospy.init_node( nome_do_node ) # Cria um Publisher pub = rospy.Publisher( nome_do_topico , TipoDeMsg, queue_size=10) # Publica uma mensagem pub.publish(ObjetoMensagem) # Cria um Subscriber rospy.Subscriber( nome_do_topico , TipoDeMsg, funcao_de_callback) # Deixa o programa executando (sem fazer nada) rospy.spin() # Cria um Rate rate = rospy.Rate(frequencia_Hz) # Espera completar o ciclo do rate rate.sleep() # Verifica se o ROS fechou (geralmente usado como condi\u00e7\u00e3o em um while) rospy.is_shutdown()","title":"Formul\u00e1rio"},{"location":"Geral/formulario/#formulario","text":"","title":"F\u00f3rmul\u00e1rio"},{"location":"Geral/formulario/#linux","text":"","title":"Linux"},{"location":"Geral/formulario/#basico","text":"Mostrar o caminho atual pwd Listar os arquivos no diret\u00f3rio atual ls Mudar de diret\u00f3rio cd caminho do diret\u00f3rio Mostar o conte\u00fado de um arquivo cat arquivo Abrir um arquivo em um editor de texto nano nome do arquivo","title":"B\u00e1sico"},{"location":"Geral/formulario/#manipulando-arquivos-e-diretorios","text":"Criar arquivo em branco touch arquivo Copiar arquivos cp arquivo opiado diret\u00f3rio de destino Mover arquivos mv arquivo destino Renomear arquivos mv nome atual do arquivo novo nome Deletar arquivos rm arquivo Criar diret\u00f3rio mkdir nome do diret\u00f3rio Deletar diret\u00f3rios vazios rmdir diret\u00f3rio Deletar diret\u00f3rios com arquivos rm -r diret\u00f3rio Modificar as permiss\u00f5es de um arquivo Todo arquivo pode possuir 8 tipos de permiss\u00f5es diferentes: 0 - Sem permiss\u00e3o 1 - Permiss\u00e3o para executar 2 - Permiss\u00e3o para escrever 3 - Permiss\u00e3o para escrever e executar 4 - Permiss\u00e3o para ler 5 - Permiss\u00e3o para ler e executar 6 - Permiss\u00e3o para ler e escrever 7 - Permiss\u00e3o para ler, escrever e executar Essa permiss\u00e3o pode ser dada para interagir com 3 tipos de usu\u00e1rios: O dono - representa o usu\u00e1rio dono do arquivo no computador. Grupos - Grupos de mais de um usu\u00e1rio. Todos - Todos os usu\u00e1rios naquele computador. Para alterar as permiss\u00f5es de um arquivo, \u00e9 necess\u00e1rio utilizar o comando chmod seguido de um n\u00famero de 3 algarimso, onde o primeiro representa as permiss\u00f5es para o usu\u00e1rio dono do arquivo, o segundo, do grupo de usu\u00e1rios e o terceiro, de todos os usu\u00e1rios e, por \u00faltimo, o nome do arquivo que queremos alterar as permiss\u00f5es. Por exemplo, se quisermos dar permiss\u00e3o para o arquivo 'EP 1' ler, escrever e executar arquivos do usu\u00e1rio dono do arquivo, ler e escrever arquivos do grupo de usu\u00e1rios e de todos os usu\u00e1rios, n\u00f3s devemos fazer o seguinte: chmod 766 'EP 1'","title":"Manipulando arquivos e diret\u00f3rios"},{"location":"Geral/formulario/#manipulando-o-sistema","text":"Executar como Super Usu\u00e1rio sudo comando a ser executado Procurar o caminho para um arquivo locate nome do arquivo Exibir os processos em execu\u00e7\u00e3o ps Parar um processo kill ID do processo","title":"Manipulando o sistema"},{"location":"Geral/formulario/#manipulando-pacotes-apenas-para-distribuicoes-baseadas-no-debian","text":"Instalando pacotes apt-get install nome do pacote. Removendo pacotes apt-get remove nome do pacote Removendo pacote e seus arquivos de configura\u00e7\u00e3o apt-get purge nome do pacote Atualizando pacotes apt-get -u upgrade Removendo pacotes que n\u00e3o ser\u00e3o mais utilizados apt-get clean apt-get autoclean Adicionando novos reposit\u00f3rios de pacotes Utilize o comando sudo nano /etc/apt/sources.list Com o editor de texto Nano escreva, no final do arquivo, o nome do reposit\u00f3rio que deseja adicionar. Atualizando o \u00edndice de resposit\u00f3rios apt-get update","title":"Manipulando pacotes (Apenas para distribui\u00e7\u00f5es baseadas no Debian)"},{"location":"Geral/formulario/#comandos-uteis-e-legais","text":"Comparar a diferen\u00e7a entre dois c\u00f3digos linha por linha diff c\u00f3digo 1 c\u00f3digo 2 Procurar express\u00f5es dentro de arquivos grep express\u00e3o arquivo Mostrar o manual de um comando man comando YES yes","title":"Comandos \u00fateis (e legais)"},{"location":"Geral/formulario/#firmware","text":"","title":"Firmware"},{"location":"Geral/formulario/#simulacaogazebo","text":"","title":"Simula\u00e7\u00e3o/Gazebo"},{"location":"Geral/formulario/#iniciar-gazebo","text":"O comando abaixo abre o gazebo gazebo op\u00e7\u00f5es de inicializa\u00e7\u00e3o Mas tamb\u00e9m da para abr\u00ed-lo com mais condi\u00e7\u00f5es. Pode abrir diretamente um mundo usando o mesmo comando colocando o caminho para o .world , ou colocando o nome do arquivo estando na pasta world. Por exemplo: gazebo exemplo.world Mais uma explica\u00e7\u00e3o ou informa\u00e7es de uso sobre o comando ou codigo Tamb\u00e9m pode iniciar o gazebo fazendo a simula\u00e7\u00e3o da PX4. Estando na raiz do Firmware d\u00ea o comando: make px4_sitl gazebo E tamb\u00e9m pode inciar o Gazebo junto com o ROS usando o roslaunch, e \u00e9 bom por que da para abrir rosnodes, packages e outras fun\u00e7\u00f5es do ros junto. roslaunch gazebo_ros exemplo.launch No roslaunch pode colocar v\u00e1rios argumentos de incializa\u00e7\u00e3o, clique aqui para ver Tutorial de inicializa\u00e7\u00e3o do gazebo","title":"Iniciar gazebo"},{"location":"Geral/formulario/#ros","text":"","title":"ROS"},{"location":"Geral/formulario/#terminal","text":"Esses s\u00e3o os mais comuns. Se voc\u00ea digitar s\u00f3 o in\u00edcio do comando (tipo rostopic ) ele deve te dar a lista de todos. Colocar -h no final pede ajuda sobre a sintaxe. Topics * Lista todos os t\u00f3picos ativos rostopic list * Informa\u00e7\u00f5es sobre um t\u00f3pico rostopic info [t\u00f3pico] * V\u00ea o que t\u00e1 sendo publicado no t\u00f3pico rostopic echo [t\u00f3pico] * V\u00ea a frequ\u00eancia com que est\u00e3o publicando no t\u00f3pico rostopic hz [t\u00f3pico] * Publica no t\u00f3pico rostopic pub [t\u00f3pico] [tipo de mensagem] [args...]","title":"Terminal"},{"location":"Geral/formulario/#messages","text":"* Lista todas os tipos de mensagem (s\u00e3o muitos kkk) rosmsg list * Informa\u00e7\u00f5es sobre um tipo de mensagem rosmsg show [mensagem]","title":"Messages"},{"location":"Geral/formulario/#services","text":"* Lista todos os servi\u00e7os rosservice list * Informa\u00e7\u00f5es sobre um servi\u00e7o rosservice info [servi\u00e7o] * Chama um servi\u00e7o rosservice call [servi\u00e7o] [args...]","title":"Services"},{"location":"Geral/formulario/#nodes","text":"* Lista todos os nodes rosnode list * Informa\u00e7\u00f5es sobre um node rosnode info [node]","title":"Nodes"},{"location":"Geral/formulario/#params","text":"* Lista todos os par\u00e2metros rosparam list * L\u00ea um par\u00e2metro rosparam get [param] * Escreve em um par\u00e2metro rosparam set [param] [valor]","title":"Params"},{"location":"Geral/formulario/#execucao","text":"* Inicia o ROS roscore * Executa um node rosrun [package] [node] * Executa um launchfile (n\u00e3o requer roscore) roslaunch [package] [arquivo .launch] [argumento:=valor ...]","title":"Execu\u00e7\u00e3o"},{"location":"Geral/formulario/#ros-bags","text":"* Grava os t\u00f3picos 1, 2 e 3 rosbag record [topico1] [topico2] [topico3] e 3 * Grava todos os t\u00f3picos rosbag record -a * Executa um rosbag rosbag play [nome_da_rosbag].bag","title":"ROS Bags"},{"location":"Geral/formulario/#outros","text":"* Acha um package e d\u00e1 cd pra ele roscd [package] * Grafo dos t\u00f3picos rqt_graph * RViz (visualiza\u00e7\u00e3o de mensagens) rviz","title":"Outros"},{"location":"Geral/formulario/#catkin","text":"* Cria o workspace (deve ser executado DENTRO DA PASTA SRC DO WORKSPACE) catkin_init_workspace * Compila o workspace catkin build * Limpa o workspace (n\u00e3o apaga os packages) catkin clean * Deinicializa o workspace catkin clean --deinit * Cria um package (execute dentro da src) catkin_create_pkg [nome no package] [dependencias...]","title":"Catkin"},{"location":"Geral/formulario/#python","text":"Os comandos n\u00e3o est\u00e3o em ordem pra serem executados em um programa, apenas listados. # Essa linha precisa ser a primeira de todo c\u00f3digo #!/usr/bin/env python # Tudo que vc faz passa por aqui, precisa importar import rospy # Declara que o programa \u00e9 um node (NECESS\u00c1RIO) rospy.init_node( nome_do_node ) # Cria um Publisher pub = rospy.Publisher( nome_do_topico , TipoDeMsg, queue_size=10) # Publica uma mensagem pub.publish(ObjetoMensagem) # Cria um Subscriber rospy.Subscriber( nome_do_topico , TipoDeMsg, funcao_de_callback) # Deixa o programa executando (sem fazer nada) rospy.spin() # Cria um Rate rate = rospy.Rate(frequencia_Hz) # Espera completar o ciclo do rate rate.sleep() # Verifica se o ROS fechou (geralmente usado como condi\u00e7\u00e3o em um while) rospy.is_shutdown()","title":"Python"},{"location":"Geral/preflightcheck/","text":"Protocolo de Seguran\u00e7a Essas s\u00e3o as instru\u00e7\u00f5es para se realizar obrigatoriamente antes de cada v\u00f4o, para garantir seguran\u00e7a do operador, das pessoas p\u0155oximas, e garantir a integridade do drone. Instru\u00e7\u00f5es: Verificar se a tens\u00e3o da bateria esta cheia (4.2v/celula) em todas as celulas Fixar bateria e h\u00e9lices de acordo com a orienta\u00e7\u00e3o ( Obs: Para as h\u00e9lices, s\u00e3o dois tipos e cada par estar\u00e1 diametralmente opostos ) Pegar o drone Segurar em dois bra\u00e7os diametralmente opostos Chacoalhar o drone Verificar se nenhum componente cai ou est\u00e1 em estado cr\u00edtico Pegar no outro par e repetir o procedimento de chacoalhar Colocar o drone em posi\u00e7\u00e3o horizontal Girar todas as h\u00e9lices para verificar se nenhum componente vai bater nelas ou se elas est\u00e3o soltas Verificar se todas as antenas n\u00e3o est\u00e3o em rota de colis\u00e3o com o drone se n\u00e3o haver\u00e1 movimenta\u00e7\u00e3o delas para n\u00e3o houver contato com h\u00e9lices e/ou outros componentes Com aux\u00edlio de uma chave allen cheque e aperte todos os parafusos Pegar o radiocontrole Pegar o m\u00f3dulo de telemtria externa Verificar se condi\u00e7\u00f5es clim\u00e1tica s\u00e3o propensas ao voo No local de v\u00f4o, verificar pontos de poss\u00edvel colis\u00e3o com o drone ( Como \u00e1rvores, pr\u00e9dios, postes, fios, rota a\u00e9rea comercial). Verificar presen\u00e7a de pessoas pr\u00f3ximas ao local de v\u00f4o ( Caso haja pessoas, notific\u00e1-las sobre o v\u00f4o ) Verificar as conex\u00f5es na controladora de v\u00f4o, computador de bordo e em outros componentes Ligar o controle Conectar a bateria Acoplar o m\u00f3dulo de telemetria (Nunca voar sem QGroundControl) Abrir QGroundControl e verificar par\u00e2metros do safety Verificar conex\u00e3o do drone/Telemetria Pressionar safety switch Verificar funcionamento do GPS Checar se est\u00e1 tudo ok pelo \u00e1udio da QGroundControl (Checar todos os bot\u00f5es) Armar o drone Testar motores sem decolagem Testar kill switch sem decolagem V\u00f4o baixo Teste de aterrisagem Verificar o espa\u00e7o vertical Verificar o par\u00e2metro do RTL Testar o RTL (Dar kill ap\u00f3s) Ent\u00e3o v\u00f4o permitido!!!","title":"Protocolo de Seguran\u00e7a"},{"location":"Geral/preflightcheck/#protocolo-de-seguranca","text":"Essas s\u00e3o as instru\u00e7\u00f5es para se realizar obrigatoriamente antes de cada v\u00f4o, para garantir seguran\u00e7a do operador, das pessoas p\u0155oximas, e garantir a integridade do drone.","title":"Protocolo de Seguran\u00e7a"},{"location":"Geral/preflightcheck/#instrucoes","text":"Verificar se a tens\u00e3o da bateria esta cheia (4.2v/celula) em todas as celulas Fixar bateria e h\u00e9lices de acordo com a orienta\u00e7\u00e3o ( Obs: Para as h\u00e9lices, s\u00e3o dois tipos e cada par estar\u00e1 diametralmente opostos ) Pegar o drone Segurar em dois bra\u00e7os diametralmente opostos Chacoalhar o drone Verificar se nenhum componente cai ou est\u00e1 em estado cr\u00edtico Pegar no outro par e repetir o procedimento de chacoalhar Colocar o drone em posi\u00e7\u00e3o horizontal Girar todas as h\u00e9lices para verificar se nenhum componente vai bater nelas ou se elas est\u00e3o soltas Verificar se todas as antenas n\u00e3o est\u00e3o em rota de colis\u00e3o com o drone se n\u00e3o haver\u00e1 movimenta\u00e7\u00e3o delas para n\u00e3o houver contato com h\u00e9lices e/ou outros componentes Com aux\u00edlio de uma chave allen cheque e aperte todos os parafusos Pegar o radiocontrole Pegar o m\u00f3dulo de telemtria externa Verificar se condi\u00e7\u00f5es clim\u00e1tica s\u00e3o propensas ao voo No local de v\u00f4o, verificar pontos de poss\u00edvel colis\u00e3o com o drone ( Como \u00e1rvores, pr\u00e9dios, postes, fios, rota a\u00e9rea comercial). Verificar presen\u00e7a de pessoas pr\u00f3ximas ao local de v\u00f4o ( Caso haja pessoas, notific\u00e1-las sobre o v\u00f4o ) Verificar as conex\u00f5es na controladora de v\u00f4o, computador de bordo e em outros componentes Ligar o controle Conectar a bateria Acoplar o m\u00f3dulo de telemetria (Nunca voar sem QGroundControl) Abrir QGroundControl e verificar par\u00e2metros do safety Verificar conex\u00e3o do drone/Telemetria Pressionar safety switch Verificar funcionamento do GPS Checar se est\u00e1 tudo ok pelo \u00e1udio da QGroundControl (Checar todos os bot\u00f5es) Armar o drone Testar motores sem decolagem Testar kill switch sem decolagem V\u00f4o baixo Teste de aterrisagem Verificar o espa\u00e7o vertical Verificar o par\u00e2metro do RTL Testar o RTL (Dar kill ap\u00f3s) Ent\u00e3o v\u00f4o permitido!!!","title":"Instru\u00e7\u00f5es:"},{"location":"Hardware/Componentes/","text":"Guia dos Componentes Clique em cada um e voc\u00ea vai ser redirecionado para um docs com as informa\u00e7\u00f5es at\u00e9 agora obtidas para instala\u00e7\u00e3o, uso, erros e links... Qualquer d\u00favida e/ou problema pode colocar uma issue! :) Componentes Ultrasonic Sensor SU04 UBEC Henge 6V 6A TONQUU Brushless ESC 40A Telemetria RFD900+ Telemetria Holybro V3 RPLIDAR S1 360 Receiver FrSky Taranis X8R Radiocontrole FrSky Taranis Q X7 Pixracer Pixhawk 4 Odroid XU4 NVIDIA Jetson TX1 Motor AIR A 2508 1200 KV LIDAR TFMini Intel RealSense t265 Here3 RTK GPS v2 H\u00e9lice Gemfan 8045 Grove IR Array MLX90640 110 GPS Holybro Pixhawk 4 Dragonboard 410c CUAV PX4FLOW 2.1 C\u00e2mera UVC OV4689 C\u00e2mera t\u00e9rmica Grove MLX90640 Pasta geral Clique aqui para ir at\u00e9 a pasta geral com todos os componentes","title":"Componentes"},{"location":"Hardware/Componentes/#guia-dos-componentes","text":"Clique em cada um e voc\u00ea vai ser redirecionado para um docs com as informa\u00e7\u00f5es at\u00e9 agora obtidas para instala\u00e7\u00e3o, uso, erros e links... Qualquer d\u00favida e/ou problema pode colocar uma issue! :)","title":"Guia dos Componentes"},{"location":"Hardware/Componentes/#componentes","text":"Ultrasonic Sensor SU04 UBEC Henge 6V 6A TONQUU Brushless ESC 40A Telemetria RFD900+ Telemetria Holybro V3 RPLIDAR S1 360 Receiver FrSky Taranis X8R Radiocontrole FrSky Taranis Q X7 Pixracer Pixhawk 4 Odroid XU4 NVIDIA Jetson TX1 Motor AIR A 2508 1200 KV LIDAR TFMini Intel RealSense t265 Here3 RTK GPS v2 H\u00e9lice Gemfan 8045 Grove IR Array MLX90640 110 GPS Holybro Pixhawk 4 Dragonboard 410c CUAV PX4FLOW 2.1 C\u00e2mera UVC OV4689 C\u00e2mera t\u00e9rmica Grove MLX90640","title":"Componentes"},{"location":"Hardware/Componentes/#pasta-geral","text":"Clique aqui para ir at\u00e9 a pasta geral com todos os componentes","title":"Pasta geral"},{"location":"Hardware/ControleRC/","text":"Controle Futaba T14SG Objetivo Descrever os comandos configurados no Controle RC. Orientar a pilotagem e salvar um padrao de configuracao. Materiais necess\u00e1rios Controle: Futaba T14SG. Antena: Ground Station (FPV Radio Telemetry Ground Module) Software: QgroundControl Passo a passo Apos ligar o receptor RC na pixhawk, no radio controle Futaba: Use o botao touch rotativo no canto inferior direito. Role ate mudar para \"yes\". Bind Control: (Conectar pela primeira vez o controle no drone) lnk - system - link (clique no RTN) Se tiver dado certo o led do receptor do radio ficara verde Outros coment\u00e1rios Provavelmente o buzzer vai fazer algum barulinho e voce vai querer descobrir o que deve fazer para enfim seu dorne voar. Para entender os barulinhos do seu drone confira: Link dos sons do Buzzer Refer\u00eancias Links que tenham te ajudado a escrever o guia, ou que sejam \u00fateis aos outros pra a compreens\u00e3o de algo.","title":"Controle"},{"location":"Hardware/ControleRC/#controle-futaba-t14sg","text":"","title":"Controle Futaba T14SG"},{"location":"Hardware/ControleRC/#objetivo","text":"Descrever os comandos configurados no Controle RC. Orientar a pilotagem e salvar um padrao de configuracao.","title":"Objetivo"},{"location":"Hardware/ControleRC/#materiais-necessarios","text":"Controle: Futaba T14SG. Antena: Ground Station (FPV Radio Telemetry Ground Module) Software: QgroundControl","title":"Materiais necess\u00e1rios"},{"location":"Hardware/ControleRC/#passo-a-passo","text":"Apos ligar o receptor RC na pixhawk, no radio controle Futaba: Use o botao touch rotativo no canto inferior direito. Role ate mudar para \"yes\". Bind Control: (Conectar pela primeira vez o controle no drone) lnk - system - link (clique no RTN) Se tiver dado certo o led do receptor do radio ficara verde","title":"Passo a passo"},{"location":"Hardware/ControleRC/#outros-comentarios","text":"Provavelmente o buzzer vai fazer algum barulinho e voce vai querer descobrir o que deve fazer para enfim seu dorne voar. Para entender os barulinhos do seu drone confira: Link dos sons do Buzzer","title":"Outros coment\u00e1rios"},{"location":"Hardware/ControleRC/#referencias","text":"Links que tenham te ajudado a escrever o guia, ou que sejam \u00fateis aos outros pra a compreens\u00e3o de algo.","title":"Refer\u00eancias"},{"location":"Hardware/Drones/","text":"Guia dos Drones Clique em cada um e voc\u00ea vai ser redirecionado para uma pasta no drive com as informa\u00e7\u00f5es at\u00e9 agora obtidas para montagem, lista de componentes, uso, erros, cuidados e links... etc... Qualquer d\u00favida e/ou problema pode colocar uma issue! :) Drones Swarm 2020 SKY3100 DJI S1000 vers\u00e3o Skyrats Indoor 2020 Pasta geral Clique aqui para ir at\u00e9 a pasta geral com todos os drones","title":"Drones"},{"location":"Hardware/Drones/#guia-dos-drones","text":"Clique em cada um e voc\u00ea vai ser redirecionado para uma pasta no drive com as informa\u00e7\u00f5es at\u00e9 agora obtidas para montagem, lista de componentes, uso, erros, cuidados e links... etc... Qualquer d\u00favida e/ou problema pode colocar uma issue! :)","title":"Guia dos Drones"},{"location":"Hardware/Drones/#drones","text":"Swarm 2020 SKY3100 DJI S1000 vers\u00e3o Skyrats Indoor 2020","title":"Drones"},{"location":"Hardware/Drones/#pasta-geral","text":"Clique aqui para ir at\u00e9 a pasta geral com todos os drones","title":"Pasta geral"},{"location":"Hardware/ESCs/","text":"Como escolher um ESC? Individual ou 4 em 1? S\u00e3o dois tipos, um ESC que controla um motor s\u00f3, o individual ou os que controlam mais de um motor, os 4 em 1. Vantagens x Desvantagens: O ESC m\u00faltiplo \u00e9 mais caro que 4 ESCs, e se quebrar tem que trocar inteiro, ao inv\u00e9s de trocar s\u00f3 um ESC, por\u00e9m ele \u00e9 menor e mais leve. Tens\u00e3o e Corrente Devemos levar em considera\u00e7\u00e3o a corrente m\u00e1xima do motor, pois \u00e9 ela que pode danificar o ESC, e a partir dela decidir o valor do ESC que vai comprar. Primeiro, ver se a corrente estiver muito pr\u00f3xima de um n\u00famero redondo(30, 40, 50... etc), para cima, pode usar um ESC arredondado para baixo, pois o pr\u00f3prio vento das h\u00e9lices faz um grande resfriamento j\u00e1, mas por\u00e9m se a corrente estiver mais afastada, como um com m\u00e1ximo de 45, 46, \u00e9 melhor arredondar para cima, por quest\u00f5es de seguran\u00e7a e vida \u00fatil do ESC, por mais que o peso e o tamanho sejam maiores. Com rela\u00e7\u00e3o a tens\u00e3o, deve-se escolher um ESC de acordo com a tens\u00e3o da bateria LiPO, seja de 4s, 6s, etc... Refer\u00eancias https://dronenodes.com/drone-esc-electronic-speed-controller/ https://oscarliang.com/choose-esc-racing-drones/#:~:text=The first thing to look,with your ESC in flames !","title":"Guia de Escolha de ESCs"},{"location":"Hardware/ESCs/#como-escolher-um-esc","text":"","title":"Como escolher um ESC?"},{"location":"Hardware/ESCs/#individual-ou-4-em-1","text":"S\u00e3o dois tipos, um ESC que controla um motor s\u00f3, o individual ou os que controlam mais de um motor, os 4 em 1.","title":"Individual ou 4 em 1?"},{"location":"Hardware/ESCs/#vantagens-x-desvantagens","text":"O ESC m\u00faltiplo \u00e9 mais caro que 4 ESCs, e se quebrar tem que trocar inteiro, ao inv\u00e9s de trocar s\u00f3 um ESC, por\u00e9m ele \u00e9 menor e mais leve.","title":"Vantagens x Desvantagens:"},{"location":"Hardware/ESCs/#tensao-e-corrente","text":"Devemos levar em considera\u00e7\u00e3o a corrente m\u00e1xima do motor, pois \u00e9 ela que pode danificar o ESC, e a partir dela decidir o valor do ESC que vai comprar. Primeiro, ver se a corrente estiver muito pr\u00f3xima de um n\u00famero redondo(30, 40, 50... etc), para cima, pode usar um ESC arredondado para baixo, pois o pr\u00f3prio vento das h\u00e9lices faz um grande resfriamento j\u00e1, mas por\u00e9m se a corrente estiver mais afastada, como um com m\u00e1ximo de 45, 46, \u00e9 melhor arredondar para cima, por quest\u00f5es de seguran\u00e7a e vida \u00fatil do ESC, por mais que o peso e o tamanho sejam maiores. Com rela\u00e7\u00e3o a tens\u00e3o, deve-se escolher um ESC de acordo com a tens\u00e3o da bateria LiPO, seja de 4s, 6s, etc...","title":"Tens\u00e3o e Corrente"},{"location":"Hardware/ESCs/#referencias","text":"https://dronenodes.com/drone-esc-electronic-speed-controller/ https://oscarliang.com/choose-esc-racing-drones/#:~:text=The first thing to look,with your ESC in flames !","title":"Refer\u00eancias"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/","text":"Introdu\u00e7\u00e3o ao Hardware Componentes e Montagem Motores, ESCs e H\u00e9lices Motores: Boa parte dos motores p/ drones s\u00e3o brushless, eles s\u00e3o conectados aos ESCs. Em um drone, metade dos motores precisam girar em um sentido, e a outra metade em outro, assim evita que o drone tenha um torque desigual, fazendo ele girar no pr\u00f3prio eixo. (Mesma fun\u00e7\u00e3o da pazinha pequena no rabo do helic\u00f3ptero). ESCs: Tem a fun\u00e7\u00e3o de transformar o sinal de PWM (Controle de velocidade por pulsos), de baixa pot\u00eancia, que vem da controladora de voo, em um sinal de alta pot\u00eancia, usando a energia da bateria. H\u00e9lices: Elas existem de dois tipos, para motores que v\u00e3o rodar em sentido hor\u00e1rio e antihor\u00e1rio. Controladora de v\u00f4o e PMB Controladora de voo: \u00c9 um dos principais componentes do drone. \u00c9 respons\u00e1vel por receber e processar sinais de entrada dos sensores e as sa\u00eddas para os motores e eventuais outros atuadores. Normalmente possuem sensores importantes embarcados nativamente, como girosc\u00f3pio, aceler\u00f4metro, b\u00fassola entre outros. Sua principal fun\u00e7\u00e3o \u00e9 mapear os comandos recebidos para controlar os movimentos de ROLL, PITCH e YAW do drone, al\u00e9m de estabilizar o voo. PMB: _Power Management Board _\u00e9 a placa respons\u00e1vel por distribuir a pot\u00eancia pelo drone, alimentando todos os componentes necess\u00e1rios, e no caso da Pixhawk 4 esta placa tamb\u00e9m \u00e9 respons\u00e1vel por medir o consumo de corrente e a tens\u00e3o da bateria bem como distribuir os sinais para os ESCs e outros componentes que usem entradas de FMU. Baterias: As baterias t\u00eam uma fun\u00e7\u00e3o super importante na cria\u00e7\u00e3o de drones, elas s\u00e3o as respons\u00e1veis pela quantidade de tempo que o drone permanecer\u00e1 no c\u00e9u! Quanto mais carga a bateria possui, mais tempo de voo (desconsiderando o peso \u00e9 claro). Telemetria: Respons\u00e1vel por transmitir informa\u00e7\u00f5es e comandos do Drone para o solo e vice-versa. Pode ser utilizada para transmitir o status da bateria, posi\u00e7\u00e3o atual, imagens e v\u00eddeos capturados e comandar o drone caso o computador de bordo n\u00e3o esteja funcionando como deveria. GPS: Permite descobrir a latitude, longitude, velocidade e dire\u00e7\u00e3o do drone baseado em uma constela\u00e7\u00e3o de sat\u00e9lites. Controle e Receptor R\u00e1dio Controle: Componente que transmite pilotar o drone manualmente, atrav\u00e9s da transmiss\u00e3o de informa\u00e7\u00f5es que alteram sua posi\u00e7\u00e3o, permitindo que ele execute tarefas como Roll, Pitch e Yaw, assim como trocar modos de voo e tomar medidas de seguran\u00e7a. Receptor: Componente que recebe as informa\u00e7\u00f5es dadas pelo R\u00e1dio Controle, e as transmite para a Controladora de voo. Computador de bordo Ele vai rodar um sistema operacional pr\u00f3prio e alguns scripts, e assim, conectado \u00e0 controladora de voo, podendo deixar o drone aut\u00f4nomo. Sensores e outros componentes Lidar: \u00c9 um m\u00e9todo de sensoriamento que utiliza pulsos de laser para medir dist\u00e2ncias dando assim uma vis\u00e3o tridimensional para nosso drone com alt\u00edssima precis\u00e3o. C\u00e2mera t\u00e9rmica: Cria imagens baseado na quantidade de radia\u00e7\u00e3o emitida pelos corpos, o que nos permite estimar a sua temperatura. N\u00f3s utilizamos para identificar pessoas (ou dummies) em lugares com baixa visibilidade. Optical Flow: \u00c9 uma c\u00e2mera que mede o movimento do drone baseado na movimenta\u00e7\u00e3o dos pontos presentes na imagem. O Drone (1p) Ground Station Q Ground Control: \u00c9 a interface gr\u00e1fica utilizada em um computador/notebook/celular para obter uma comunica\u00e7\u00e3o drone-piloto que vai al\u00e9m do que apenas um r\u00e1dio controle. Ela permite calibrar o drone, configurar par\u00e2metros, monitorar, fazer voo simples e criar planejamentos de voos. Firmware Firmware \u00e9 o software embarcado na controladora de voo, e tem a fun\u00e7\u00e3o de fazer o controle mais b\u00e1sico e de baixo n\u00edvel do drone. Exemplos: PX4 Ardupilot Boas pr\u00e1ticas de Hardware (1p) N\u00e3o queimar o amiguinho com ferro de solda? goxto rs Muito cuidado ao manusear as baterias LiPo pois s\u00e3o muito vol\u00e1teis, sempre respeitando os procedimentos para carregamento e os n\u00edveis de descarga recomendados (descarga m\u00e1xima 20%) Verificar as liga\u00e7\u00f5es de acordo com os devidos circuitos esquem\u00e1ticos antes de energizar qualquer circuito a fim de evitar a queima de componentes ou riscos ao operador Sempre se atentar para a qualidade e seguran\u00e7a das liga\u00e7\u00f5es ao testar componentes isolados em bancada, evitando curtos e danos aos equipamentos. Boas pr\u00e1ticas de v\u00f4o (1p) Protocolo de v\u00f4o Sempre usar o nosso protocolo de v\u00f4o antes de pilotar algum drone feito pela equipe(https://skyrats.github.io/knowledge_base/Introdu\u00e7\u00e3o/preflightcheck/), caso seja um drone comercial, usar o pr\u00f3prio protocolo de v\u00f4o. Modos de v\u00f4o b\u00e1sicos da PX4 (https://docs.px4.io/v1.9.0/en/flight_modes/) Position O throttle fica no meio do canal Usa o GPS para controlar e ajustar sua posi\u00e7\u00e3o Mais f\u00e1cil de controlar Stabilized O throttle fica na parte inferior do canal N\u00e3o usa GPS para ajustar posi\u00e7\u00e3o Meio dif\u00edcil de controlar Altitude Igual o stabilized, por\u00e9m mant\u00e9m a altitude do drone controlada Manual Controle 100% manual do drone, sem estabiliza\u00e7\u00f5es. Muito dif\u00edcil de controlar Todos esses modos existem no ardupilot, s\u00f3 que com alguns outros nomes: https://ardupilot.org/plane/docs/flight-modes.html","title":"Introdu\u00e7\u00e3o ao Hardware"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#introducao-ao-hardware","text":"","title":"Introdu\u00e7\u00e3o ao Hardware"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#componentes-e-montagem","text":"","title":"Componentes e Montagem"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#motores-escs-e-helices","text":"Motores: Boa parte dos motores p/ drones s\u00e3o brushless, eles s\u00e3o conectados aos ESCs. Em um drone, metade dos motores precisam girar em um sentido, e a outra metade em outro, assim evita que o drone tenha um torque desigual, fazendo ele girar no pr\u00f3prio eixo. (Mesma fun\u00e7\u00e3o da pazinha pequena no rabo do helic\u00f3ptero). ESCs: Tem a fun\u00e7\u00e3o de transformar o sinal de PWM (Controle de velocidade por pulsos), de baixa pot\u00eancia, que vem da controladora de voo, em um sinal de alta pot\u00eancia, usando a energia da bateria. H\u00e9lices: Elas existem de dois tipos, para motores que v\u00e3o rodar em sentido hor\u00e1rio e antihor\u00e1rio.","title":"Motores, ESCs e H\u00e9lices"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#controladora-de-voo-e-pmb","text":"Controladora de voo: \u00c9 um dos principais componentes do drone. \u00c9 respons\u00e1vel por receber e processar sinais de entrada dos sensores e as sa\u00eddas para os motores e eventuais outros atuadores. Normalmente possuem sensores importantes embarcados nativamente, como girosc\u00f3pio, aceler\u00f4metro, b\u00fassola entre outros. Sua principal fun\u00e7\u00e3o \u00e9 mapear os comandos recebidos para controlar os movimentos de ROLL, PITCH e YAW do drone, al\u00e9m de estabilizar o voo. PMB: _Power Management Board _\u00e9 a placa respons\u00e1vel por distribuir a pot\u00eancia pelo drone, alimentando todos os componentes necess\u00e1rios, e no caso da Pixhawk 4 esta placa tamb\u00e9m \u00e9 respons\u00e1vel por medir o consumo de corrente e a tens\u00e3o da bateria bem como distribuir os sinais para os ESCs e outros componentes que usem entradas de FMU.","title":"Controladora de v\u00f4o e PMB"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#baterias","text":"As baterias t\u00eam uma fun\u00e7\u00e3o super importante na cria\u00e7\u00e3o de drones, elas s\u00e3o as respons\u00e1veis pela quantidade de tempo que o drone permanecer\u00e1 no c\u00e9u! Quanto mais carga a bateria possui, mais tempo de voo (desconsiderando o peso \u00e9 claro).","title":"Baterias:"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#telemetria","text":"Respons\u00e1vel por transmitir informa\u00e7\u00f5es e comandos do Drone para o solo e vice-versa. Pode ser utilizada para transmitir o status da bateria, posi\u00e7\u00e3o atual, imagens e v\u00eddeos capturados e comandar o drone caso o computador de bordo n\u00e3o esteja funcionando como deveria.","title":"Telemetria:"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#gps","text":"Permite descobrir a latitude, longitude, velocidade e dire\u00e7\u00e3o do drone baseado em uma constela\u00e7\u00e3o de sat\u00e9lites.","title":"GPS:"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#controle-e-receptor","text":"R\u00e1dio Controle: Componente que transmite pilotar o drone manualmente, atrav\u00e9s da transmiss\u00e3o de informa\u00e7\u00f5es que alteram sua posi\u00e7\u00e3o, permitindo que ele execute tarefas como Roll, Pitch e Yaw, assim como trocar modos de voo e tomar medidas de seguran\u00e7a. Receptor: Componente que recebe as informa\u00e7\u00f5es dadas pelo R\u00e1dio Controle, e as transmite para a Controladora de voo.","title":"Controle e Receptor"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#computador-de-bordo","text":"Ele vai rodar um sistema operacional pr\u00f3prio e alguns scripts, e assim, conectado \u00e0 controladora de voo, podendo deixar o drone aut\u00f4nomo.","title":"Computador de bordo"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#sensores-e-outros-componentes","text":"Lidar: \u00c9 um m\u00e9todo de sensoriamento que utiliza pulsos de laser para medir dist\u00e2ncias dando assim uma vis\u00e3o tridimensional para nosso drone com alt\u00edssima precis\u00e3o. C\u00e2mera t\u00e9rmica: Cria imagens baseado na quantidade de radia\u00e7\u00e3o emitida pelos corpos, o que nos permite estimar a sua temperatura. N\u00f3s utilizamos para identificar pessoas (ou dummies) em lugares com baixa visibilidade. Optical Flow: \u00c9 uma c\u00e2mera que mede o movimento do drone baseado na movimenta\u00e7\u00e3o dos pontos presentes na imagem.","title":"Sensores e outros componentes"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#o-drone-1p","text":"Ground Station Q Ground Control: \u00c9 a interface gr\u00e1fica utilizada em um computador/notebook/celular para obter uma comunica\u00e7\u00e3o drone-piloto que vai al\u00e9m do que apenas um r\u00e1dio controle. Ela permite calibrar o drone, configurar par\u00e2metros, monitorar, fazer voo simples e criar planejamentos de voos. Firmware Firmware \u00e9 o software embarcado na controladora de voo, e tem a fun\u00e7\u00e3o de fazer o controle mais b\u00e1sico e de baixo n\u00edvel do drone. Exemplos: PX4 Ardupilot","title":"O Drone (1p)"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#boas-praticas-de-hardware-1p","text":"N\u00e3o queimar o amiguinho com ferro de solda? goxto rs Muito cuidado ao manusear as baterias LiPo pois s\u00e3o muito vol\u00e1teis, sempre respeitando os procedimentos para carregamento e os n\u00edveis de descarga recomendados (descarga m\u00e1xima 20%) Verificar as liga\u00e7\u00f5es de acordo com os devidos circuitos esquem\u00e1ticos antes de energizar qualquer circuito a fim de evitar a queima de componentes ou riscos ao operador Sempre se atentar para a qualidade e seguran\u00e7a das liga\u00e7\u00f5es ao testar componentes isolados em bancada, evitando curtos e danos aos equipamentos.","title":"Boas pr\u00e1ticas de Hardware (1p)"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#boas-praticas-de-voo-1p","text":"","title":"Boas pr\u00e1ticas de v\u00f4o (1p)"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#protocolo-de-voo","text":"Sempre usar o nosso protocolo de v\u00f4o antes de pilotar algum drone feito pela equipe(https://skyrats.github.io/knowledge_base/Introdu\u00e7\u00e3o/preflightcheck/), caso seja um drone comercial, usar o pr\u00f3prio protocolo de v\u00f4o.","title":"Protocolo de v\u00f4o"},{"location":"Hardware/Introdu\u00e7\u00e3o_Hardware/#modos-de-voo-basicos-da-px4-httpsdocspx4iov190enflight_modes","text":"Position O throttle fica no meio do canal Usa o GPS para controlar e ajustar sua posi\u00e7\u00e3o Mais f\u00e1cil de controlar Stabilized O throttle fica na parte inferior do canal N\u00e3o usa GPS para ajustar posi\u00e7\u00e3o Meio dif\u00edcil de controlar Altitude Igual o stabilized, por\u00e9m mant\u00e9m a altitude do drone controlada Manual Controle 100% manual do drone, sem estabiliza\u00e7\u00f5es. Muito dif\u00edcil de controlar Todos esses modos existem no ardupilot, s\u00f3 que com alguns outros nomes: https://ardupilot.org/plane/docs/flight-modes.html","title":"Modos de v\u00f4o b\u00e1sicos da PX4 (https://docs.px4.io/v1.9.0/en/flight_modes/)"},{"location":"Hardware/MAVLink/","text":"MAVLINK Introdu\u00e7\u00e3o MAVLink \u00e9 um protocolo utilizado para a comunica\u00e7\u00e3o de ve\u00edculos aereos n\u00e3o tripulados entre si e com o computador de bordo e a esta\u00e7\u00e3o de controle. Existem duas vers\u00f5es. Na MAVLink v1.0, cada mensagem possui entre 8 e 263 bytes, sendo 255 de carga \u00fatil m\u00e1xima. Na vers\u00e3o 2.0, as mensagens variam entre 11 e 279 bytes, tendo a mesma carga \u00fatil. Por meio da MAVLink, \u00e9 poss\u00edvel mandar comandos para tirar foto, pedir para o drone ir at\u00e9 um ponto, realizar download do log de voo e requisitar informa\u00e7\u00f5es como altitude, velocidade, posi\u00e7\u00e3o etc. A MAVLink tamb\u00e9m \u00e9 uma parte fundamental da QGroundControl. A QGC funciona como uma interface gr\u00e1fica que recebe, exibe e envia as informa\u00e7\u00f5es do drone por meio do protoc\u00f3lo MAVLink Mensagens As mensagens j\u00e1 prontas da MAVLink se dividem por alguns servi\u00e7os. Heartbeat/Connection Protocol Esse servi\u00e7o \u00e9 respons\u00e1vel por conectar o Drone \u00e0 Ground Station. Por meio dele, o Drone envia regularmente uma mensagem chamada Heartbeat que serve para avisar que o drone est\u00e1 conectado e dispon\u00edvel Mission Protocol Serve para realizar download, upload e modificar planos de voo. Parameter Protocols Esse servi\u00e7o serve para exibir os par\u00e2metros utilizados pelo drone e seus componentes. Ele \u00e9 bastante \u00fatil porque permite que a gente visualize todos os par\u00e2metros por meio da QGroundControl e da Mission Planner. Command Protocol Permite mandar comandos para o drone. Por exemplo, v\u00e1 para o ponto x. Bibliotecas O projeto MAVLink possui algumas bibliotecas que podem ser utilizadas para transmitir e receber mensagens utilizando o protocolo. A primeira e de mais baixo n\u00edvel \u00e9 a MAVLink . Ela \u00e9 a oficial da equipe que desenvolve o protocolo, por\u00e9m us\u00e1-la \u00e9 bastante trabalhoso. S\u00f3 vale a pena para escrever mensagens personalizadas, o que \u00e9 um caso raro j\u00e1 que as mensagens j\u00e1 dispon\u00edveis por padr\u00e3o na PX4 costumam ser suficientes. Por isso utilizamos outras ferramentas: MAVSDK \u00c9 uma API criada pela equipe que mantem a MAVLink para facilitar o envio e recebimento de mensagens. Com ela, \u00e9 poss\u00edvel programar em C++ e Python . Para instalar a vers\u00e3o para Python \u00e9 simples, basta digitar no terminal: pip3 install mavsdk pip3 install aioconsole Pymavlink Outra alternativa, dispon\u00edvel apenas com Python, \u00e9 a Pymavlink . Ela \u00e9 a mais simples de todas e \u00e9 a que utilizamos para fazer a transmiss\u00e3o de dados do TFMini na Odroid para a PX4. Projetos ja feitos: Distance sensor externo a FCU (TFMini) Driver TFMini O TFMini por ser serial foi conectado ao GPIO da Odroid xu4, mais precisamente nos pinos 4 e 6, respectivamente RX e TX da Odroid. Para fazer a leitura dos dados do GPIO foi utilizada a biblioteca Odroid Wiring Pi. #!/usr/bin/env python import odroid_wiringpi as wpi import time No c\u00f3digo ent\u00e3o foi criado uma classe \"TFMini\", p/ que ela possa ser utilizada facilmente em outros c\u00f3digos, precisando apenas ser incluida e inicializada. A conex\u00e3o com o TFMini fica dentro do construtor, onde ele abre a porta serial em que est\u00e1 conectado fisicamente o TFMini e declara a Baudrate; e \u00e9 encerrada a conex\u00e3o em seu destrutor. class tfmini: def __init__(self): self.serial = wpi.serialOpen('/dev/ttySAC0', 115200) def __del__(self): wpi.serialClose(self.serial) O m\u00e9todo medir fica respons\u00e1vel por pegar as informa\u00e7\u00f5es recebidas pela serial, onde ele transforma os respectivos bits recebidos em cada pacote em sua informa\u00e7\u00e3o, cujos valores e significados est\u00e3o no datasheet do sensor. Tamb\u00e9m existe uma main, por\u00e9m ela roda apenas quando o script \u00e9 rodado direto. ```python= def medir(self): cont = 0 cont2 = 0 cont3 = 0 distancia = -1 strenght = -1 bit3 = 0 bit4 = 0 bit5 = 0 bit6 = 0 wpi.serialFlush(self.serial) while cont 9: output = wpi.serialGetchar(self.serial) cont += 1 if cont == 3 or cont == 4: #print(output) cont2 += 1 #Leitura de bits ( 3 e 4 distance, 5 e 6 strenght ) if cont == 3: bit3 = output if cont == 4: bit4 = output # Calcular distance if cont2 == 2: cont2 = 0 distancia = bit3 + ( bit4 * 256 ) if cont == 5 or cont == 6: #print(output) cont2 += 1 #Leitura de bits ( 5 e 6 strenght ) if cont == 5: bit5 = output if cont == 6: bit6 = output # Calcular distance e strenght if cont2 == 2: cont2 = 0 strenght = bit5 + ( bit6 * 256 ) #print('Distance = ' + str(distancia) + ' || Strenght = ' + str(strenght)) return [distancia, strenght] if name == ' main ': tfmini = tfmini() medidas = tfmini.medir() print('Distance = ' + str(medidas[0]) + ' || Strenght = ' + str(medidas[1])) #print(medidas) Agora, a conex\u00e3o com a FCU foi feita atravez de MAVLink, com a biblioteca mavutil, que envia a msg de distance_sensor , onde estabelecemos a conex\u00e3o com a FCU usando o comando mavlink_connection da biblioteca mavutil, usando no caso de USB a respectiva porta conectada, a ACM0. Mas caso ele n\u00e3o conecte com as portas citadas abaixo, seja qual for a forma de conex\u00e3o, ela pode ser detectada utilizando o comando ```bash dmesg ```. ```python= #!/usr/bin/env python3 from pymavlink import mavutil import time import tfmini as lidar if __name__ == __main__ : #Telemetria: mav = mavutil.mavlink_connection( /dev/ttyUSB0 , autoreconnect=True, baud=57600) #USB: #mav = mavutil.mavlink_connection( /dev/ttyACM0 , autoreconnect=True, baud=57600) #Gazebo: #mav = mavutil.mavlink_connection('udpin:localhost:1450') print( Conectou ) for i in range(3): print( Testando: ) print(mav.wait_heartbeat()) time.sleep(1) tfmini = lidar() while(True): distance = tfmini.medir() #'time_boot_ms', 'min_distance', 'max_distance', 'current_distance', 'type', 'id', 'orientation', and 'covariance' mav.mav.distance_sensor_send(10, 20, 1200, distance, 0, 0, 25, 255) print( SENT ) #print(dir(mav.mav.distance_sensor_send()))","title":"MAVLINK"},{"location":"Hardware/MAVLink/#mavlink","text":"","title":"MAVLINK"},{"location":"Hardware/MAVLink/#introducao","text":"MAVLink \u00e9 um protocolo utilizado para a comunica\u00e7\u00e3o de ve\u00edculos aereos n\u00e3o tripulados entre si e com o computador de bordo e a esta\u00e7\u00e3o de controle. Existem duas vers\u00f5es. Na MAVLink v1.0, cada mensagem possui entre 8 e 263 bytes, sendo 255 de carga \u00fatil m\u00e1xima. Na vers\u00e3o 2.0, as mensagens variam entre 11 e 279 bytes, tendo a mesma carga \u00fatil. Por meio da MAVLink, \u00e9 poss\u00edvel mandar comandos para tirar foto, pedir para o drone ir at\u00e9 um ponto, realizar download do log de voo e requisitar informa\u00e7\u00f5es como altitude, velocidade, posi\u00e7\u00e3o etc. A MAVLink tamb\u00e9m \u00e9 uma parte fundamental da QGroundControl. A QGC funciona como uma interface gr\u00e1fica que recebe, exibe e envia as informa\u00e7\u00f5es do drone por meio do protoc\u00f3lo MAVLink","title":"Introdu\u00e7\u00e3o"},{"location":"Hardware/MAVLink/#mensagens","text":"As mensagens j\u00e1 prontas da MAVLink se dividem por alguns servi\u00e7os.","title":"Mensagens"},{"location":"Hardware/MAVLink/#heartbeatconnection-protocol","text":"Esse servi\u00e7o \u00e9 respons\u00e1vel por conectar o Drone \u00e0 Ground Station. Por meio dele, o Drone envia regularmente uma mensagem chamada Heartbeat que serve para avisar que o drone est\u00e1 conectado e dispon\u00edvel","title":"Heartbeat/Connection Protocol"},{"location":"Hardware/MAVLink/#mission-protocol","text":"Serve para realizar download, upload e modificar planos de voo.","title":"Mission Protocol"},{"location":"Hardware/MAVLink/#parameter-protocols","text":"Esse servi\u00e7o serve para exibir os par\u00e2metros utilizados pelo drone e seus componentes. Ele \u00e9 bastante \u00fatil porque permite que a gente visualize todos os par\u00e2metros por meio da QGroundControl e da Mission Planner.","title":"Parameter Protocols"},{"location":"Hardware/MAVLink/#command-protocol","text":"Permite mandar comandos para o drone. Por exemplo, v\u00e1 para o ponto x.","title":"Command Protocol"},{"location":"Hardware/MAVLink/#bibliotecas","text":"O projeto MAVLink possui algumas bibliotecas que podem ser utilizadas para transmitir e receber mensagens utilizando o protocolo. A primeira e de mais baixo n\u00edvel \u00e9 a MAVLink . Ela \u00e9 a oficial da equipe que desenvolve o protocolo, por\u00e9m us\u00e1-la \u00e9 bastante trabalhoso. S\u00f3 vale a pena para escrever mensagens personalizadas, o que \u00e9 um caso raro j\u00e1 que as mensagens j\u00e1 dispon\u00edveis por padr\u00e3o na PX4 costumam ser suficientes. Por isso utilizamos outras ferramentas:","title":"Bibliotecas"},{"location":"Hardware/MAVLink/#mavsdk","text":"\u00c9 uma API criada pela equipe que mantem a MAVLink para facilitar o envio e recebimento de mensagens. Com ela, \u00e9 poss\u00edvel programar em C++ e Python . Para instalar a vers\u00e3o para Python \u00e9 simples, basta digitar no terminal: pip3 install mavsdk pip3 install aioconsole","title":"MAVSDK"},{"location":"Hardware/MAVLink/#pymavlink","text":"Outra alternativa, dispon\u00edvel apenas com Python, \u00e9 a Pymavlink . Ela \u00e9 a mais simples de todas e \u00e9 a que utilizamos para fazer a transmiss\u00e3o de dados do TFMini na Odroid para a PX4.","title":"Pymavlink"},{"location":"Hardware/MAVLink/#projetos-ja-feitos","text":"","title":"Projetos ja feitos:"},{"location":"Hardware/MAVLink/#distance-sensor-externo-a-fcu-tfmini","text":"","title":"Distance sensor externo a FCU (TFMini)"},{"location":"Hardware/MAVLink/#driver-tfmini","text":"O TFMini por ser serial foi conectado ao GPIO da Odroid xu4, mais precisamente nos pinos 4 e 6, respectivamente RX e TX da Odroid. Para fazer a leitura dos dados do GPIO foi utilizada a biblioteca Odroid Wiring Pi. #!/usr/bin/env python import odroid_wiringpi as wpi import time No c\u00f3digo ent\u00e3o foi criado uma classe \"TFMini\", p/ que ela possa ser utilizada facilmente em outros c\u00f3digos, precisando apenas ser incluida e inicializada. A conex\u00e3o com o TFMini fica dentro do construtor, onde ele abre a porta serial em que est\u00e1 conectado fisicamente o TFMini e declara a Baudrate; e \u00e9 encerrada a conex\u00e3o em seu destrutor. class tfmini: def __init__(self): self.serial = wpi.serialOpen('/dev/ttySAC0', 115200) def __del__(self): wpi.serialClose(self.serial) O m\u00e9todo medir fica respons\u00e1vel por pegar as informa\u00e7\u00f5es recebidas pela serial, onde ele transforma os respectivos bits recebidos em cada pacote em sua informa\u00e7\u00e3o, cujos valores e significados est\u00e3o no datasheet do sensor. Tamb\u00e9m existe uma main, por\u00e9m ela roda apenas quando o script \u00e9 rodado direto. ```python= def medir(self): cont = 0 cont2 = 0 cont3 = 0 distancia = -1 strenght = -1 bit3 = 0 bit4 = 0 bit5 = 0 bit6 = 0 wpi.serialFlush(self.serial) while cont 9: output = wpi.serialGetchar(self.serial) cont += 1 if cont == 3 or cont == 4: #print(output) cont2 += 1 #Leitura de bits ( 3 e 4 distance, 5 e 6 strenght ) if cont == 3: bit3 = output if cont == 4: bit4 = output # Calcular distance if cont2 == 2: cont2 = 0 distancia = bit3 + ( bit4 * 256 ) if cont == 5 or cont == 6: #print(output) cont2 += 1 #Leitura de bits ( 5 e 6 strenght ) if cont == 5: bit5 = output if cont == 6: bit6 = output # Calcular distance e strenght if cont2 == 2: cont2 = 0 strenght = bit5 + ( bit6 * 256 ) #print('Distance = ' + str(distancia) + ' || Strenght = ' + str(strenght)) return [distancia, strenght] if name == ' main ': tfmini = tfmini() medidas = tfmini.medir() print('Distance = ' + str(medidas[0]) + ' || Strenght = ' + str(medidas[1])) #print(medidas) Agora, a conex\u00e3o com a FCU foi feita atravez de MAVLink, com a biblioteca mavutil, que envia a msg de distance_sensor , onde estabelecemos a conex\u00e3o com a FCU usando o comando mavlink_connection da biblioteca mavutil, usando no caso de USB a respectiva porta conectada, a ACM0. Mas caso ele n\u00e3o conecte com as portas citadas abaixo, seja qual for a forma de conex\u00e3o, ela pode ser detectada utilizando o comando ```bash dmesg ```. ```python= #!/usr/bin/env python3 from pymavlink import mavutil import time import tfmini as lidar if __name__ == __main__ : #Telemetria: mav = mavutil.mavlink_connection( /dev/ttyUSB0 , autoreconnect=True, baud=57600) #USB: #mav = mavutil.mavlink_connection( /dev/ttyACM0 , autoreconnect=True, baud=57600) #Gazebo: #mav = mavutil.mavlink_connection('udpin:localhost:1450') print( Conectou ) for i in range(3): print( Testando: ) print(mav.wait_heartbeat()) time.sleep(1) tfmini = lidar() while(True): distance = tfmini.medir() #'time_boot_ms', 'min_distance', 'max_distance', 'current_distance', 'type', 'id', 'orientation', and 'covariance' mav.mav.distance_sensor_send(10, 20, 1200, distance, 0, 0, 25, 255) print( SENT ) #print(dir(mav.mav.distance_sensor_send()))","title":"Driver TFMini"},{"location":"Hardware/Radio Controle/","text":"Configura\u00e7\u00e3o dos R\u00e1dio Controles Como Bindar o Controle no receptor Para Bindar o R\u00e1dio Controle FrSky Taranis Q X7 ao Receptor FrSky Taranis X8R, pegue um objeto com ponta pois ser\u00e1 necess\u00e1rio mais para frente. Ligue o Controle, mas n\u00e3o ligue a Controladora de voo ao qual o Receptor est\u00e1 conectado. Clique no menu (bot\u00e3o circular com tr\u00eas ricos horizintais); Em seguida clique no bot\u00e3o page ; Ao clicar no bot\u00e3o page, voc\u00ea entrar\u00e1 na p\u00e1gina de SETUP onde ao descer at\u00e9 RxNum voc\u00ea encontrar\u00e1 a op\u00e7\u00e3o [Bnd] ; Uma vez com o cursor em [Bnd] , tenha em m\u00e3os o objeto com ponta para eventualmente pressionar o bot\u00e3o min\u00fasculo encontrado no Receptor com a escrita F/S ; Clique em [Bnd] e escolha a op\u00e7\u00e3o de canais desejada, ela come\u00e7ar\u00e1 a apitar; Com a Controladora ainda desligada, pressione bot\u00e3ozinho com a ponta do objeto continuamente e a\u00ed sim ligue a Controladora de voo. Quando uma luz verde s\u00f3lida e uma luz vermelha piscando ascender no Receptor, voc\u00ea pode soltar o bot\u00e3ozinho; Desligue primeiramente a Controladora de voo e depois o [Bnd] , parando de apitar. Feito todos esses passos, seu Radio Controle estar\u00e1 bindado ao Receptor. Voc\u00ea pode checar isso ao ligar a Controladora de voo, e no Receptor acender uma luz s\u00f3lida verde de confirma\u00e7\u00e3o de conex\u00e3o. OBS: Se uma luz s\u00f3lida verde acender e uma luz vermelha s\u00f3lida tamb\u00e9m acender, \u00e9 porque h\u00e1 um conflito de Firmware entre o Receptor e o Transmissor. Esse erro n\u00e3o corresponde \u00e0 um erro de vers\u00e3o do Firmware, mas sim que existem duas vers\u00f5es de Firmware, uma vers\u00e3o Internacional e outra vers\u00e3o EU, que n\u00e3o s\u00e3o compat\u00edveis entre si. Portanto \u00e9 necess\u00e1rio alterar o Firmware de um dos dois componentes, para que eles combinem, e depois \u00e9 s\u00f3 Binda-los novamente. Como configurar os switches do Controle Para configurar os Switches do R\u00e1dio Controle ser\u00e1 necess\u00e1rio o Controle, e o Receptor, que estar\u00e1 conectado a uma Controladora de voo e a um computador pela Q Ground Control. Vamos separar as instru\u00e7\u00f5es em duas etapas. As que ser\u00e3o feitas no controle, e as que ser\u00e3o feitas no Q Groud Control. No Controle: Clique no menu (bot\u00e3o circular com tr\u00eas ricos horizintais); Em seguida clique no bot\u00e3o page at\u00e9 encontrar a p\u00e1gina MIXER ; Na p\u00e1gina mixer a contagem de canais livres para serem configurados come\u00e7a a partir do 5 pois os 4 primeiros s\u00e3o o de controle de movimenta\u00e7\u00e3o do drone, ent\u00e3o vamos configurar a partir do CH5 . Selecionado o CH5 ou o canal desejado, podemos nomea-lo para identifica\u00e7\u00e3o em Mix name Em Source escolhe-se o Switch ao qual ser\u00e1 atrelado ao canal, ent\u00e3o seleciona-se Source e ativa-se o switch/clica-se no bot\u00e3o queremos atrelar, n\u00e3o precisando assim passar por toda a lista de Switches, para identificar qual voc\u00ea deseja. Feito isso, conclui-se a parte do Controle. Voc\u00ea pode Configurar o m\u00e1ximo de Switches que vc desejar e que o Controle permitir. Na Q Ground Control: Abra o Q Ground Control, clique nas engrenagens na parte superior esquerda, e v\u00e1 para Flight Modes Em Flight Modes voc\u00ea ter\u00e1 uma lista de canais, ela corresponde a numera\u00e7\u00e3o de canais e switches que voc\u00ea configurou no seu controle. Para cada canal, clicando na setinha para baixo, aparecem uma s\u00e9rie de poss\u00edveis atribui\u00e7\u00f5es para o canal. Ent\u00e3o para configurar cada canal basta selecionar o desejado, escolher a atribui\u00e7\u00e3o e seleciona-la. Lembrando novamente que voc\u00ea s\u00f3 poderar configurar a partir do channel 5 pois os 4 primeiros s\u00e3o respectivos ao controle de voo do pr\u00f3prio drone. Caso queira saber mais de como setar os switches: How to setup Switches . Caso queira saber mais de como configurar os canais: Flight Modes . Explica\u00e7\u00e3o de cada Flight Mode: PX4 ou Ardupilot","title":"Radio Controle"},{"location":"Hardware/Radio Controle/#configuracao-dos-radio-controles","text":"","title":"Configura\u00e7\u00e3o dos R\u00e1dio Controles"},{"location":"Hardware/Radio Controle/#como-bindar-o-controle-no-receptor","text":"Para Bindar o R\u00e1dio Controle FrSky Taranis Q X7 ao Receptor FrSky Taranis X8R, pegue um objeto com ponta pois ser\u00e1 necess\u00e1rio mais para frente. Ligue o Controle, mas n\u00e3o ligue a Controladora de voo ao qual o Receptor est\u00e1 conectado. Clique no menu (bot\u00e3o circular com tr\u00eas ricos horizintais); Em seguida clique no bot\u00e3o page ; Ao clicar no bot\u00e3o page, voc\u00ea entrar\u00e1 na p\u00e1gina de SETUP onde ao descer at\u00e9 RxNum voc\u00ea encontrar\u00e1 a op\u00e7\u00e3o [Bnd] ; Uma vez com o cursor em [Bnd] , tenha em m\u00e3os o objeto com ponta para eventualmente pressionar o bot\u00e3o min\u00fasculo encontrado no Receptor com a escrita F/S ; Clique em [Bnd] e escolha a op\u00e7\u00e3o de canais desejada, ela come\u00e7ar\u00e1 a apitar; Com a Controladora ainda desligada, pressione bot\u00e3ozinho com a ponta do objeto continuamente e a\u00ed sim ligue a Controladora de voo. Quando uma luz verde s\u00f3lida e uma luz vermelha piscando ascender no Receptor, voc\u00ea pode soltar o bot\u00e3ozinho; Desligue primeiramente a Controladora de voo e depois o [Bnd] , parando de apitar. Feito todos esses passos, seu Radio Controle estar\u00e1 bindado ao Receptor. Voc\u00ea pode checar isso ao ligar a Controladora de voo, e no Receptor acender uma luz s\u00f3lida verde de confirma\u00e7\u00e3o de conex\u00e3o. OBS: Se uma luz s\u00f3lida verde acender e uma luz vermelha s\u00f3lida tamb\u00e9m acender, \u00e9 porque h\u00e1 um conflito de Firmware entre o Receptor e o Transmissor. Esse erro n\u00e3o corresponde \u00e0 um erro de vers\u00e3o do Firmware, mas sim que existem duas vers\u00f5es de Firmware, uma vers\u00e3o Internacional e outra vers\u00e3o EU, que n\u00e3o s\u00e3o compat\u00edveis entre si. Portanto \u00e9 necess\u00e1rio alterar o Firmware de um dos dois componentes, para que eles combinem, e depois \u00e9 s\u00f3 Binda-los novamente.","title":"Como Bindar o Controle no receptor"},{"location":"Hardware/Radio Controle/#como-configurar-os-switches-do-controle","text":"Para configurar os Switches do R\u00e1dio Controle ser\u00e1 necess\u00e1rio o Controle, e o Receptor, que estar\u00e1 conectado a uma Controladora de voo e a um computador pela Q Ground Control. Vamos separar as instru\u00e7\u00f5es em duas etapas. As que ser\u00e3o feitas no controle, e as que ser\u00e3o feitas no Q Groud Control. No Controle: Clique no menu (bot\u00e3o circular com tr\u00eas ricos horizintais); Em seguida clique no bot\u00e3o page at\u00e9 encontrar a p\u00e1gina MIXER ; Na p\u00e1gina mixer a contagem de canais livres para serem configurados come\u00e7a a partir do 5 pois os 4 primeiros s\u00e3o o de controle de movimenta\u00e7\u00e3o do drone, ent\u00e3o vamos configurar a partir do CH5 . Selecionado o CH5 ou o canal desejado, podemos nomea-lo para identifica\u00e7\u00e3o em Mix name Em Source escolhe-se o Switch ao qual ser\u00e1 atrelado ao canal, ent\u00e3o seleciona-se Source e ativa-se o switch/clica-se no bot\u00e3o queremos atrelar, n\u00e3o precisando assim passar por toda a lista de Switches, para identificar qual voc\u00ea deseja. Feito isso, conclui-se a parte do Controle. Voc\u00ea pode Configurar o m\u00e1ximo de Switches que vc desejar e que o Controle permitir. Na Q Ground Control: Abra o Q Ground Control, clique nas engrenagens na parte superior esquerda, e v\u00e1 para Flight Modes Em Flight Modes voc\u00ea ter\u00e1 uma lista de canais, ela corresponde a numera\u00e7\u00e3o de canais e switches que voc\u00ea configurou no seu controle. Para cada canal, clicando na setinha para baixo, aparecem uma s\u00e9rie de poss\u00edveis atribui\u00e7\u00f5es para o canal. Ent\u00e3o para configurar cada canal basta selecionar o desejado, escolher a atribui\u00e7\u00e3o e seleciona-la. Lembrando novamente que voc\u00ea s\u00f3 poderar configurar a partir do channel 5 pois os 4 primeiros s\u00e3o respectivos ao controle de voo do pr\u00f3prio drone. Caso queira saber mais de como setar os switches: How to setup Switches . Caso queira saber mais de como configurar os canais: Flight Modes . Explica\u00e7\u00e3o de cada Flight Mode: PX4 ou Ardupilot","title":"Como configurar os switches do Controle"},{"location":"Middleware/Ardupilot/","text":"Ardupilot for Skyrats Usamos como firmware secund\u00e1rio, quando \u00e9 necess\u00e1ria alguma fun\u00e7\u00e3o ou especifica\u00e7\u00e3o que n\u00e3o existe na PX4, como por exemplo, usar a porta CAM, como UAVCAM para usar informa\u00e7\u00f5es de GPS. Caso n\u00e3o tenha ele baixado ainda, realize as instru\u00e7\u00f5es do guia de instala\u00e7\u00f5es. Compilar #Instala depend\u00eancias necess\u00e1rias do firmware: . ~/src/ardupilot/Tools/environment_install/install-prereqs-ubuntu.sh -y . ~/.profile #Instala depend\u00eancias necess\u00e1rias do python: pip install future #Lista todas as placas nas quais o ardupilot pode ser compilado ./waf list_boards #Escolher a controladora de v\u00f4o ./waf configure --board Pixhawk4 #Escolher tipo de ve\u00edculo ./waf copter #Fazer o upload da \u00faltima config de Firmware compilada ./waf --targets bin/ nome_do_arquivo --upload","title":"Ardupilot"},{"location":"Middleware/Ardupilot/#ardupilot-for-skyrats","text":"Usamos como firmware secund\u00e1rio, quando \u00e9 necess\u00e1ria alguma fun\u00e7\u00e3o ou especifica\u00e7\u00e3o que n\u00e3o existe na PX4, como por exemplo, usar a porta CAM, como UAVCAM para usar informa\u00e7\u00f5es de GPS. Caso n\u00e3o tenha ele baixado ainda, realize as instru\u00e7\u00f5es do guia de instala\u00e7\u00f5es.","title":"Ardupilot for Skyrats"},{"location":"Middleware/Ardupilot/#compilar","text":"#Instala depend\u00eancias necess\u00e1rias do firmware: . ~/src/ardupilot/Tools/environment_install/install-prereqs-ubuntu.sh -y . ~/.profile #Instala depend\u00eancias necess\u00e1rias do python: pip install future #Lista todas as placas nas quais o ardupilot pode ser compilado ./waf list_boards #Escolher a controladora de v\u00f4o ./waf configure --board Pixhawk4 #Escolher tipo de ve\u00edculo ./waf copter #Fazer o upload da \u00faltima config de Firmware compilada ./waf --targets bin/ nome_do_arquivo --upload","title":"Compilar"},{"location":"Middleware/Calibra\u00e7ao e Firmaware/","text":"Compilamento do Firmware e Calibra\u00e7\u00e3o do Drone Compilando Firmware O primeiro passo antes de come\u00e7ar a compilar o Firmware \u00e9 conectar o drone ao seu computador, portanto conecte-os utilizando-se de um cabo USB. OBS : Utilize o cabo pra conectar o drone ao computador! N\u00e3o fa\u00e7a pela telemetria pois compilar o firmware \u00e9 uma tarefa pesada para se fazer por telemetria. Depois de conectados, abra seu navegador de arquivos e v\u00e1 at\u00e9 sua pasta de drivers: /Firmware/src/drivers . L\u00e1 se encontram todos os seus drivers. Caso n\u00e3o encontre o driver que procuras, baixe-o e salve nesta pasta. Depois de encontrar a pasta do Driver desejado, abra-o e procure pelo arquivo dos par\u00e2metros, como por exemplo parameters.c e altere o par\u00e2metro de acordo com sua necessidade, desabilitando-o, habilitando-o e fazendo isso de acordo com seu tipo de entrada. Com os par\u00e2metros do Firmware alterados, v\u00e1 para /Firmware/boards . Cada pasta encontrada aqui \u00e9 um Firmware diferente, escolha portanto o Firmware o qual voc\u00ea utiliza. Escolhido um Firmware, selecione a vers\u00e3o que voc\u00ea possui. No nosso caso o nosso caminho foi /Firmware/boards/px4/fmu-v2/ . Nessa paste procure pelo arquivo o qual apresenta todos os drives habilitados ou n\u00e3o habilitados, no nosso caso ele se chama multicopter.cmake , mas ele pode apresentar outro nome no seu computador, isso tamb\u00e9m de acordo com o Firmware que voc\u00ea utiliza. Fa\u00e7a uma copia dele e o renomeie da forma que for mais pr\u00e1tica para voc\u00ea, pois voc\u00ea ir\u00e1 utiliza-lo. A pixhawk, controladora o qual usamos, apresenta uma mem\u00f3ria limitada, uma caracter\u00edstica de sistemas embarcados, e portanto geralmente habilita-se apenas os Drivers necess\u00e1rios para compilar. Habilite ent\u00e3o os drivers que voc\u00ea precisar, isso dentro do arquivo copiado e renomeado, pois n\u00e3o queremos alterar o arquivo original. Feito isso, abra seu terminal e d\u00ea /Firmware . Dado o comando, compile o Firmware utilizando-se do arquivo que voc\u00ea editou, no nosso caso o comando foi make px4_fmu-v2_multicoptereditado . Ele pode demorar um pouco, mas isso ocorre porque \u00e9 um comando pesado. Mas uma vez compilado, n\u00e3o \u00e9 necess\u00e1rio compila-lo novamente a n\u00e3o ser que haja mudan\u00e7as nos Drivers ou no Firmware utilizado. Enquanto ele compila, \u00e9 recomend\u00e1vel que se salve os par\u00e2metros de sua controladora antes de dar o upload do Firmware novo. Ele \u00e9 um arquivo .params e pode ser salvado pelo QGroundControl. Com o QGroundControl abra o Vehicle Setup (tr\u00eas engrenagens na parte superios esquerda), des\u00e7a at\u00e9 os Parameters , clique em Tools (na parte superior direita), e selecione Save to file .params Depois de compilado, basta dar o upload. No nosso caso o comando foi make px4_fmu-v2_multicoptereditado upload . Conclu\u00eddo o upload, seu Firmware est\u00e1 compilado e instalado na sua controladora de voo. Caso precise de ajuda com o compilamento acesse: Building the code - PX4 . Calibra\u00e7\u00e3o Para calibra\u00e7\u00e3o, iremos primeiro carregar o arquivo .params que foi salvo anteriormente, ou que possu\u00edmos salvado no computador. Iremos ent\u00e3o rebootar para que o processo se complete. Uma forma bacana de fazer isso \u00e9 abrindo o Analyze (desenho de um papel com uma lupinha ao lado), indo em MavLink Console e digitando na barra de comando inferior reboot . Carregado os par\u00e2metros e rebootado, precisamos selecionar o tipo de veiculo utilizado, portanto v\u00e1 em Vehicle Setup , abra o Airframe e selecione o que condiz com o seu. Feito isso, \u00e9 necess\u00e1rio calibrar os sensores, ent\u00e3o v\u00e1 em Sensors . Note que alguns deles apresentar\u00e3o bolinhas vermelhas ao seu lado, este ser\u00e3o os sensores que voc\u00ea precisar\u00e1 calibrar. Para calibrar, ser\u00e1 necess\u00e1rio movimentar o drone, portanto \u00e9 recomend\u00e1vel que utilize-se da Telemetria pra estabelecer a comunica\u00e7\u00e3o entre o drone e o QGroundControl. Desconecte o cabo USB entre o drone e o computador, e tamb\u00e9m o USB que liga a Jetson \u00e0 Pixhawk, conecte a Ground station no seu computador e ligue o seu drone. Conclu\u00eddo isso eles deveriam se conectar. Uma vez conectados, note que no Summary aparecem os mais variados itens, no qual se a bolinha apresenta-se vermelha, \u00e9 necess\u00e1rio uma corre\u00e7\u00e3o antes de executar um voo. Novamente, em Sensors , cheque os sensores que se apresentam em vermelho e os calibre. Clique no Sensor, aparecer\u00e1 uma barra sua lateral direita, l\u00e1 clique em OK e ele te redirecionar\u00e1 para a p\u00e1gina de calibra\u00e7\u00e3o do sensor. Cada sensor possui tarefas espec\u00edficas para que a calibra\u00e7\u00e3o seja feita, execute-as de acordo com as instru\u00e7\u00f5es e pronto, este sensor estar\u00e1 calibrado. Um problema o que voc\u00ea pode se deparar \u00e9 que sua controla de voo possui dire\u00e7\u00f5es pr\u00e9 definidas como Yaw, Pitch e Roll, mas que n\u00e3o condizem com a orienta\u00e7\u00e3o o qual voc\u00ea est\u00e1 usando. Para corrigir, a aba que aparece a sua direita possui a op\u00e7\u00e3o de rotacionar essas orienta\u00e7\u00f5es girando determinada quantidade de graus entorno de tal eixo. Ap\u00f3s selecionada a op\u00e7\u00e3o adequada \u00e9 necess\u00e1rio rebootar, depois de rebootar veja se o problema foi corrigido. Caso precise de ajuda com as orienta\u00e7\u00f5es acesse: Roll, Pitch and Yaw - PX4 .","title":"Calibra\u00e7\u00e3o e Firmware"},{"location":"Middleware/Calibra\u00e7ao e Firmaware/#compilamento-do-firmware-e-calibracao-do-drone","text":"","title":"Compilamento do Firmware e Calibra\u00e7\u00e3o do Drone"},{"location":"Middleware/Calibra\u00e7ao e Firmaware/#compilando-firmware","text":"O primeiro passo antes de come\u00e7ar a compilar o Firmware \u00e9 conectar o drone ao seu computador, portanto conecte-os utilizando-se de um cabo USB. OBS : Utilize o cabo pra conectar o drone ao computador! N\u00e3o fa\u00e7a pela telemetria pois compilar o firmware \u00e9 uma tarefa pesada para se fazer por telemetria. Depois de conectados, abra seu navegador de arquivos e v\u00e1 at\u00e9 sua pasta de drivers: /Firmware/src/drivers . L\u00e1 se encontram todos os seus drivers. Caso n\u00e3o encontre o driver que procuras, baixe-o e salve nesta pasta. Depois de encontrar a pasta do Driver desejado, abra-o e procure pelo arquivo dos par\u00e2metros, como por exemplo parameters.c e altere o par\u00e2metro de acordo com sua necessidade, desabilitando-o, habilitando-o e fazendo isso de acordo com seu tipo de entrada. Com os par\u00e2metros do Firmware alterados, v\u00e1 para /Firmware/boards . Cada pasta encontrada aqui \u00e9 um Firmware diferente, escolha portanto o Firmware o qual voc\u00ea utiliza. Escolhido um Firmware, selecione a vers\u00e3o que voc\u00ea possui. No nosso caso o nosso caminho foi /Firmware/boards/px4/fmu-v2/ . Nessa paste procure pelo arquivo o qual apresenta todos os drives habilitados ou n\u00e3o habilitados, no nosso caso ele se chama multicopter.cmake , mas ele pode apresentar outro nome no seu computador, isso tamb\u00e9m de acordo com o Firmware que voc\u00ea utiliza. Fa\u00e7a uma copia dele e o renomeie da forma que for mais pr\u00e1tica para voc\u00ea, pois voc\u00ea ir\u00e1 utiliza-lo. A pixhawk, controladora o qual usamos, apresenta uma mem\u00f3ria limitada, uma caracter\u00edstica de sistemas embarcados, e portanto geralmente habilita-se apenas os Drivers necess\u00e1rios para compilar. Habilite ent\u00e3o os drivers que voc\u00ea precisar, isso dentro do arquivo copiado e renomeado, pois n\u00e3o queremos alterar o arquivo original. Feito isso, abra seu terminal e d\u00ea /Firmware . Dado o comando, compile o Firmware utilizando-se do arquivo que voc\u00ea editou, no nosso caso o comando foi make px4_fmu-v2_multicoptereditado . Ele pode demorar um pouco, mas isso ocorre porque \u00e9 um comando pesado. Mas uma vez compilado, n\u00e3o \u00e9 necess\u00e1rio compila-lo novamente a n\u00e3o ser que haja mudan\u00e7as nos Drivers ou no Firmware utilizado. Enquanto ele compila, \u00e9 recomend\u00e1vel que se salve os par\u00e2metros de sua controladora antes de dar o upload do Firmware novo. Ele \u00e9 um arquivo .params e pode ser salvado pelo QGroundControl. Com o QGroundControl abra o Vehicle Setup (tr\u00eas engrenagens na parte superios esquerda), des\u00e7a at\u00e9 os Parameters , clique em Tools (na parte superior direita), e selecione Save to file .params Depois de compilado, basta dar o upload. No nosso caso o comando foi make px4_fmu-v2_multicoptereditado upload . Conclu\u00eddo o upload, seu Firmware est\u00e1 compilado e instalado na sua controladora de voo. Caso precise de ajuda com o compilamento acesse: Building the code - PX4 .","title":"Compilando Firmware"},{"location":"Middleware/Calibra\u00e7ao e Firmaware/#calibracao","text":"Para calibra\u00e7\u00e3o, iremos primeiro carregar o arquivo .params que foi salvo anteriormente, ou que possu\u00edmos salvado no computador. Iremos ent\u00e3o rebootar para que o processo se complete. Uma forma bacana de fazer isso \u00e9 abrindo o Analyze (desenho de um papel com uma lupinha ao lado), indo em MavLink Console e digitando na barra de comando inferior reboot . Carregado os par\u00e2metros e rebootado, precisamos selecionar o tipo de veiculo utilizado, portanto v\u00e1 em Vehicle Setup , abra o Airframe e selecione o que condiz com o seu. Feito isso, \u00e9 necess\u00e1rio calibrar os sensores, ent\u00e3o v\u00e1 em Sensors . Note que alguns deles apresentar\u00e3o bolinhas vermelhas ao seu lado, este ser\u00e3o os sensores que voc\u00ea precisar\u00e1 calibrar. Para calibrar, ser\u00e1 necess\u00e1rio movimentar o drone, portanto \u00e9 recomend\u00e1vel que utilize-se da Telemetria pra estabelecer a comunica\u00e7\u00e3o entre o drone e o QGroundControl. Desconecte o cabo USB entre o drone e o computador, e tamb\u00e9m o USB que liga a Jetson \u00e0 Pixhawk, conecte a Ground station no seu computador e ligue o seu drone. Conclu\u00eddo isso eles deveriam se conectar. Uma vez conectados, note que no Summary aparecem os mais variados itens, no qual se a bolinha apresenta-se vermelha, \u00e9 necess\u00e1rio uma corre\u00e7\u00e3o antes de executar um voo. Novamente, em Sensors , cheque os sensores que se apresentam em vermelho e os calibre. Clique no Sensor, aparecer\u00e1 uma barra sua lateral direita, l\u00e1 clique em OK e ele te redirecionar\u00e1 para a p\u00e1gina de calibra\u00e7\u00e3o do sensor. Cada sensor possui tarefas espec\u00edficas para que a calibra\u00e7\u00e3o seja feita, execute-as de acordo com as instru\u00e7\u00f5es e pronto, este sensor estar\u00e1 calibrado. Um problema o que voc\u00ea pode se deparar \u00e9 que sua controla de voo possui dire\u00e7\u00f5es pr\u00e9 definidas como Yaw, Pitch e Roll, mas que n\u00e3o condizem com a orienta\u00e7\u00e3o o qual voc\u00ea est\u00e1 usando. Para corrigir, a aba que aparece a sua direita possui a op\u00e7\u00e3o de rotacionar essas orienta\u00e7\u00f5es girando determinada quantidade de graus entorno de tal eixo. Ap\u00f3s selecionada a op\u00e7\u00e3o adequada \u00e9 necess\u00e1rio rebootar, depois de rebootar veja se o problema foi corrigido. Caso precise de ajuda com as orienta\u00e7\u00f5es acesse: Roll, Pitch and Yaw - PX4 .","title":"Calibra\u00e7\u00e3o"},{"location":"Software/Convencoes-de-Codigo/","text":"Conven\u00e7\u00f5es de C\u00f3digo Em geral, times de desenvolvedores passam mais tempo lendo e mantendo c\u00f3digo j\u00e1 escrito (incluindo durante debugging) do que escrevendo c\u00f3digo novo. Assim, \u00e9 necess\u00e1rio que c\u00f3digo seja de f\u00e1cil compreens\u00e3o tanto para a pessoa que o desenvolveu inicialmente, mas n\u00e3o se lembra de todos os detalhes, quanto para outros membros do time que nunca trabalharam no projeto. Nesse contexto, conven\u00e7\u00f5es de programa\u00e7\u00e3o servem como uma funda\u00e7\u00e3o para que todos consigam entender e escrever com facilidade c\u00f3digo que outras pessoas entendam. Elas economizam tempo de revis\u00e3o, permitindo que o programador entenda mais rapidamente a estrutura de um programa pouco familiar. Al\u00e9m disso, facilitam que outros grupos integrem c\u00f3digo de diversos times e adaptem-no com facilidade. Princ\u00edpios gerais Essa se\u00e7\u00e3o descreve atributos de C\u00f3digo Limpo, e que se aplicam a qualquer linguagem de programa\u00e7\u00e3o. Ela n\u00e3o \u00e9 excludente com as se\u00e7\u00f5es de linguagens espec\u00edficas, e \u00e9 at\u00e9 mais importante do que as outras. Layout Programas s\u00e3o em geral complexos, realizando diversas tarefas para chegar ao resultado desejado. Por isso, \u00e9 importante que essas tarefas estejam bem segmentadas em fun\u00e7\u00f5es e classes claras, sem repeti\u00e7\u00e3o e, o m\u00e1ximo poss\u00edvel, independentes da implementa\u00e7\u00e3o de outras fun\u00e7\u00f5es ou classes. Fun\u00e7\u00f5es Devem ser pequenas, realizando apenas uma \u00fanica tarefa \u00c9 aconselh\u00e1vel tentar deixar suas fun\u00e7\u00f5es com at\u00e9 20 linhas, mas isso n\u00e3o \u00e9 necess\u00e1rio De prefer\u00eancia em um \u00fanico n\u00edvel de abstra\u00e7\u00e3o (esse \u00e9 o crit\u00e9rio mais dif\u00edcil de implementar) Devem ter o menor n\u00famero de argumentos poss\u00edvel, preferencialmente at\u00e9 3 Caso tenha mais, possivelmente esses argumentos poderiam ser colocados em um objeto de mais f\u00e1cil compreens\u00e3o (e.g. um objeto Point em vez de x e y ) Caso v\u00e1rias fun\u00e7\u00f5es dependam de uma mesma lista de argumentos, considere coloc\u00e1-las em uma classe \u00e0 parte Devem ou executar uma tarefa, ou retornas informa\u00e7\u00e3o, mas n\u00e3o os dois Devem preferencialmente n\u00e3o modificar seus argumentos ou ter efeitos em outros objetos que n\u00e3o estejam \u00f3bvios Classes Devem ser pequenas e coesas (i.e. ter membros com depend\u00eancias similares e que necessariamente se beneficiam de estarem juntos) Devem permitir adi\u00e7\u00e3o de novas fun\u00e7\u00f5es facilmente \u00c9 necess\u00e1rio ressaltar que nenhum objeto deve depender da implementa\u00e7\u00e3o de outro . Por exemplo, uma classe DrawCircle depende do fato da classe LocateCircle ter atributos center_x_ e center_y_ . Posteriormente, a classe LocateCircle passa a armazenar o centro em coordenadas polares. Com isso, DrawCircle vai parar de funcionar e vai precisar ser modificada tamb\u00e9m. Nesse exemplo, seria mais adequado existir uma fun\u00e7\u00e3o GetCircleCenter em LocateCircle , criando uma camada de abstra\u00e7\u00e3o entre as implementa\u00e7\u00f5es das classes. Coment\u00e1rios Do Google C++ Style Guide: Comments are absolutely vital to keeping our code readable. The following rules describe what you should comment and where. But remember: while comments are very important, the best code is self-documenting. Do Style Guide for Python Code Comments that contradict the code are worse than no comments. Always make a priority of keeping the comments up-to-date when the code changes! Idealmente, c\u00f3digo bem escrito n\u00e3o exige coment\u00e1rios. Eles s\u00e3o indicativos de que o seu c\u00f3digo n\u00e3o consegue se explicar adequadamente, j\u00e1 que voc\u00ea ter\u00e1 implementado fun\u00e7\u00f5es pequenas, que realizam fun\u00e7\u00f5es \u00fanicas, conforme as recomenda\u00e7\u00f5es acima. \u00c9 claro que existem trechos de c\u00f3digo que precisam ser comentados, mas \u00e9 necess\u00e1rio frisar que coment\u00e1rios geralmente tornam a vida do desenvolvedor mais complicada por n\u00e3o serem atualizados com frequ\u00eancia; assim, o c\u00f3digo muda, mas os coment\u00e1rios descrevendo-o, n\u00e3o. Logo, \u00e9 preciso pensar em coment\u00e1rios como um peso, n\u00e3o um facilitador. As conven\u00e7\u00f5es a seguir descrevem o bom uso de coment\u00e1rios. Vale ressaltar algumas ocasi\u00f5es em que eles podem de fato ser \u00fateis: Explica\u00e7\u00e3o de motiva\u00e7\u00e3o (e.g. por que um caso espec\u00edfico \u00e9 diferente do caso geral?) Avisos de consequ\u00eancia (e.g. se um programa demora muito para ser executado) Coment\u00e1rios TODO E algumas em que eles s\u00e3o inapropriados : Coment\u00e1rios redundantes (que repetem o que est\u00e1 claro no c\u00f3digo) Coment\u00e1rios no fechamento de chaves ou par\u00eanteses (exceto para namespaces ) C\u00f3digo comentado Pode ser \u00fatil ao fazer testes locais, mas deve ser removido antes de colocar no reposit\u00f3rio Se for necess\u00e1rio mais tarde, basta recuperar o hist\u00f3rico do reposit\u00f3rio Informa\u00e7\u00e3o sobre outras partes do c\u00f3digo Informa\u00e7\u00e3o excessiva (e.g. como uma fun\u00e7\u00e3o foi implementada) Nomenclatura Do Google C++ Style Guide: Optimize for readability using names that would be clear even to people on a different team. Use names that describe the purpose or intent of the object. Do not worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader. Minimize the use of abbreviations that would likely be unknown to someone outside your project (especially acronyms and initialisms). Nomes n\u00e3o podem de forma alguma ser amb\u00edguos. Eles devem ser descritivos o suficiente para possibilitarem a leitura fluida do c\u00f3digo por uma pessoa que n\u00e3o conhece muito sobre o sistema, n\u00e3o importando se para isso parecerem muito grandes. Por exemplo, uma pessoa n\u00e3o deve ter que voltar \u00e0 defini\u00e7\u00e3o de uma vari\u00e1vel num para descobrir que \u00e9 um contador do n\u00famero de dummies encontrados; a vari\u00e1vel deveria se chamar number_of_dummmies_found ou ainda possivelmente num_dummies_found . Em geral, quanto maior o escopo de uma vari\u00e1vel, maior deve ser o nome dela para descrever bem um objeto. Por exemplo, dentro da fun\u00e7\u00e3o count_dummies() , uma vari\u00e1vel chamada count seria clara pelo seu contexto, mas n\u00e3o seria caso ela fosse uma vari\u00e1vel global. Ou seja, o nome da vari\u00e1vel precisa ser descritiva o suficiente para ser entendida quando em seu contexto , e n\u00e3o mais. N\u00e3o crie com informa\u00e7\u00e3o que poderia ser inferida da classe ou fun\u00e7\u00e3o em que seu objeto est\u00e1 inserido. Tente evitar abrevia\u00e7\u00f5es, exceto aquelas que s\u00e3o absolutamente \u00f3bvias mesmo para uma pessoa que n\u00e3o conhece o sistema implementado. Inclusividade Do Google C++ Style Guide: In all code, including naming and comments, use inclusive language and avoid terms that other programmers might find disrespectful or offensive (such as \"master\" and \"slave\", \"blacklist\" and \"whitelist\", or \"redline\"), even if the terms also have an ostensibly neutral meaning. Similarly, use gender-neutral language unless you're referring to a specific person (and using their pronouns). For example, use \"they\"/\"them\"/\"their\" for people of unspecified gender (even when singular), and \"it\"/\"its\" for software, computers, and other things that aren't people. Python Layout Geral Indenta\u00e7\u00e3o de 4 espa\u00e7os Linhas devem ter at\u00e9 79 caracteres Pode ser estendido at\u00e9 99 caracteres caso o time escolha isso Textos longos sem restri\u00e7\u00f5es estruturais (e.g. coment\u00e1rios e docstrings ) devem ter no m\u00e1ximo 72 Arquivos devem ser codificados em UTF-8 Quebra de linhas Quebras de linha devem ser indentadas no mesmo n\u00edvel do conte\u00fado original, ou usar \"hanging indent\" - adicionar uma indenta\u00e7\u00e3o para distiguir argumentos de c\u00f3digo, por exemplo # Alinhado com o delimitador foo = long_function_name(var_one, var_two, var_three, var_four) # Adicione um nivel de indentacao para distinguir argumentos do resto def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # Hanging indents foo = long_function_name( var_one, var_two, var_three, var_four) Quebras de linhas em if -statements com mais de uma linha podem ou n\u00e3o ser indentados Fechamento de par\u00eanteses/chaves/colchetes em estruturas de mais de uma linha podem se alinhar com o conte\u00fado ou com o primeiro caractere da linha da estrutura # Alinhamento com o conte\u00fado my_list = [ 1, 2, 3, 4, 5, 6, ] # Alinhamento com o primeiro caractere my_list = [ 1, 2, 3, 4, 5, 6, ] \u00c9 prefer\u00edvel encapsular estruturas de v\u00e1rias linhas entre par\u00eanteses Linhas devem ser quebradas antes de operadores bin\u00e1rios # Errado income = (gross_wages + taxable_interest) # Correto income = (gross_wages + taxable_interest) Espa\u00e7o em branco Separe fun\u00e7\u00f5es de alto n\u00edvel e defini\u00e7\u00f5es de classes com duas linhas em branco Separe m\u00e9todos da mesma classe com uma linha em branco Linhas em branco a mais podem ser usadas, com parcim\u00f4nia, em: Separa\u00e7\u00e3o de conjuntos de fun\u00e7\u00f5es Indica\u00e7\u00e3o de se\u00e7\u00f5es l\u00f3gicas Evite: Dentro de par\u00eanteses/chaves/colchetes Entre uma v\u00edrgula final e o fechamento de par\u00eanteses # Correto foo = (0,) foo = (0,) foo = (0,) Imediatamente antes de um sinal de pontua\u00e7\u00e3o Imediatamente antes de abrir par\u00eanteses ao chamar uma fun\u00e7\u00e3o # Correto spam(1) Mais de dois espa\u00e7os ao redor de um operador de atribui\u00e7\u00e3o para alinh\u00e1-lo com outros Espa\u00e7os no final da linha Colocar espa\u00e7o entre o = e o argumento de uma fun\u00e7\u00e3o # Correto def complex(real, imag=0.0): return magic(r=real, i=imag) # Errado def complex(real, imag = 0.0): return magic(r = real, i = imag) Deixe um espa\u00e7o entre vari\u00e1veis e operadores bin\u00e1rios import Devem estar em linhas separadas Mas se forem v\u00e1rios importados do mesmo local, podem ficar na mesma linha import os import sys from subprocess import Popen, PIPE Sempre vem no topo do arquivo Devem ser agrupados na seguinte ordem: Bibliotecas padr\u00e3o Bibliotecas de terceiros relacionadas Bibliotecas espec\u00edficas \u00e0 aplica\u00e7\u00e3o \u00c9 prefer\u00edvel fazer refer\u00eancia absoluta a import s, mesmo que estejam no mesmo pacote Exceto quando nomes de pacotes forem excessivamente grandes import mypkg.sibling from mypkg import sibling from mypkg.sibling import example \"Wildcard\" import s (como from mavbase.MAV import * ) devem ser evitados Coment\u00e1rios Devem ser frases completas em ingl\u00eas Se fazem refer\u00eancia a vari\u00e1veis, devem referenciar o nome da vari\u00e1vel exatamente como aparece no c\u00f3digo Coment\u00e1rios em blocos Devem ser indentados junto com o c\u00f3digo que referenciam Devem come\u00e7ar com um # Par\u00e1grafos devem ser separados por uma linha contendo somente um # Coment\u00e1rios em linha Devem ser usados com parcim\u00f4nia Devem ser separados do c\u00f3digo por pelo menos 2 espa\u00e7os Nomenclatura \u00c9 prefer\u00edvel manter a consist\u00eancia com c\u00f3digo \"errado\" a misturar estilos no mesmo arquivo Uma outra possibilidade \u00e9 refatorar o programa todo pra se adequar ao padr\u00e3o escolhido pela equipe Pacotes e M\u00f3dulos Tudo min\u00fasculo, com underscore entre as palavras Classes CapWords (aka CamelCase): s\u00f3 as primeiras letras de cada palavra em mai\u00fasculas Tipos de vari\u00e1veis personalizados CapWords, preferencialmente com nomes abreviados Exce\u00e7\u00f5es Exce\u00e7\u00f5es s\u00e3o classes, ent\u00e3o seguem o modelo das classes Usam o sufixo Error Fun\u00e7\u00f5es e Vari\u00e1veis Todas min\u00fasculas, com underscore separando palavras mixedCase tamb\u00e9m \u00e9 permitido se o programa j\u00e1 usa esse estilo Constantes Devem ser com todas as letras mai\u00fasculas, e underscore entre as palavras Especificidades da Linguagem Trailing Commas Geralmente opcionais, mas podem ser \u00fateis se \u00e9 espperado que a lista cres\u00e7a Quando forem usadas, \u00e9 recomendado colocar entre par\u00eanteses N\u00e3o devem estar junto ao fechamento de par\u00eanteses/chaves/colchetes # Correto FILES = ('setup.cfg',) # Errado FILES = 'setup.cfg', # Correto FILES = [ 'setup.cfg', 'tox.ini', ] initialize(FILES, error=True, ) Underscore Existem quatro jeitos de usar underscore em nomes de Python: um_no_final_ # Usado para nao conflitar com nomes reservados um_no_final_ # Usado para nao conflitar com nomes reservados um_no_final_ # Usado para nao conflitar com nomes reservados _um_no_inicio # Indica que a variavel e de uso interno, mas ela ainda pode ser acessada por outros arquivos facilmente _um_no_inicio # Indica que a variavel e de uso interno, mas ela ainda pode ser acessada por outros arquivos facilmente _um_no_inicio # Indica que a variavel e de uso interno, mas ela ainda pode ser acessada por outros arquivos facilmente __dois_no_inicio # Quando for atributo de classe, invoca name mangling (ver Especificades da Linguagem) __dois_no_inicio_e_fim__ # Nomes magicos; NAO invente novos, so use os ja existentes Name mangling Python \"funde\" o nome da classe com o da vari\u00e1vel para dificultar o acesso indevido a ela Por exemplo, se a classe Foo tem um atributo __a , ele n\u00e3o pode ser acessado com Foo.__a , mas sim com Foo._Foo__a Mangling pode afetar debug de programas negativamente docstrings docstrings s\u00e3o uma forma padronizada de documenta\u00e7\u00e3o de fun\u00e7\u00f5es e classes em Python Para um m\u00f3dulo, devem estar no __init__.py e devem listar as classes e fun\u00e7\u00f5es do m\u00f3dulo em resumos de uma linha cada. Para uma classe, devem estar no m\u00e9todo __init__ , e devem listar seus m\u00e9todos p\u00fablicos e interfaces para a cria\u00e7\u00e3o de subclasses (caso existam) Para uma fun\u00e7\u00e3o, deve resumir seus argumentos (argumentos opcionais devem ser indicados), comportamento, valores de sa\u00edda, exce\u00e7\u00f5es levantadas, restri\u00e7\u00f5es ao ser chamada Devem ser posicionadas no inicio do objeto para se tornarem o atributo __doc__ desse objeto Sempre use \"\"\"aspas triplas\"\"\" ao fazer uma docstring def function(a, b): Utilize essa funcao para fazer X coisa. docstrings com mais de uma linha devem ter um resumo de uma linha, seguido de um espa\u00e7o em branco e de uma descri\u00e7\u00e3o mais completa dos elementos e comportamento do objeto def complex_function(a=0.0, b=0.0): Essa funcao faz X coisas. Keyword arguments: a -- pequena descri\u00e7\u00e3o sobre a (default 0.0) b -- pequena descri\u00e7\u00e3o sobre b (default 0.0) Misc Sempre compare algo a None usando is e is not N\u00e3o \u00e9 recomendado definir fun\u00e7\u00f5es com lambda arbitrariamente para ajudar em debugging Ao usar try-except , sempre defina o tipo de erro de que o bloco deve tratar Seja consistente com return : ou todos os return s devolvem express\u00f5es, ou nenhum devolve # Correto def foo(x): if x = 0: return math.sqrt(x) else: return None # Errado def foo(x): if x = 0: return math.sqrt(x) Para sequ\u00eancias ( strings , lists , tuples ), use o fato de que sequ\u00eancias vazias s\u00e3o False # Correto if not seq # Errado if len(seq) C++ Layout Geral Linhas devem ter no m\u00e1ximo 80 caracteres, exceto Em conte\u00fado que n\u00e3o deve ser separado (e.g. URLs) #include Arquivos devem ser codificados em UTF-8 Indenta\u00e7\u00e3o de 2 espa\u00e7os Valores para return \u2192 s\u00f3 use par\u00eanteses caso houver quebra de linha namespace \u2192 n\u00e3o se deve indentar Fun\u00e7\u00f5es Defini\u00e7\u00e3o de fun\u00e7\u00f5es - Tente definir em uma \u00fanica linha - Se lista de argumentos passar de 80 caracteres, quebre a linha desta forma: ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2, Type par_name3) { DoSomething(); ... } Se nem mesmo o primeiro argumento couber na defini\u00e7\u00e3o, fa\u00e7a: ReturnType LongClassName::ReallyReallyReallyLongFunctionName( Type par_name1, // 2 indenta\u00e7\u00f5es Type par_name2, Type par_name3) { DoSomething(); // 1 indenta\u00e7\u00e3o ... } N\u00e3o h\u00e1 espa\u00e7o entre par\u00eanteses e o nome da fun\u00e7\u00e3o A abertura de chaves \u00e9 na mesma linha da declara\u00e7\u00e3o da fun\u00e7\u00e3o O fechamento de chaves \u00e9 na mesma linha da abertura ou em uma linha pr\u00f3pria Chamar fun\u00e7\u00f5es Seguem as mesmas regras de quebra de linha que defini\u00e7\u00f5es de fun\u00e7\u00f5es Caso um argumento seja uma express\u00e3o muito complexa, considere dar um nome a ele, ou adicion\u00e1-lo sozinho numa linha Essas regras podem ser quebradas se o posicionamento espacial dos argumentos auxiliar na legibilidade (e.g quando trabalhando com matrizes) // Dando um nome ao argumento int my_heuristic = scores[x] * y + bases[x]; bool result = DoSomething(my_heuristic, x, y, z); // Separando o argumento em uma linha a parte bool result = DoSomething(scores[x] * y + bases[x], // Score heuristic. x, y, z); Condicionais Coloque um espa\u00e7o entre o if e os par\u00eanteses Chaves devem ser abertas na mesma linha da declara\u00e7\u00e3o, e fechadas em uma continua\u00e7\u00e3o (e.g. if (...) { } else { ) ou em uma linha separada Caso a condicional seja um \u00fanico if , pode-se omitir as chaves Loops Chaves s\u00e3o opcionais caso o loop tenha s\u00f3 uma declara\u00e7\u00e3o Loops vazios devem abrir e fechar chaves vazias ou ter uma declara\u00e7\u00e3o continue dentro deles para mostrar que est\u00e3o vazios while (condition) { // Repete o teste ate que retorne falso. } for (int i = 0; i kSomeNumber; ++i) {} // Bom while (condition) continue; // Bom - ainda indica que nao ha logica while (condition); // Ruim - parece parte de um do/while Ponteiros Refer\u00eancias a ponteiros devem seguir o padr\u00e3o: x = *p; p = x; x = r.y; x = r- y; Quando juntos de defini\u00e7\u00f5es de tipo, pode haver espa\u00e7o antes, depois ou ele pode ser emitido; deve-se ser consistente dentro do mesmo arquivo // Espaco antes char *c; const std::string str; int *GetPointer(); std::vector char * // Espaco depois char* c; const std::string str; int* GetPointer(); // Espaco omitido std::vector char* Classes Se\u00e7\u00f5es de public , protected e private s\u00e3o indentadas com rela\u00e7\u00e3o \u00e0 defini\u00e7\u00e3o da classe e devem ser precedidas por uma linha em branco (exceto a primeira inst\u00e2ncia) Construtores devem ter lista de par\u00e2metros seguindo as regras de quebra de linha de fun\u00e7\u00f5es descritas acima Exemplo: class MyClass : public OtherClass { public: MyClass(); explicit MyClass(int var); ~MyClass() {} void SomeFunction(); void SomeFunctionThatDoesNothing() { } void set_some_var(int var) { some_var_ = var; } int some_var() const { return some_var_; } private: bool SomeInternalFunction(); int some_var_; int some_other_var_; }; // Quando tudo cabe em uma linha MyClass::MyClass(int var) : some_var_(var) { DoSomething(); } // Se a lista de atributos nao estiver toda na mesma linha, // voce deve quebrar antes dos dois-pontos e indentar 4 espacos: MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) { DoSomething(); } // Quando a lista tem muitas linhas, coloque cada atributo // em uma linha e os alinhe: MyClass::MyClass(int var) : some_var_(var), // indentacao de 4 espacos some_other_var_(var + 1) { // alinhado DoSomething(); } Espa\u00e7o em branco Horizontal \u2192 depende da localiza\u00e7\u00e3o, mas NUNCA no final de uma linha Seja consistente: se houver de um lado de par\u00eanteses, coloque no outro tamb\u00e9m Operadores matem\u00e1ticos un\u00e1rios tem espa\u00e7o para a vari\u00e1vel Operadores bin\u00e1rios devem ter espa\u00e7o, mas \u00e9 permitido remover de fatores Par\u00eanteses n\u00e3o devem ter espa\u00e7o interno Vertical \u2192 minimize sempre que poss\u00edvel N\u00e3o \u00e9 uma regra, mas uma recomenda\u00e7\u00e3o Linhas em branco s\u00e3o como quebras de par\u00e1grafo - elas deve separar blocos coesos de c\u00f3digo Coment\u00e1rios Classes Todas as classes ou structs n\u00e3o \u00f3bvias devem ter coment\u00e1rios que descrevem o que elas fazem e como us\u00e1-las Com separa\u00e7\u00e3o suficiente entre .cc e .h , coment\u00e1rios de implementa\u00e7\u00e3o devem ir no .cc e de uso, no .h Fun\u00e7\u00f5es Devem ter coment\u00e1rios come\u00e7ando com verbos cujo sujeito impl\u00edcito \u00e9 \"esta fun\u00e7\u00e3o\" N\u00e3o descrevem como ela faz o que faz Devem descrever como a fun\u00e7\u00e3o interage com o mundo externo, descrevendo por exemplo: Entradas e sa\u00eddas Aloca\u00e7\u00e3o de mem\u00f3ria (s\u00f3 se o usu\u00e1rio precisar desalocar) Se algum dos argumentos pode ser NULL ou n\u00e3o Coment\u00e1rios dentro da fun\u00e7\u00e3o devem ser usados com parcim\u00f4nia para descrever peculiaridades de implementa\u00e7\u00e3o (e.g. por que o primeiro caso \u00e9 diferente do caso geral em um loop) Vari\u00e1veis Atributos de classe S\u00f3 se o tipo e nome da vari\u00e1vel n\u00e3o a descreverem o suficiente Descreva valores padr\u00e3o, como no exemplo: private: // Usado para conferir acesso a tabela. -1 significa // que n\u00e3o sabemos ainda quantas entradas a tabela tem. int num_total_entries_; Vari\u00e1veis globais Todas precisam de um coment\u00e1rio explicando o que s\u00e3o, como s\u00e3o usadas e, caso n\u00e3o esteja claro, porque precisam ser globais // O numero de vezes que passamos por essse teste. const int kNumTestCases = 6; Implementa\u00e7\u00e3o Blocos de c\u00f3digo complicados devem ter coment\u00e1rios explicat\u00f3rios antes do c\u00f3digo em si Linhas confusas dever ter coment\u00e1rios no final da linha, separados por um Tab do c\u00f3digo Argumentos de fun\u00e7\u00f5es S\u00f3 quando n\u00e3o forem \u00f3bvios pelos nomes ou pela descri\u00e7\u00e3o da fun\u00e7\u00e3o Se o argumento for uma constante, deixe isso expl\u00edcito no nome dela Caso a fun\u00e7\u00e3o receba muitos argumentos, considere criar uma struct ou classe para cont\u00ea-los. Por exemplo: ProductOptions options; options.set_precision_decimals(7); options.set_use_cache(ProductOptions::kDontUseCache); const DecimalNumber product = CalculateProduct(values, options, /*completion_callback=*/nullptr); Em \u00faltimo caso, explique os argumentos com coment\u00e1rios Nomenclatura Arquivos Letras todas min\u00fasculas, com _ (preferencialmente) ou - separando palavras Arquivos em C++ deveriam terminar com .cc e headers com .h my_useful_class.cc # Prefer\u00edvel my-useful-class.cc Classes e Tipos de vari\u00e1veis personalizados Todas as palavras come\u00e7am com letra mai\u00fascula, sem separa\u00e7\u00e3o entre elas class UrlTable { ... } struct UrlTableProperties { ... } Vari\u00e1veis Geral: Todas min\u00fasculas, com _ entre palavras Atributos de classe: mesmo que Geral, mas com _ a mais no final // Nome de uma vari\u00e1vel qualquer std::string table_name; class TableInfo { ... private: std::string table_name_; // OK - underscore no final. static Pool TableInfo * pool_; // OK. }; Constantes Come\u00e7am com k ; palavras subsequentes come\u00e7am com letra mai\u00fascula const int kDaysInAWeek = 7; Fun\u00e7\u00f5es Todas as palavras come\u00e7am com mai\u00fascula Se for fun\u00e7\u00e3o de acesso ou modificador (i.e. getter ou setter), \u00e9 nomeado como uma vari\u00e1vel OpenFile() // Getter e setter int count() void set_count(int count) namespaces Tudo min\u00fasculo, com _ separando palavras Deve ser o nome do projeto contido no namespace Macros ( #define ) Tudo mai\u00fasculo, com _ separando Especificidades da Linguagem Headers (arquivos .h ) Todo c\u00f3digo que n\u00e3o seja extremamente curto ou um teste unit\u00e1rio deve ter um .h Todo .h deve ter um \"header guard\" para impedir inclus\u00e3o m\u00faltipla: // No arquivo foo/src/bar/baz.h #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ N\u00e3o declare fun\u00e7\u00f5es antes de defini-las - use o .h N\u00e3o declare fun\u00e7\u00f5es do tipo static em um arquivo .h Ordem de inclus\u00e3o do #include Headers relacionados Headers de C Headers de C++ Headers de bibliotecas padr\u00e3o Headers de outras bibliotecas Headers definidos no seu projeto Cada grupo deve ser separado por uma linha em branco namespaces Namespaces subdivide the global scope into distinct, named scopes, and so are useful for preventing name collisions in the global scope. O final de namespace s grandes deve ser comentado N\u00e3o declare nada dentro do namespace std N\u00c3O use a diretiva using (e.g. using namespace foo ), porque ela polui o namespace Misc D\u00ea valor a vari\u00e1veis no momento em que elas forem declaradas Prefira n\u00e3o declarar vari\u00e1veis globais est\u00e1ticas - elas podem causar bugs dif\u00edceis de encontrar depois structs s\u00f3 devem ser usados para armazenamento de objetos passivos, sen\u00e3o devem ser usadas classes Em geral, \u00e9 prefer\u00edvel compor classes (ter um objeto de uma classe como atributo de outra) a usar inheritance S\u00f3 fa\u00e7a uma subclasse de uma superclasse se o objeto da subclasse for \"um tipo de\" objeto da superclasse (e.g. Skyrats \u00e9 \"um tipo de\" Grupo de Extens\u00e3o) Para representar o valor NULL , use nullptr para ponteiros e '\\0' para char ROS Nomenclatura Pacotes, T\u00f3picos e Servi\u00e7os Todas as letras min\u00fasculas, com underscore entre palavras Arquivos Todas as letras min\u00fasculas, com underscore entre palavras Misc Sa\u00edda do terminal Evite print e similares; prefira logs do ROS (e.g. rospy.loginfo() ) e outras fun\u00e7\u00f5es do pacote rosconsole C\u00f3digo n\u00e3o mais mantido Em headers ( .h ), coloque um coment\u00e1rio Para fun\u00e7\u00f5es, use ROS_DEPRECATED Para classes, use ROS_DEPRECATED no construtor da classe Refer\u00eancias Google C++ Style Guide PEP 8 -- Style Guide for Python Code PEP 257 -- Docstring Conventions ROS Style Guide","title":"Conven\u00e7\u00f5es de C\u00f3digo"},{"location":"Software/Convencoes-de-Codigo/#convencoes-de-codigo","text":"Em geral, times de desenvolvedores passam mais tempo lendo e mantendo c\u00f3digo j\u00e1 escrito (incluindo durante debugging) do que escrevendo c\u00f3digo novo. Assim, \u00e9 necess\u00e1rio que c\u00f3digo seja de f\u00e1cil compreens\u00e3o tanto para a pessoa que o desenvolveu inicialmente, mas n\u00e3o se lembra de todos os detalhes, quanto para outros membros do time que nunca trabalharam no projeto. Nesse contexto, conven\u00e7\u00f5es de programa\u00e7\u00e3o servem como uma funda\u00e7\u00e3o para que todos consigam entender e escrever com facilidade c\u00f3digo que outras pessoas entendam. Elas economizam tempo de revis\u00e3o, permitindo que o programador entenda mais rapidamente a estrutura de um programa pouco familiar. Al\u00e9m disso, facilitam que outros grupos integrem c\u00f3digo de diversos times e adaptem-no com facilidade.","title":"Conven\u00e7\u00f5es de C\u00f3digo"},{"location":"Software/Convencoes-de-Codigo/#principios-gerais","text":"Essa se\u00e7\u00e3o descreve atributos de C\u00f3digo Limpo, e que se aplicam a qualquer linguagem de programa\u00e7\u00e3o. Ela n\u00e3o \u00e9 excludente com as se\u00e7\u00f5es de linguagens espec\u00edficas, e \u00e9 at\u00e9 mais importante do que as outras.","title":"Princ\u00edpios gerais"},{"location":"Software/Convencoes-de-Codigo/#layout","text":"Programas s\u00e3o em geral complexos, realizando diversas tarefas para chegar ao resultado desejado. Por isso, \u00e9 importante que essas tarefas estejam bem segmentadas em fun\u00e7\u00f5es e classes claras, sem repeti\u00e7\u00e3o e, o m\u00e1ximo poss\u00edvel, independentes da implementa\u00e7\u00e3o de outras fun\u00e7\u00f5es ou classes.","title":"Layout"},{"location":"Software/Convencoes-de-Codigo/#funcoes","text":"Devem ser pequenas, realizando apenas uma \u00fanica tarefa \u00c9 aconselh\u00e1vel tentar deixar suas fun\u00e7\u00f5es com at\u00e9 20 linhas, mas isso n\u00e3o \u00e9 necess\u00e1rio De prefer\u00eancia em um \u00fanico n\u00edvel de abstra\u00e7\u00e3o (esse \u00e9 o crit\u00e9rio mais dif\u00edcil de implementar) Devem ter o menor n\u00famero de argumentos poss\u00edvel, preferencialmente at\u00e9 3 Caso tenha mais, possivelmente esses argumentos poderiam ser colocados em um objeto de mais f\u00e1cil compreens\u00e3o (e.g. um objeto Point em vez de x e y ) Caso v\u00e1rias fun\u00e7\u00f5es dependam de uma mesma lista de argumentos, considere coloc\u00e1-las em uma classe \u00e0 parte Devem ou executar uma tarefa, ou retornas informa\u00e7\u00e3o, mas n\u00e3o os dois Devem preferencialmente n\u00e3o modificar seus argumentos ou ter efeitos em outros objetos que n\u00e3o estejam \u00f3bvios","title":"Fun\u00e7\u00f5es"},{"location":"Software/Convencoes-de-Codigo/#classes","text":"Devem ser pequenas e coesas (i.e. ter membros com depend\u00eancias similares e que necessariamente se beneficiam de estarem juntos) Devem permitir adi\u00e7\u00e3o de novas fun\u00e7\u00f5es facilmente \u00c9 necess\u00e1rio ressaltar que nenhum objeto deve depender da implementa\u00e7\u00e3o de outro . Por exemplo, uma classe DrawCircle depende do fato da classe LocateCircle ter atributos center_x_ e center_y_ . Posteriormente, a classe LocateCircle passa a armazenar o centro em coordenadas polares. Com isso, DrawCircle vai parar de funcionar e vai precisar ser modificada tamb\u00e9m. Nesse exemplo, seria mais adequado existir uma fun\u00e7\u00e3o GetCircleCenter em LocateCircle , criando uma camada de abstra\u00e7\u00e3o entre as implementa\u00e7\u00f5es das classes.","title":"Classes"},{"location":"Software/Convencoes-de-Codigo/#comentarios","text":"Do Google C++ Style Guide: Comments are absolutely vital to keeping our code readable. The following rules describe what you should comment and where. But remember: while comments are very important, the best code is self-documenting. Do Style Guide for Python Code Comments that contradict the code are worse than no comments. Always make a priority of keeping the comments up-to-date when the code changes! Idealmente, c\u00f3digo bem escrito n\u00e3o exige coment\u00e1rios. Eles s\u00e3o indicativos de que o seu c\u00f3digo n\u00e3o consegue se explicar adequadamente, j\u00e1 que voc\u00ea ter\u00e1 implementado fun\u00e7\u00f5es pequenas, que realizam fun\u00e7\u00f5es \u00fanicas, conforme as recomenda\u00e7\u00f5es acima. \u00c9 claro que existem trechos de c\u00f3digo que precisam ser comentados, mas \u00e9 necess\u00e1rio frisar que coment\u00e1rios geralmente tornam a vida do desenvolvedor mais complicada por n\u00e3o serem atualizados com frequ\u00eancia; assim, o c\u00f3digo muda, mas os coment\u00e1rios descrevendo-o, n\u00e3o. Logo, \u00e9 preciso pensar em coment\u00e1rios como um peso, n\u00e3o um facilitador. As conven\u00e7\u00f5es a seguir descrevem o bom uso de coment\u00e1rios. Vale ressaltar algumas ocasi\u00f5es em que eles podem de fato ser \u00fateis: Explica\u00e7\u00e3o de motiva\u00e7\u00e3o (e.g. por que um caso espec\u00edfico \u00e9 diferente do caso geral?) Avisos de consequ\u00eancia (e.g. se um programa demora muito para ser executado) Coment\u00e1rios TODO E algumas em que eles s\u00e3o inapropriados : Coment\u00e1rios redundantes (que repetem o que est\u00e1 claro no c\u00f3digo) Coment\u00e1rios no fechamento de chaves ou par\u00eanteses (exceto para namespaces ) C\u00f3digo comentado Pode ser \u00fatil ao fazer testes locais, mas deve ser removido antes de colocar no reposit\u00f3rio Se for necess\u00e1rio mais tarde, basta recuperar o hist\u00f3rico do reposit\u00f3rio Informa\u00e7\u00e3o sobre outras partes do c\u00f3digo Informa\u00e7\u00e3o excessiva (e.g. como uma fun\u00e7\u00e3o foi implementada)","title":"Coment\u00e1rios"},{"location":"Software/Convencoes-de-Codigo/#nomenclatura","text":"Do Google C++ Style Guide: Optimize for readability using names that would be clear even to people on a different team. Use names that describe the purpose or intent of the object. Do not worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader. Minimize the use of abbreviations that would likely be unknown to someone outside your project (especially acronyms and initialisms). Nomes n\u00e3o podem de forma alguma ser amb\u00edguos. Eles devem ser descritivos o suficiente para possibilitarem a leitura fluida do c\u00f3digo por uma pessoa que n\u00e3o conhece muito sobre o sistema, n\u00e3o importando se para isso parecerem muito grandes. Por exemplo, uma pessoa n\u00e3o deve ter que voltar \u00e0 defini\u00e7\u00e3o de uma vari\u00e1vel num para descobrir que \u00e9 um contador do n\u00famero de dummies encontrados; a vari\u00e1vel deveria se chamar number_of_dummmies_found ou ainda possivelmente num_dummies_found . Em geral, quanto maior o escopo de uma vari\u00e1vel, maior deve ser o nome dela para descrever bem um objeto. Por exemplo, dentro da fun\u00e7\u00e3o count_dummies() , uma vari\u00e1vel chamada count seria clara pelo seu contexto, mas n\u00e3o seria caso ela fosse uma vari\u00e1vel global. Ou seja, o nome da vari\u00e1vel precisa ser descritiva o suficiente para ser entendida quando em seu contexto , e n\u00e3o mais. N\u00e3o crie com informa\u00e7\u00e3o que poderia ser inferida da classe ou fun\u00e7\u00e3o em que seu objeto est\u00e1 inserido. Tente evitar abrevia\u00e7\u00f5es, exceto aquelas que s\u00e3o absolutamente \u00f3bvias mesmo para uma pessoa que n\u00e3o conhece o sistema implementado.","title":"Nomenclatura"},{"location":"Software/Convencoes-de-Codigo/#inclusividade","text":"Do Google C++ Style Guide: In all code, including naming and comments, use inclusive language and avoid terms that other programmers might find disrespectful or offensive (such as \"master\" and \"slave\", \"blacklist\" and \"whitelist\", or \"redline\"), even if the terms also have an ostensibly neutral meaning. Similarly, use gender-neutral language unless you're referring to a specific person (and using their pronouns). For example, use \"they\"/\"them\"/\"their\" for people of unspecified gender (even when singular), and \"it\"/\"its\" for software, computers, and other things that aren't people.","title":"Inclusividade"},{"location":"Software/Convencoes-de-Codigo/#python","text":"","title":"Python"},{"location":"Software/Convencoes-de-Codigo/#layout_1","text":"","title":"Layout"},{"location":"Software/Convencoes-de-Codigo/#geral","text":"Indenta\u00e7\u00e3o de 4 espa\u00e7os Linhas devem ter at\u00e9 79 caracteres Pode ser estendido at\u00e9 99 caracteres caso o time escolha isso Textos longos sem restri\u00e7\u00f5es estruturais (e.g. coment\u00e1rios e docstrings ) devem ter no m\u00e1ximo 72 Arquivos devem ser codificados em UTF-8","title":"Geral"},{"location":"Software/Convencoes-de-Codigo/#quebra-de-linhas","text":"Quebras de linha devem ser indentadas no mesmo n\u00edvel do conte\u00fado original, ou usar \"hanging indent\" - adicionar uma indenta\u00e7\u00e3o para distiguir argumentos de c\u00f3digo, por exemplo # Alinhado com o delimitador foo = long_function_name(var_one, var_two, var_three, var_four) # Adicione um nivel de indentacao para distinguir argumentos do resto def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # Hanging indents foo = long_function_name( var_one, var_two, var_three, var_four) Quebras de linhas em if -statements com mais de uma linha podem ou n\u00e3o ser indentados Fechamento de par\u00eanteses/chaves/colchetes em estruturas de mais de uma linha podem se alinhar com o conte\u00fado ou com o primeiro caractere da linha da estrutura # Alinhamento com o conte\u00fado my_list = [ 1, 2, 3, 4, 5, 6, ] # Alinhamento com o primeiro caractere my_list = [ 1, 2, 3, 4, 5, 6, ] \u00c9 prefer\u00edvel encapsular estruturas de v\u00e1rias linhas entre par\u00eanteses Linhas devem ser quebradas antes de operadores bin\u00e1rios # Errado income = (gross_wages + taxable_interest) # Correto income = (gross_wages + taxable_interest)","title":"Quebra de linhas"},{"location":"Software/Convencoes-de-Codigo/#espaco-em-branco","text":"Separe fun\u00e7\u00f5es de alto n\u00edvel e defini\u00e7\u00f5es de classes com duas linhas em branco Separe m\u00e9todos da mesma classe com uma linha em branco Linhas em branco a mais podem ser usadas, com parcim\u00f4nia, em: Separa\u00e7\u00e3o de conjuntos de fun\u00e7\u00f5es Indica\u00e7\u00e3o de se\u00e7\u00f5es l\u00f3gicas Evite: Dentro de par\u00eanteses/chaves/colchetes Entre uma v\u00edrgula final e o fechamento de par\u00eanteses # Correto foo = (0,) foo = (0,) foo = (0,) Imediatamente antes de um sinal de pontua\u00e7\u00e3o Imediatamente antes de abrir par\u00eanteses ao chamar uma fun\u00e7\u00e3o # Correto spam(1) Mais de dois espa\u00e7os ao redor de um operador de atribui\u00e7\u00e3o para alinh\u00e1-lo com outros Espa\u00e7os no final da linha Colocar espa\u00e7o entre o = e o argumento de uma fun\u00e7\u00e3o # Correto def complex(real, imag=0.0): return magic(r=real, i=imag) # Errado def complex(real, imag = 0.0): return magic(r = real, i = imag) Deixe um espa\u00e7o entre vari\u00e1veis e operadores bin\u00e1rios","title":"Espa\u00e7o em branco"},{"location":"Software/Convencoes-de-Codigo/#import","text":"Devem estar em linhas separadas Mas se forem v\u00e1rios importados do mesmo local, podem ficar na mesma linha import os import sys from subprocess import Popen, PIPE Sempre vem no topo do arquivo Devem ser agrupados na seguinte ordem: Bibliotecas padr\u00e3o Bibliotecas de terceiros relacionadas Bibliotecas espec\u00edficas \u00e0 aplica\u00e7\u00e3o \u00c9 prefer\u00edvel fazer refer\u00eancia absoluta a import s, mesmo que estejam no mesmo pacote Exceto quando nomes de pacotes forem excessivamente grandes import mypkg.sibling from mypkg import sibling from mypkg.sibling import example \"Wildcard\" import s (como from mavbase.MAV import * ) devem ser evitados","title":"import"},{"location":"Software/Convencoes-de-Codigo/#comentarios_1","text":"Devem ser frases completas em ingl\u00eas Se fazem refer\u00eancia a vari\u00e1veis, devem referenciar o nome da vari\u00e1vel exatamente como aparece no c\u00f3digo Coment\u00e1rios em blocos Devem ser indentados junto com o c\u00f3digo que referenciam Devem come\u00e7ar com um # Par\u00e1grafos devem ser separados por uma linha contendo somente um # Coment\u00e1rios em linha Devem ser usados com parcim\u00f4nia Devem ser separados do c\u00f3digo por pelo menos 2 espa\u00e7os","title":"Coment\u00e1rios"},{"location":"Software/Convencoes-de-Codigo/#nomenclatura_1","text":"\u00c9 prefer\u00edvel manter a consist\u00eancia com c\u00f3digo \"errado\" a misturar estilos no mesmo arquivo Uma outra possibilidade \u00e9 refatorar o programa todo pra se adequar ao padr\u00e3o escolhido pela equipe","title":"Nomenclatura"},{"location":"Software/Convencoes-de-Codigo/#pacotes-e-modulos","text":"Tudo min\u00fasculo, com underscore entre as palavras","title":"Pacotes e M\u00f3dulos"},{"location":"Software/Convencoes-de-Codigo/#classes_1","text":"CapWords (aka CamelCase): s\u00f3 as primeiras letras de cada palavra em mai\u00fasculas","title":"Classes"},{"location":"Software/Convencoes-de-Codigo/#tipos-de-variaveis-personalizados","text":"CapWords, preferencialmente com nomes abreviados","title":"Tipos de vari\u00e1veis personalizados"},{"location":"Software/Convencoes-de-Codigo/#excecoes","text":"Exce\u00e7\u00f5es s\u00e3o classes, ent\u00e3o seguem o modelo das classes Usam o sufixo Error","title":"Exce\u00e7\u00f5es"},{"location":"Software/Convencoes-de-Codigo/#funcoes-e-variaveis","text":"Todas min\u00fasculas, com underscore separando palavras mixedCase tamb\u00e9m \u00e9 permitido se o programa j\u00e1 usa esse estilo","title":"Fun\u00e7\u00f5es e Vari\u00e1veis"},{"location":"Software/Convencoes-de-Codigo/#constantes","text":"Devem ser com todas as letras mai\u00fasculas, e underscore entre as palavras","title":"Constantes"},{"location":"Software/Convencoes-de-Codigo/#especificidades-da-linguagem","text":"","title":"Especificidades da Linguagem"},{"location":"Software/Convencoes-de-Codigo/#trailing-commas","text":"Geralmente opcionais, mas podem ser \u00fateis se \u00e9 espperado que a lista cres\u00e7a Quando forem usadas, \u00e9 recomendado colocar entre par\u00eanteses N\u00e3o devem estar junto ao fechamento de par\u00eanteses/chaves/colchetes # Correto FILES = ('setup.cfg',) # Errado FILES = 'setup.cfg', # Correto FILES = [ 'setup.cfg', 'tox.ini', ] initialize(FILES, error=True, )","title":"Trailing Commas"},{"location":"Software/Convencoes-de-Codigo/#underscore","text":"Existem quatro jeitos de usar underscore em nomes de Python: um_no_final_ # Usado para nao conflitar com nomes reservados um_no_final_ # Usado para nao conflitar com nomes reservados um_no_final_ # Usado para nao conflitar com nomes reservados _um_no_inicio # Indica que a variavel e de uso interno, mas ela ainda pode ser acessada por outros arquivos facilmente _um_no_inicio # Indica que a variavel e de uso interno, mas ela ainda pode ser acessada por outros arquivos facilmente _um_no_inicio # Indica que a variavel e de uso interno, mas ela ainda pode ser acessada por outros arquivos facilmente __dois_no_inicio # Quando for atributo de classe, invoca name mangling (ver Especificades da Linguagem) __dois_no_inicio_e_fim__ # Nomes magicos; NAO invente novos, so use os ja existentes","title":"Underscore"},{"location":"Software/Convencoes-de-Codigo/#name-mangling","text":"Python \"funde\" o nome da classe com o da vari\u00e1vel para dificultar o acesso indevido a ela Por exemplo, se a classe Foo tem um atributo __a , ele n\u00e3o pode ser acessado com Foo.__a , mas sim com Foo._Foo__a Mangling pode afetar debug de programas negativamente","title":"Name mangling"},{"location":"Software/Convencoes-de-Codigo/#docstrings","text":"docstrings s\u00e3o uma forma padronizada de documenta\u00e7\u00e3o de fun\u00e7\u00f5es e classes em Python Para um m\u00f3dulo, devem estar no __init__.py e devem listar as classes e fun\u00e7\u00f5es do m\u00f3dulo em resumos de uma linha cada. Para uma classe, devem estar no m\u00e9todo __init__ , e devem listar seus m\u00e9todos p\u00fablicos e interfaces para a cria\u00e7\u00e3o de subclasses (caso existam) Para uma fun\u00e7\u00e3o, deve resumir seus argumentos (argumentos opcionais devem ser indicados), comportamento, valores de sa\u00edda, exce\u00e7\u00f5es levantadas, restri\u00e7\u00f5es ao ser chamada Devem ser posicionadas no inicio do objeto para se tornarem o atributo __doc__ desse objeto Sempre use \"\"\"aspas triplas\"\"\" ao fazer uma docstring def function(a, b): Utilize essa funcao para fazer X coisa. docstrings com mais de uma linha devem ter um resumo de uma linha, seguido de um espa\u00e7o em branco e de uma descri\u00e7\u00e3o mais completa dos elementos e comportamento do objeto def complex_function(a=0.0, b=0.0): Essa funcao faz X coisas. Keyword arguments: a -- pequena descri\u00e7\u00e3o sobre a (default 0.0) b -- pequena descri\u00e7\u00e3o sobre b (default 0.0)","title":"docstrings"},{"location":"Software/Convencoes-de-Codigo/#misc","text":"Sempre compare algo a None usando is e is not N\u00e3o \u00e9 recomendado definir fun\u00e7\u00f5es com lambda arbitrariamente para ajudar em debugging Ao usar try-except , sempre defina o tipo de erro de que o bloco deve tratar Seja consistente com return : ou todos os return s devolvem express\u00f5es, ou nenhum devolve # Correto def foo(x): if x = 0: return math.sqrt(x) else: return None # Errado def foo(x): if x = 0: return math.sqrt(x) Para sequ\u00eancias ( strings , lists , tuples ), use o fato de que sequ\u00eancias vazias s\u00e3o False # Correto if not seq # Errado if len(seq)","title":"Misc"},{"location":"Software/Convencoes-de-Codigo/#c","text":"","title":"C++"},{"location":"Software/Convencoes-de-Codigo/#layout_2","text":"","title":"Layout"},{"location":"Software/Convencoes-de-Codigo/#geral_1","text":"Linhas devem ter no m\u00e1ximo 80 caracteres, exceto Em conte\u00fado que n\u00e3o deve ser separado (e.g. URLs) #include Arquivos devem ser codificados em UTF-8 Indenta\u00e7\u00e3o de 2 espa\u00e7os Valores para return \u2192 s\u00f3 use par\u00eanteses caso houver quebra de linha namespace \u2192 n\u00e3o se deve indentar","title":"Geral"},{"location":"Software/Convencoes-de-Codigo/#funcoes_1","text":"Defini\u00e7\u00e3o de fun\u00e7\u00f5es - Tente definir em uma \u00fanica linha - Se lista de argumentos passar de 80 caracteres, quebre a linha desta forma: ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2, Type par_name3) { DoSomething(); ... } Se nem mesmo o primeiro argumento couber na defini\u00e7\u00e3o, fa\u00e7a: ReturnType LongClassName::ReallyReallyReallyLongFunctionName( Type par_name1, // 2 indenta\u00e7\u00f5es Type par_name2, Type par_name3) { DoSomething(); // 1 indenta\u00e7\u00e3o ... } N\u00e3o h\u00e1 espa\u00e7o entre par\u00eanteses e o nome da fun\u00e7\u00e3o A abertura de chaves \u00e9 na mesma linha da declara\u00e7\u00e3o da fun\u00e7\u00e3o O fechamento de chaves \u00e9 na mesma linha da abertura ou em uma linha pr\u00f3pria Chamar fun\u00e7\u00f5es Seguem as mesmas regras de quebra de linha que defini\u00e7\u00f5es de fun\u00e7\u00f5es Caso um argumento seja uma express\u00e3o muito complexa, considere dar um nome a ele, ou adicion\u00e1-lo sozinho numa linha Essas regras podem ser quebradas se o posicionamento espacial dos argumentos auxiliar na legibilidade (e.g quando trabalhando com matrizes) // Dando um nome ao argumento int my_heuristic = scores[x] * y + bases[x]; bool result = DoSomething(my_heuristic, x, y, z); // Separando o argumento em uma linha a parte bool result = DoSomething(scores[x] * y + bases[x], // Score heuristic. x, y, z);","title":"Fun\u00e7\u00f5es"},{"location":"Software/Convencoes-de-Codigo/#condicionais","text":"Coloque um espa\u00e7o entre o if e os par\u00eanteses Chaves devem ser abertas na mesma linha da declara\u00e7\u00e3o, e fechadas em uma continua\u00e7\u00e3o (e.g. if (...) { } else { ) ou em uma linha separada Caso a condicional seja um \u00fanico if , pode-se omitir as chaves","title":"Condicionais"},{"location":"Software/Convencoes-de-Codigo/#loops","text":"Chaves s\u00e3o opcionais caso o loop tenha s\u00f3 uma declara\u00e7\u00e3o Loops vazios devem abrir e fechar chaves vazias ou ter uma declara\u00e7\u00e3o continue dentro deles para mostrar que est\u00e3o vazios while (condition) { // Repete o teste ate que retorne falso. } for (int i = 0; i kSomeNumber; ++i) {} // Bom while (condition) continue; // Bom - ainda indica que nao ha logica while (condition); // Ruim - parece parte de um do/while","title":"Loops"},{"location":"Software/Convencoes-de-Codigo/#ponteiros","text":"Refer\u00eancias a ponteiros devem seguir o padr\u00e3o: x = *p; p = x; x = r.y; x = r- y; Quando juntos de defini\u00e7\u00f5es de tipo, pode haver espa\u00e7o antes, depois ou ele pode ser emitido; deve-se ser consistente dentro do mesmo arquivo // Espaco antes char *c; const std::string str; int *GetPointer(); std::vector char * // Espaco depois char* c; const std::string str; int* GetPointer(); // Espaco omitido std::vector char*","title":"Ponteiros"},{"location":"Software/Convencoes-de-Codigo/#classes_2","text":"Se\u00e7\u00f5es de public , protected e private s\u00e3o indentadas com rela\u00e7\u00e3o \u00e0 defini\u00e7\u00e3o da classe e devem ser precedidas por uma linha em branco (exceto a primeira inst\u00e2ncia) Construtores devem ter lista de par\u00e2metros seguindo as regras de quebra de linha de fun\u00e7\u00f5es descritas acima Exemplo: class MyClass : public OtherClass { public: MyClass(); explicit MyClass(int var); ~MyClass() {} void SomeFunction(); void SomeFunctionThatDoesNothing() { } void set_some_var(int var) { some_var_ = var; } int some_var() const { return some_var_; } private: bool SomeInternalFunction(); int some_var_; int some_other_var_; }; // Quando tudo cabe em uma linha MyClass::MyClass(int var) : some_var_(var) { DoSomething(); } // Se a lista de atributos nao estiver toda na mesma linha, // voce deve quebrar antes dos dois-pontos e indentar 4 espacos: MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) { DoSomething(); } // Quando a lista tem muitas linhas, coloque cada atributo // em uma linha e os alinhe: MyClass::MyClass(int var) : some_var_(var), // indentacao de 4 espacos some_other_var_(var + 1) { // alinhado DoSomething(); }","title":"Classes"},{"location":"Software/Convencoes-de-Codigo/#espaco-em-branco_1","text":"Horizontal \u2192 depende da localiza\u00e7\u00e3o, mas NUNCA no final de uma linha Seja consistente: se houver de um lado de par\u00eanteses, coloque no outro tamb\u00e9m Operadores matem\u00e1ticos un\u00e1rios tem espa\u00e7o para a vari\u00e1vel Operadores bin\u00e1rios devem ter espa\u00e7o, mas \u00e9 permitido remover de fatores Par\u00eanteses n\u00e3o devem ter espa\u00e7o interno Vertical \u2192 minimize sempre que poss\u00edvel N\u00e3o \u00e9 uma regra, mas uma recomenda\u00e7\u00e3o Linhas em branco s\u00e3o como quebras de par\u00e1grafo - elas deve separar blocos coesos de c\u00f3digo","title":"Espa\u00e7o em branco"},{"location":"Software/Convencoes-de-Codigo/#comentarios_2","text":"","title":"Coment\u00e1rios"},{"location":"Software/Convencoes-de-Codigo/#classes_3","text":"Todas as classes ou structs n\u00e3o \u00f3bvias devem ter coment\u00e1rios que descrevem o que elas fazem e como us\u00e1-las Com separa\u00e7\u00e3o suficiente entre .cc e .h , coment\u00e1rios de implementa\u00e7\u00e3o devem ir no .cc e de uso, no .h","title":"Classes"},{"location":"Software/Convencoes-de-Codigo/#funcoes_2","text":"Devem ter coment\u00e1rios come\u00e7ando com verbos cujo sujeito impl\u00edcito \u00e9 \"esta fun\u00e7\u00e3o\" N\u00e3o descrevem como ela faz o que faz Devem descrever como a fun\u00e7\u00e3o interage com o mundo externo, descrevendo por exemplo: Entradas e sa\u00eddas Aloca\u00e7\u00e3o de mem\u00f3ria (s\u00f3 se o usu\u00e1rio precisar desalocar) Se algum dos argumentos pode ser NULL ou n\u00e3o Coment\u00e1rios dentro da fun\u00e7\u00e3o devem ser usados com parcim\u00f4nia para descrever peculiaridades de implementa\u00e7\u00e3o (e.g. por que o primeiro caso \u00e9 diferente do caso geral em um loop)","title":"Fun\u00e7\u00f5es"},{"location":"Software/Convencoes-de-Codigo/#variaveis","text":"Atributos de classe S\u00f3 se o tipo e nome da vari\u00e1vel n\u00e3o a descreverem o suficiente Descreva valores padr\u00e3o, como no exemplo: private: // Usado para conferir acesso a tabela. -1 significa // que n\u00e3o sabemos ainda quantas entradas a tabela tem. int num_total_entries_; Vari\u00e1veis globais Todas precisam de um coment\u00e1rio explicando o que s\u00e3o, como s\u00e3o usadas e, caso n\u00e3o esteja claro, porque precisam ser globais // O numero de vezes que passamos por essse teste. const int kNumTestCases = 6;","title":"Vari\u00e1veis"},{"location":"Software/Convencoes-de-Codigo/#implementacao","text":"Blocos de c\u00f3digo complicados devem ter coment\u00e1rios explicat\u00f3rios antes do c\u00f3digo em si Linhas confusas dever ter coment\u00e1rios no final da linha, separados por um Tab do c\u00f3digo Argumentos de fun\u00e7\u00f5es S\u00f3 quando n\u00e3o forem \u00f3bvios pelos nomes ou pela descri\u00e7\u00e3o da fun\u00e7\u00e3o Se o argumento for uma constante, deixe isso expl\u00edcito no nome dela Caso a fun\u00e7\u00e3o receba muitos argumentos, considere criar uma struct ou classe para cont\u00ea-los. Por exemplo: ProductOptions options; options.set_precision_decimals(7); options.set_use_cache(ProductOptions::kDontUseCache); const DecimalNumber product = CalculateProduct(values, options, /*completion_callback=*/nullptr); Em \u00faltimo caso, explique os argumentos com coment\u00e1rios","title":"Implementa\u00e7\u00e3o"},{"location":"Software/Convencoes-de-Codigo/#nomenclatura_2","text":"","title":"Nomenclatura"},{"location":"Software/Convencoes-de-Codigo/#arquivos","text":"Letras todas min\u00fasculas, com _ (preferencialmente) ou - separando palavras Arquivos em C++ deveriam terminar com .cc e headers com .h my_useful_class.cc # Prefer\u00edvel my-useful-class.cc","title":"Arquivos"},{"location":"Software/Convencoes-de-Codigo/#classes-e-tipos-de-variaveis-personalizados","text":"Todas as palavras come\u00e7am com letra mai\u00fascula, sem separa\u00e7\u00e3o entre elas class UrlTable { ... } struct UrlTableProperties { ... }","title":"Classes e Tipos de vari\u00e1veis personalizados"},{"location":"Software/Convencoes-de-Codigo/#variaveis_1","text":"Geral: Todas min\u00fasculas, com _ entre palavras Atributos de classe: mesmo que Geral, mas com _ a mais no final // Nome de uma vari\u00e1vel qualquer std::string table_name; class TableInfo { ... private: std::string table_name_; // OK - underscore no final. static Pool TableInfo * pool_; // OK. };","title":"Vari\u00e1veis"},{"location":"Software/Convencoes-de-Codigo/#constantes_1","text":"Come\u00e7am com k ; palavras subsequentes come\u00e7am com letra mai\u00fascula const int kDaysInAWeek = 7;","title":"Constantes"},{"location":"Software/Convencoes-de-Codigo/#funcoes_3","text":"Todas as palavras come\u00e7am com mai\u00fascula Se for fun\u00e7\u00e3o de acesso ou modificador (i.e. getter ou setter), \u00e9 nomeado como uma vari\u00e1vel OpenFile() // Getter e setter int count() void set_count(int count)","title":"Fun\u00e7\u00f5es"},{"location":"Software/Convencoes-de-Codigo/#namespaces","text":"Tudo min\u00fasculo, com _ separando palavras Deve ser o nome do projeto contido no namespace","title":"namespaces"},{"location":"Software/Convencoes-de-Codigo/#macros-define","text":"Tudo mai\u00fasculo, com _ separando","title":"Macros (#define)"},{"location":"Software/Convencoes-de-Codigo/#especificidades-da-linguagem_1","text":"","title":"Especificidades da Linguagem"},{"location":"Software/Convencoes-de-Codigo/#headers-arquivos-h","text":"Todo c\u00f3digo que n\u00e3o seja extremamente curto ou um teste unit\u00e1rio deve ter um .h Todo .h deve ter um \"header guard\" para impedir inclus\u00e3o m\u00faltipla: // No arquivo foo/src/bar/baz.h #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ N\u00e3o declare fun\u00e7\u00f5es antes de defini-las - use o .h N\u00e3o declare fun\u00e7\u00f5es do tipo static em um arquivo .h Ordem de inclus\u00e3o do #include Headers relacionados Headers de C Headers de C++ Headers de bibliotecas padr\u00e3o Headers de outras bibliotecas Headers definidos no seu projeto Cada grupo deve ser separado por uma linha em branco","title":"Headers (arquivos .h)"},{"location":"Software/Convencoes-de-Codigo/#namespaces_1","text":"Namespaces subdivide the global scope into distinct, named scopes, and so are useful for preventing name collisions in the global scope. O final de namespace s grandes deve ser comentado N\u00e3o declare nada dentro do namespace std N\u00c3O use a diretiva using (e.g. using namespace foo ), porque ela polui o namespace","title":"namespaces"},{"location":"Software/Convencoes-de-Codigo/#misc_1","text":"D\u00ea valor a vari\u00e1veis no momento em que elas forem declaradas Prefira n\u00e3o declarar vari\u00e1veis globais est\u00e1ticas - elas podem causar bugs dif\u00edceis de encontrar depois structs s\u00f3 devem ser usados para armazenamento de objetos passivos, sen\u00e3o devem ser usadas classes Em geral, \u00e9 prefer\u00edvel compor classes (ter um objeto de uma classe como atributo de outra) a usar inheritance S\u00f3 fa\u00e7a uma subclasse de uma superclasse se o objeto da subclasse for \"um tipo de\" objeto da superclasse (e.g. Skyrats \u00e9 \"um tipo de\" Grupo de Extens\u00e3o) Para representar o valor NULL , use nullptr para ponteiros e '\\0' para char","title":"Misc"},{"location":"Software/Convencoes-de-Codigo/#ros","text":"","title":"ROS"},{"location":"Software/Convencoes-de-Codigo/#nomenclatura_3","text":"","title":"Nomenclatura"},{"location":"Software/Convencoes-de-Codigo/#pacotes-topicos-e-servicos","text":"Todas as letras min\u00fasculas, com underscore entre palavras","title":"Pacotes, T\u00f3picos e Servi\u00e7os"},{"location":"Software/Convencoes-de-Codigo/#arquivos_1","text":"Todas as letras min\u00fasculas, com underscore entre palavras","title":"Arquivos"},{"location":"Software/Convencoes-de-Codigo/#misc_2","text":"","title":"Misc"},{"location":"Software/Convencoes-de-Codigo/#saida-do-terminal","text":"Evite print e similares; prefira logs do ROS (e.g. rospy.loginfo() ) e outras fun\u00e7\u00f5es do pacote rosconsole","title":"Sa\u00edda do terminal"},{"location":"Software/Convencoes-de-Codigo/#codigo-nao-mais-mantido","text":"Em headers ( .h ), coloque um coment\u00e1rio Para fun\u00e7\u00f5es, use ROS_DEPRECATED Para classes, use ROS_DEPRECATED no construtor da classe","title":"C\u00f3digo n\u00e3o mais mantido"},{"location":"Software/Convencoes-de-Codigo/#referencias","text":"Google C++ Style Guide PEP 8 -- Style Guide for Python Code PEP 257 -- Docstring Conventions ROS Style Guide","title":"Refer\u00eancias"},{"location":"Software/SIMULACAO_E_GAZEBO/","text":"Gazebo \u00c9 um simulador que usamos aqui na Skyrats para simular as miss\u00f5es que vamos realizar com o drone na vida real. B\u00e1sicos Para instalar ele, as instru\u00e7\u00f5es no seguinte guia j\u00e1 fazem isso: https://github.com/SkyRats/knowledge_base/blob/main/guias/Instalacao.md ; se precisar de mais informa\u00e7\u00f5es sobre sua instala\u00e7\u00e3o: http://gazebosim.org/tutorials?tut=install_ubuntu . O comando abaixo abre o gazebo gazebo op\u00e7\u00f5es de inicializa\u00e7\u00e3o Mas tamb\u00e9m da para abr\u00ed-lo com mais condi\u00e7\u00f5es. Pode abrir diretamente um mundo usando o mesmo comando colocando o caminho para o .world , ou colocando o nome do arquivo estando na pasta world. Por exemplo: gazebo exemplo.world Mais uma explica\u00e7\u00e3o ou informa\u00e7es de uso sobre o comando ou codigo Tamb\u00e9m pode iniciar o gazebo fazendo a simula\u00e7\u00e3o da PX4. Estando na raiz do Firmware d\u00ea o comando: make px4_sitl gazebo E tamb\u00e9m pode inciar o Gazebo junto com o ROS usando o roslaunch, e \u00e9 bom por que da para abrir rosnodes, packages e outras fun\u00e7\u00f5es do ros junto. roslaunch gazebo_ros exemplo.launch No roslaunch pode colocar v\u00e1rios argumentos de incializa\u00e7\u00e3o, clique aqui para ver Tutorial de inicializa\u00e7\u00e3o do gazeb o Os arquivos Models S\u00e3o os modelos que aparecem no mundo, por exemplo: caixas, paredes, cen\u00e1rios, dummies e at\u00e9 o pr\u00f3prio drone. Dentro do gazebo, n\u00f3s temos dois jeitos para criar models e um para edi\u00e7\u00e3o, sendo eles: Na barra cima do painel de simula\u00e7\u00e3o: Esses 3 bot\u00f5es podem criar um cubo, uma bola e um cilindro, todos com propriedades de in\u00e9rcia e colis\u00e3o. Indo em Edit\u2192Building Editor Nessa parte voc\u00ea criar casas e outras constru\u00e7\u00f5es urbanas ou relacionadas, pois facilita bastante. Para usar: Para fazer as paredes, janelas, portas e escadas, voc\u00ea primeiramente seleciona o tipo, cor e textura no painel da esquerda, e \"desenha\" em vista superior na malha branca superior a constru\u00e7\u00e3o a ser feita. Pode tamb\u00e9m ver que tudo \u00e9 dividido em \"levels\", esses s\u00e3o os andares das constru\u00e7\u00f5es. Model Editor: Tem dois caminhos, o primeiro, a partir de nenhum objeto \u00e9: Edit\u2192Model editor, o outro voc\u00ea pode modificar um model existente, selecione ele, no display de simula\u00e7\u00e3o ou no painel esquerdo, depois clique com bot\u00e3o direito \u2192 Edit Model. Ambos v\u00e3o abrir o painel do model editor. Nesse painel, seu objeto selecionado a ser editado fica em laranja, o resto branco(ambos transparentes). No painel a esquerda, na aba insert, voc\u00ea pode fazer algumas coisas, como colocar mais objetos, sendo as \"simple shapes\", ou \"custom shapes\"(para outros models feitos fora do gazebo, vou explicar depois), na aba model, voc\u00ea pode deixar o objeto static, que deixa ele fixado no mundo(isso n\u00e3o afeta a caixa de colis\u00e3o, ele apenas n\u00e3o consegue se mover), pode adicionar plugins, e visualizar links e joints, e dar auto-disable. Joints: No model editor, na barra superior, assim como na imagem acima, voc\u00ea pode criar \"joints\", elas s\u00e3o liga\u00e7\u00f5es entre models, ou entre links de algum model, (links s\u00e3o \"models de models\", ou melhor, partes de um model que teem representa\u00e7\u00e3o pr\u00f3pria, no drone por exemplo, tem o link do frame, dos rotores e p\u00e1s, do LiDar, etc..). Essas liga\u00e7\u00f5es podem ser de v\u00e1rios tipos, cada um com sua caracter\u00edstica, por exemplo, a joint ball \u00e9 uma liga\u00e7\u00e3o com rota\u00e7\u00e3o livre em 6 eixos (x, y, z, roll, pitch, yaw), tem a revolute joint, que permite rota\u00e7\u00e3o em um eixo, o qual voc\u00ea seleciona o eixo no qual vai ser o livre, entre outros... Corda no Gazebo Funcionamento O pacote criado pela Skyrats possui um script capaz de criar um model que simula uma corda no Gazebo. A ideia principal \u00e9 utiliza-la para miss\u00f5es que envolvam o carregamento de objetos, como a Outdoor e Swarm. Como o Gazebo s\u00f3 \u00e9 capaz de simular corpos r\u00edgidos, que n\u00e3o \u00e9 o caso de uma corda, algumas adapta\u00e7\u00f5es precisaram ser feitas. A corda foi criada por meio da uni\u00e3o de v\u00e1rios links, no formato de cilindro, empilhados um acima do outro. Para uni-los, foi utilizado um joint do tipo ball, que permite rota\u00e7\u00e3o em todos os eixos. Assim, a corda \u00e9 formada por um conjunto de corpos r\u00edgidos unidos para dar a impress\u00e3o de que atuam como uma corda. Portanto, o realismo da simula\u00e7\u00e3o \u00e9 diretamente proporcional a quantidade de links. Quanto mais links o modelo tiver para um mesmo tamanho, maior ser\u00e1 a semelhan\u00e7a com uma corda real. Entretanto, um n\u00famero muito alto de links pode afetar o FPS e o real time factor, deixando a simula\u00e7\u00e3o lenta, o que, em alguns casos, chega a ser inutiliz\u00e1vel. Baseado em testes emp\u00edricos, 10 a 20 links para uma corda de um metro costuma ser o ideal para conciliar a performance e o desempenho. Como utilizar Para utilizar o script, basta entrar no diret\u00f3rio scripts do pacote de simula\u00e7\u00e3o e executar Corda.py. O programa ir\u00e1 pedir que voc\u00ea insira a quantidade de links desejados e o tamanho de cada link. Dessa forma, \u00e9 poss\u00edvel controlar o tamanho final da corda realizando uma conta simples: n\u00famero de links vezes tamanho do link. Ap\u00f3s digitar essas entradas, o model da corda estar\u00e1 na pasta models do pacote de simula\u00e7\u00e3o, onde \u00e9 poss\u00edvel utilizar diretamente no Gazebo utilizando a aba insert caso voc\u00ea tenha feito setup.bash. Explicacao do Script O script funciona de uma forma muito simples. Nele, existem duas fun\u00e7\u00f5es: uma para criar um link e outra para colocar uma joint entre dois links. A primeira, quando chamada, ir\u00e1 escrever no arquivo SDF que ser\u00e1 criado todos os atributos necess\u00e1rios (posi\u00e7\u00e3o, massa, momento de in\u00e9rcia e a geometria da caixa de colis\u00e3o e do visual) para criar o SDF de um link cil\u00edndrico. def buildLink(i,tamanho): f.write( link name=\\ link_ + str(i + 1) + \\ \\n ) f.write( pose 0 0 + str(i * tamanho) + /pose \\n ) f.write( inertial \\n ) f.write( mass + str(1 * tamanho) + /mass \\n ) f.write( /inertial \\n ) f.write( collision name=\\ + str(i + 1) + \\ \\n ) f.write( pose 0 0 0 /pose \\n ) f.write( geometry \\n ) f.write( cylinder \\n ) f.write( radius 0.012 /radius \\n ) f.write( length + str(tamanho) + /length \\n ) f.write( /cylinder \\n ) f.write( /geometry \\n ) f.write( /collision \\n ) f.write( visual name=\\ + str(i + 1) + \\ \\n ) f.write( pose 0 0 0 /pose \\n ) f.write( geometry \\n ) f.write( cylinder \\n ) f.write( radius 0.012 /radius \\n ) f.write( length + str(tamanho) + /length \\n ) f.write( /cylinder \\n ) f.write( /geometry \\n ) f.write( /visual \\n ) f.write( /link \\n ) A segunda fun\u00e7\u00e3o \u00e9 respons\u00e1vel por criar uma joint do tipo ball e coloc\u00e1-la na posi\u00e7\u00e3o correta entre dois links. def buildJoint (i, tamanho): f.write( joint name=\\ joint + str(i) + \\ type=\\ ball\\ \\n ) f.write( parent link_ + str(i + 1) + /parent \\n ) f.write( child link_ + str(i) + /child \\n ) f.write( pose 0 0 + str(0.5 * tamanho) + /pose \\n ) f.write( physics \\n ) f.write( /physics \\n ) f.write( /joint \\n ) Por fim, o resto do script \u00e9 respons\u00e1vel por abrir e fechar o arquivo, pedir que o usu\u00e1rio insira o tamanho e a quantidade de links, criar o cabe\u00e7alho do SDF e chamar as fun\u00e7\u00f5es buildLink e buildJoint quantas vezes for necess\u00e1rio. tamanho = float(input( Por favor, insira o tamanho de cada link: )) quantidade = int(input( Por favor, insira a quantidade de links: )) f = open( ../../models/Rope/model.sdf , w ) f.write( ?xml version=\\ 1.0\\ ? ) f.write( sdf version=\\ 1.5\\ \\n ) f.write( model name=\\ Corda\\ \\n ) f.write( self_collide true /self_collide \\n ) for i in range(quantidade): if i == 0: buildLink(i, tamanho) else: buildLink(i, tamanho) buildJoint(i, tamanho) f.write( /model \\n ) f.write( /sdf \\n ) f.close() Como funciona o arquivo model? Ele, basicamente precisa de dois arquivos, um sendo .config , e outro .sdf ou .urdf . Todos funcionando na linguagem XML. O .config tem esse estilo: https://github.com/SkyRats/simulation/blob/master/models/drone_indoor/model.config Onde \u00e9 declarado o nome do model, vers\u00e3o do model, a vers\u00e3o do sdf(1.6), configura\u00e7\u00f5es do autor e descri\u00e7\u00f5es do objeto. O .sdf tem esse estilo: https://github.com/SkyRats/simulation/blob/master/models/drone_indoor/model.sdf Todas as coisas do objeto est\u00e3o nesse arquivo, por exemplo, a mesh, plugins, orienta\u00e7\u00f5es, add de links, add de outros models, joints, materials, e todo o resto poss\u00edvel. Como \u00e9 muito grande as coisas, temos muitos exemplos no nosso reposit\u00f3rio simulation e outras infos sobre o .sdf e seus atributos aqui: http://sdformat.org/spec?ver=1.7 elem=model Worlds Eles s\u00e3o os mundos no gazebo, ou seja, s\u00e3o meio que uma jun\u00e7\u00e3o de models com suas posi\u00e7\u00f5es e configura\u00e7\u00f5es. Eles podem ser configurados direto no gazebo, adicionando coisas no painel de simula\u00e7\u00e3o, sendo pelo painel esquerdo, adicionando modelos na parte \"insert\", e na aba world visualizar as configura\u00e7\u00f5es existentes do mundo, nas aba de cima, pode mudar a configura\u00e7\u00e3o de posi\u00e7\u00e3o, rota\u00e7\u00e3o e escala manualmente dos models, adicionar fontes de luz e mexer a camera. Pelo arquivo .world, da para fazer e adicionar todas as configura\u00e7\u00f5es do mundo, adicionando models, mudar posi\u00e7\u00e3o, rota\u00e7\u00e3o, escala dos mesmos, adicionar plugins de mundo e configurar a GUI, sendo essa infinitamente customiz\u00e1vel ( Vou explicar mais para frente ), como por exemplo, adicionar interfaces com bot\u00f5es, labels, etc, 100% customiz\u00e1veis, que podem fazer qualquer coisa dentro do gazebo, customizar configura\u00e7\u00f5es de ilumina\u00e7\u00e3o, c\u00e2mera e c\u00e9u, entre outros. Temos v\u00e1rios exemplos de .worlds no nosso reposit\u00f3rio simulation, al\u00e9m disso, todas as configura\u00e7\u00f5es para o .world tem aqui: http://sdformat.org/spec?ver=1.7 elem=world Adicionar Meshs de Outros Programas Quais os arquivos? No gazebo, p/ usar meshs externas, os principais tipos de arquivos suportados pelo sdf arquivos .dae, .obj, .stl. Com observa\u00e7\u00e3o de que o .obj e o .stl n\u00e3o suporta materiais/texturas, o .dae \u00e9 melhor n\u00e3o ser usado para transportar texturas pois ele d\u00e1 problemas com sombras fixas nesse transporte de arquivos; em rela\u00e7\u00e3o a desempenho/qualidade, o .dae \u00e9 o mais \"leve\", enquanto o .stl \u00e9 mais \"pesado\", por\u00e9m ambos s\u00e3o bem otimizados; como compara\u00e7\u00e3o o .stl \u00e9 superior na maioria dos casos. Em rela\u00e7\u00e3o as texturas, os tipos de arquivos citado acima n\u00e3o suportam/n\u00e3o suportam bem. O recomendado \u00e9 usar scripts de materiais. O seguinte link explica muito bem como fazer: http://gazebosim.org/tutorials?tut=color_model Como adicionar a mesh? Primeiro cria uma pasta para o model, exemplo: mkdir model; cd model , depois crie os arquivos de config, sdf, e outra pasta para guardar a mesh: mkdir meshes; touch model.config model.sdf Nisso, voc\u00ea coloca a mesh dentro da pasta, configura seus arquivos .sdf e .config. P/ adicionar a mesh no .sdf, s\u00f3 usar um \"include\" dentro da parte da configura\u00e7\u00e3o do link, como exemplo: geometry mesh uri model://model/meshes/mesh.stl /uri /mesh /geometry Lembre-se que deve-se colocar o link para a mesh na colision box e no visual. Programa\u00e7\u00e3o no Gazebo e Plugins Tudo que vimos at\u00e9 agora \u00e9 uma pequena parte do que da para fazer com o gazebo, com plugins, ele fica 100% configur\u00e1vel e ajust\u00e1vel p/ qualquer simula\u00e7\u00e3o. Por ser infinitamente longo, vou ensinar o jeito de como buscar e come\u00e7ar a fazer alguma programa\u00e7\u00e3o/plugin em cima do gazebo e explicar alguns c\u00f3digos. Como funciona? Os plugins do gazebo s\u00e3o em C++ OO e se dividem em 3 tipos principais, os de model, de world ou de GUI. Os de model s\u00e3o, como o nome j\u00e1 diz, inicializados em models, por exemplo, dentro do .sdf: include plugin name = 'wind_gazebo' filename = 'libgazebo_wind_plugin.so' robotNamespace/ linkName base_link /linkName xyzOffset 0 0 0 /xyzOffset windForceMean 10 /windForceMean windForceMax 50 /windForceMax windForceVariance 0 /windForceVariance windDirectionMean 0 1 0 /windDirectionMean windDirectionVariance 0 /windDirectionVariance /plugin uri model://model /uri /include Esse \u00e9 um exemplo de como adicionar um plugin com par\u00e2metros dentro do sdf, no caso o plugin do vento. Como declarar os tipos? Para indicar qual o tipo de plugin, coloque no c\u00f3digo o seguinte comando, sendo para modelo, gui ou world. Coloque ele depois de tudo ou antes de tudo,(em cima ou embaixo dos m\u00e9todos, nunca dentro de nenhum). GZ_REGISTER_GUI_PLUGIN(NomeDaClasse) GZ_REGISTER_MODEL_PLUGIN(NomeDaClasse) GZ_REGISTER_WORLD_PLUGIN(NomeDaClasse) Al\u00e9m disso, os plugins de model possuem duas formas de rodar, uma \u00fanica no Load do model, e outra no OnUpdate(Como se fosse um while(1)... obs: n\u00e3o fa\u00e7am while(1) pfv). Como exemplo temos o m\u00e9todo load do plugin \"GetDropZonePositions\" public: void Load(physics::ModelPtr _parent, sdf::ElementPtr _sdf) { ignition::math::Pose3d dz_clean_pose = _parent- WorldPose(); ignition::math::Vector3 double dzc_p = dz_clean_pose.Pos(); double CP_V[3] = {dzc_p.X(), dzc_p.Y(), dzc_p.Z() }; gzmsg Dropzone pose: \\n\\tX = CP_V[0] \\n\\tY = CP_V[1] \\n\\tZ = CP_V[2] std::endl; } essa fun\u00e7\u00e3o load recebe dois atributos, no caso, o _parent que \u00e9 o pr\u00f3prio model dentro do mundo, e o _sdf que \u00e9 o sdf do model que foi inserido no mundo. No caso, a fun\u00e7\u00e3o dessa fun\u00e7\u00e3o .-. \u00e9 de dar no in\u00edcio do model a posi\u00e7\u00e3o dele no mapa, pois ele foi inserido de forma aleat\u00f3ria usando o modo population do .world. Primeiro, ele cria um objeto de Pose3d, que representa a posi\u00e7\u00e3o do objeto no mundo, e atribui a ele a posi\u00e7\u00e3o do mundo usando o m\u00e9todo WorldPose() do model _parent, depois disso, ele cria um vector3, que \u00e9 um objeto com informa\u00e7\u00f5es sobre posi\u00e7\u00e3o em x,y,z e nele atribui o vector3d de dentro do pose 3d usando o m\u00e9todo Pos(), e nisso ele coloca um vetor de 3 posi\u00e7\u00f5es cada uma das posi\u00e7\u00f5es e depois printa elas com gzmsg, p aparecer destacado no terminal como mensagem do gazebo. E como exemplo do m\u00e9todo OnUpdate temos o do plugin dos Dynamic Obstacles: public: void OnUpdate() { //1 if (!this- toggle_status) { this- model- SetLinearVel(ignition::math::Vector3d(0, 0, 0)); this- model- SetAngularVel(ignition::math::Vector3d(0, 0, 0)); return; } //2 double v; ignition::math::Vector3 double curr_pos = this- link- WorldCoGPose().Pos(); double x_direction = (curr_pos - this- point_0).Dot(this- direction); //3 if (this- goal_point == 1) { if (x_direction = this- distance) { v = this- vel; } else { v = -this- vel; this- goal_point = 0; } } //4 else { if (x_direction = 0) { v = -this- vel; } else { v = this- vel; this- goal_point = 1; } } //5 this- model- SetLinearVel(v*this- direction); this- model- SetAngularVel(ignition::math::Vector3d(0, 0, 0)); } A fun\u00e7\u00e3o est\u00e1 dividida em 5 partes, com os respectivos coment\u00e1rios. Como explicado anteriormente, a fun\u00e7\u00e3o OnUpdate roda a cada atualiza\u00e7\u00e3o do mundo(alguns milissegundos, tudo depende do Real Time Factor), parecido com a ideia do \"void loop()\" do arduino; come\u00e7ando pela parte da fun\u00e7\u00e3o //1 ; com o toggle_status, ele verifica se a movimenta\u00e7\u00e3o dos obst\u00e1culos foi ativada pelo usu\u00e1rio(veremos isso mais p frente em plugins de interface); se ela estiver desativada ele desliga a velocidade dos objetos, linear e angular, e retorna a fun\u00e7\u00e3o. No //2 , ele declara uma vari\u00e1vel double v, que mais para a frente vai receber valores de velocidade, depois ele cria uma vari\u00e1vel do tipo Vector3 em double, que \u00e9 como se fosse um vetor cartesiano, com 3 dimens\u00f5es, por\u00e9m em formato de objeto ao inv\u00e9s de vari\u00e1vel, e esse Vector3, com nome curr_pos, recebe a posi\u00e7\u00e3o do objeto naquele instante, usando o m\u00e9todo do m\u00e9todo do link \"WorldCoGPose().Pos()\" para retornar a posi\u00e7\u00e3o cartesiana do mesmo em Vector3, e em outra vari\u00e1vel double, a x_direction, recebe o produto escalar(.Dot()) entre a dire\u00e7\u00e3o entre o ponto inicial e final do ciclo(aparece em outras partes do c\u00f3digo) e a posi\u00e7\u00e3o atual dele, para assim saber o sentido que ele est\u00e1 percorrendo na trajet\u00f3ria. Em //3 , entra no loop assumido que o objeto est\u00e1 se movendo em dire\u00e7\u00e3o ao ponto 1 da trajet\u00f3ria, e nisso ele verifica se o x_direction, que \u00e9 o produto escalar entre o vetor posi\u00e7\u00e3o do objeto e da dire\u00e7\u00e3o, sendo ele maior que a dist\u00e2ncia se o x_direction coincidir com a sua chegada no ponto 1, se for verdadeiro, ele assume a velocidade positiva ao V, caso contr\u00e1rio, ele assume velocidade negativa e coloca como ponto de destino o ponto 0, assim, no //4 , estando em dire\u00e7\u00e3o do ponto 0(ponto de in\u00edcio), ele verifica se o x_direction \u00e9 maior/igual a zero, se for, ele ainda est\u00e1 em dire\u00e7\u00e3o ao ponto 0, assumindo velocidade negativa, caso contr\u00e1rio ele assume velocidade positiva e toma como dire\u00e7\u00e3o o ponto 1. E no //5 , ele coloca no objeto as velocidades, no caso sendo a angular como 0 fixa, para ele n\u00e3o ter movimenta\u00e7\u00e3o angular. Os plugins de mundo, tem como maior finalidade modificar o mundo em um instante inicial, pois ele s\u00f3 tem a condi\u00e7\u00e3o de ser realizado com o m\u00e9todo \"Load\", tem como o exemplo o m\u00e9todo do \"Attach Rope\" ( https://github.com/SkyRats/simulation/blob/master/plugins/attach_rope.cc ) OBS:: Por mais que os plugins tem os m\u00e9todos Load ou OnUpdate, que permitem que ele rode uma ou mais vezes, ou em Loop, temos o sistema de msgs, que abre mais infinitas op\u00e7\u00f5es... falarei mais para a frente Plugins de GUI Esses plugins permitem que n\u00f3s possamos criar uma nova interface para o gazebo, n\u00e3o s\u00f3 com bot\u00f5es, mas com displays, barras de inser\u00e7\u00f5es, e infinitas possiblidades. Como exemplo n\u00f3s temos do plugin feito em 2020 para facilitar e controlar as simula\u00e7\u00f5es, vou explicar resumidamente o c\u00f3digo: (Obs: vou mostrar o .cpp, mas vale muito a pena ir olhando o .h do c\u00f3digo, vai ajudar muito no entendimento) #include sstream #include gazebo/msgs/msgs.hh #include simulation/skyrats_interface.hh #include ignition/msgs.hh #include simulation/common.h #include fstream #include math.h using namespace gazebo; //1 GZ_REGISTER_GUI_PLUGIN(GUIExampleSpawnWidget) GUIExampleSpawnWidget::GUIExampleSpawnWidget()//1.1 : GUIPlugin() { gzmsg Hello world std::endl; this- counter = 0; this- wind_status = false; this- smoke_status = false; //2 this- setStyleSheet( QFrame { background-color : rgba(95, 139, 250, 255); color : blue; } ); //3 QHBoxLayout *mainLayout = new QHBoxLayout; //4 QFrame *mainFrame = new QFrame(); //5 QVBoxLayout *frameLayout = new QVBoxLayout(); //6 QPushButton *WindButton = new QPushButton(tr( ON/OFF WIND )); connect(WindButton, SIGNAL(clicked()), this, SLOT(WindButton())); QPushButton *SmokeButton = new QPushButton(tr( ON/OFF SMOKE )); connect(SmokeButton, SIGNAL(clicked()), this, SLOT(SmokeButton())); QPushButton *ObstacleButton = new QPushButton(tr( ON/OFF OBSTACLE )); connect(ObstacleButton, SIGNAL(clicked()), this, SLOT(ObstacleButton())); QPushButton *AttachButton = new QPushButton(tr( Rope Attach )); connect(AttachButton, SIGNAL(clicked()), this, SLOT(AttachButton())); //7 QLabel *Skyrats_txt = new QLabel(( Skyrats Simulator v1.0 )); //8 frameLayout- addWidget(Skyrats_txt); frameLayout- addWidget(WindButton); frameLayout- addWidget(SmokeButton); frameLayout- addWidget(ObstacleButton); QLabel *indoor_txt = new QLabel(( Indoor Simulation )); frameLayout- addWidget(indoor_txt); frameLayout- addWidget(AttachButton); QLabel *outdoor_txt = new QLabel(( Outdoor Simulation )); frameLayout- addWidget(outdoor_txt); //9 mainFrame- setLayout(frameLayout); //10 mainLayout- addWidget(mainFrame); //11 frameLayout- setContentsMargins(0, 0, 0, 0); mainLayout- setContentsMargins(0, 0, 0, 0); this- setLayout(mainLayout); this- move(10, 10); this- resize(160, 235); //12 this- node = transport::NodePtr(new transport::Node()); this- node- Init(); this- factoryPub = this- node- Advertise msgs::Factory ( ~/factory ); this- wind_toggle_pub = this- node- Advertise msgs::Int ( ~/wind_toggle ); this- smoke_pub = this- node- Advertise msgs::Scene ( ~/scene ); this- obstacle_toggle_pub = this- node- Advertise msgs::Int ( ~/obstacle_toggle ); this- attach_pub = this- node- Advertise msgs::Int ( ~/rope_attach ); } ///////////////////////////////////////////////// GUIExampleSpawnWidget::~GUIExampleSpawnWidget(){ } //13 void GUIExampleSpawnWidget::WindButton() { msgs::Int msg; this- wind_status = !this- wind_status; msg.set_data(this- wind_status); this- wind_toggle_pub- Publish(msg); gzmsg Wind status: wind_status std::endl; } void GUIExampleSpawnWidget::SmokeButton() { msgs::Scene smk_msg; msgs::Fog* fog = new msgs::Fog; this- smoke_status =! smoke_status; smk_msg.set_name( smoke_toggle ); if (smoke_status == 0){ smk_msg.clear_fog(); fog- set_start(10000.0); fog- set_density(0.0); fog- set_end(30000.0); smk_msg.set_allocated_fog(fog); } if (smoke_status == 1){ fog- set_start(0.1); fog- set_density(300.0); fog- set_end(10.0); smk_msg.set_allocated_fog(fog); } this- smoke_pub- Publish(smk_msg); gzmsg Smoke status: smoke_status std::endl; gzmsg A_Fog status: smk_msg.has_fog() std::endl; } void GUIExampleSpawnWidget::ObstacleButton() { msgs::Int obstacle_msg; this- obstacle_status = !this- obstacle_status; obstacle_msg.set_data(this- obstacle_status); this- obstacle_toggle_pub- Publish(obstacle_msg); gzmsg Obstacle status: obstacle_status std::endl; } void GUIExampleSpawnWidget::AttachButton() { gzmsg Rope attached message sent... std::endl; msgs::Int attach_msg; attach_msg.set_data(1); this- attach_pub- Publish(attach_msg); } O c\u00f3digo ta dividido em 13 partes para facilitar a explica\u00e7\u00e3o: //1 \u2192 \u00c9 registrado o plugin como plugin de interface(obs: isso pode ser declarado no come\u00e7o ou no final, embora na maioria dos plugins seja no final) //1.1 \u2192 Nos plugins de GUI, n\u00e3o existe m\u00e9todo \"Load\", o m\u00e9todo para plugins GUI, com o mesmo funcionamento \u00e9 o construtor. //2 \u2192 Define o estilo do \"fundo\" da interface adicionada ao gazebo, no caso foi utilizado o padr\u00e3o RGB, mas existem outros, tudo isso pode ser visto na documenta\u00e7\u00e3o do QWidgets. //3 \u2192 Cria um layout do QWidget em formato de caixa para guardar a interface //4 \u2192 Cria o frame principal(Obs: o frame \u00e9 a \u00e1rea toda ocupada pela interface, e o layout \u00e9 onde ficar\u00e3o os itens da interface). //5 \u2192 Cria uma layout para o frame. //6 \u2192 Aqui ele cria os bot\u00f5es da interface, criando um ponteiro para eles e chamando um construtor, enviando uma string, sendo essa string a que aparecer\u00e1 em cima do bot\u00e3o em sua implementa\u00e7\u00e3o, ale\u1e3f disso na pr\u00f3xima linha ele liga o bot\u00e3o ao seu m\u00e9todo, declarando seu tipo de funcionamento, como no exemplo, o cliked(), que funciona como um bot\u00e3o de press\u00e3o, que ele realiza uma \u00fanica vez o c\u00f3digo ao ser precionado, necessitando ser pressionado denovo para uma nova execu\u00e7\u00e3o do c\u00f3digo. //7 \u2192 Cria uma Label com uma string, sendo a Label alguma string/texto colocada no layout da interface. //8 \u2192 Ele adiciona todos os objetos criados no layout do frame, usando o m\u00e9todo addWidget(). Obs: Os objetos s\u00e3o colocados na ordem que s\u00e3o escritos no c\u00f3digo, sendo de cima para baixo, como se fosse uma fila. //9 \u2192 Aqui ele coloca o layout principal do frame como sendo o layout criado anteriormente em que foi adicionado todos os widgets. //10 \u2192 Adiciona o outro layout criado como um widget do frame. //11 \u2192 Configura a margem dos dois layouts criados e adicionados, no caso setando as duas como 0 em todas as dimens\u00f5es. //12 \u2192 Aqui ele cria os nodes e publishers que ser\u00e3o usados nos c\u00f3digos dos m\u00e9todos de cada bot\u00e3o, essa parte vou explicar com bastante detalhes mais para a frente. //13 \u2192 Aqui, por final ele cria os m\u00e9todos de cada bot\u00e3o adicionado. Em cada m\u00e9todo, que foi declarado no .h e associado a cada bot\u00e3o no passo 6 \u00e9 descrito o c\u00f3digo que rodar\u00e1 de acordo com o esquema de press\u00e3o do bot\u00e3o, no caso dos \"clicked()\", cada c\u00f3digo desse rodar\u00e1 uma vez a cada vez que o bot\u00e3o for pressionado. Msgs do Gazebo Al\u00e9m de tudo isso que j\u00e1 explicamos, outro jeito de modificar/criar coisas para simula\u00e7\u00e3o no gazebo \u00e9 atrav\u00e9s das msgs, sistema parecido com o ROS, onde cada pequena parte do gazebo se comunica com outras atrav\u00e9s dela, por exemplo temos os bot\u00f5es do nosso plugin Skyzebo 1.0, onde todos os bot\u00f5es criam publishers, e estes enviam mensagens para outras coisas, como por exemplo ligar a fuma\u00e7a, que cria uma msg do tipo \"Fog\", modifica ela para ter as caracter\u00edsticas da fuma\u00e7a, depois \u00e9 criado uma vari\u00e1vel do tipo scene, onde modificamos nela apenas a parte \"Fog\", onde \u00e9 inclu\u00edda a configura\u00e7\u00e3o feita, e ap\u00f3s isso a mensagem \u00e9 publicada para que chegue no t\u00f3pico \"~/scene\" e assim modifique ele aplicando fuma\u00e7a no mundo. O c\u00f3digo do m\u00e9todo desse bot\u00e3o \u00e9 esse, onde tem informa\u00e7\u00f5es explicadas em coment\u00e1rios: void GUIExampleSpawnWidget::SmokeButton() { msgs::Scene smk_msg; msgs::Fog* fog = new msgs::Fog; //Criar as msgs necess\u00e1rias this- smoke_status =! smoke_status; //Inverter o estado passado da fuma\u00e7a, para funcionar como um toggle smk_msg.set_name( smoke_toggle ); //Da o nome da msg da smoke if (smoke_status == 0){ smk_msg.clear_fog(); // Se o estado da fuma\u00e7a for 0 ele limpa a fog, al\u00e9m de inicializar ela bem longe do objeto que possui vis\u00e3o, como camera do drono ou nossa vis\u00e3o fog- set_start(10000.0); fog- set_density(0.0); fog- set_end(30000.0); smk_msg.set_allocated_fog(fog); // Coloca a msg modificada dentro da msg da scene } if (smoke_status == 1){ //Aqui, ele ativa a fuma\u00e7a, al\u00e9m de deixar seu \u00ednicio bem pr\u00f3ximo do objeto com vis\u00e3o. fog- set_start(0.1); fog- set_density(300.0); fog- set_end(10.0); smk_msg.set_allocated_fog(fog); // Coloca a msg modificada dentro da msg da scene } this- smoke_pub- Publish(smk_msg); // publica a mensagem gzmsg Smoke status: smoke_status std::endl; gzmsg A_Fog status: smk_msg.has_fog() std::endl; //printa as informa\u00e7\u00f5es no terminal } Mas para que a msg seja publicada, tamb\u00e9m \u00e9 necess\u00e1rio criar o publisher e associar o node do gazebo a ele. Nesse mesmo publisher, da fuma\u00e7a, o publisher \u00e9 criado assim: Primeiro, dentro da defini\u00e7\u00e3o da classe, voc\u00ea declara o node e cria o publisher: transport::NodePtr node; // Define o node onde vai ser associado o gazebo nele transport::PublisherPtr smoke_pub; // Define o publisher do bot\u00e3o de toggle da fuma\u00e7a Agora, dentro do m\u00e9todo \"Load\", que \u00e9 o que roda no in\u00edcio da simula\u00e7\u00e3o, ou para plugins de GUI, no construtor dele: this- node = transport::NodePtr(new transport::Node()); // Coloca um node dentro da var\u00edavel node criada this- node- Init(); // O m\u00e9todo Init inicia o node this- smoke_pub = this- node- Advertise msgs::Scene ( ~/scene ); // Declara a cria\u00e7\u00e3o do publisher, colocando nele o tipo de msg e tamb\u00e9m o t\u00f3pico Todo o sistema de msgs pode ser visualizado como \"mapa mental\" no site da api do gazebo: http://osrf-distributions.s3.amazonaws.com/gazebo/api/1.3.1/dir_856da1f3c0f82036884d2d586cbc0904.html Al\u00e9m disso, se precisar criar uma msg nova, a explica\u00e7\u00e3o est\u00e1 aqui: http://gazebosim.org/tutorials?tut=custom_messages cat=transport Msgs: Comunica\u00e7\u00e3o entre Plugins/Scripts Al\u00e9m de usar as mgs para comunica\u00e7\u00e3o com o sistema do gazebo diretamente, podemos usar elas para comunica\u00e7\u00e3o entre plugins, funciona no mesmo esquema, a diferen\u00e7a \u00e9 que publicaremos em um t\u00f3pico para outro plugin dar subscribe e callback nele. Vou explicar com exemplos agora, pois com a no\u00e7\u00e3o dada acima j\u00e1 \u00e9 necess\u00e1rio para entender o funcionamento: Como exemplo vou usar a comunica\u00e7\u00e3o do \"rope_attach\", plugin utilizado para conectar as cordas de uma certa carga nos drones. Primeiramente, assim como no exemplo anterior \u00e9 declarado o node e o publisher dentro da declara\u00e7\u00e3o da classe ( Obs: O node s\u00f3 precisa ser criado em uma vez por plugin. ): transport::NodePtr node; transport::PublisherPtr attach_pub; E s\u00e3o iniciados ao iniciar do gazebo: this- node = transport::NodePtr(new transport::Node()); this- node- Init(); this- attach_pub = this- node- Advertise msgs::Int ( ~/rope_attach ); O c\u00f3digo do bot\u00e3o, para publicar a mensagem para esse t\u00f3pico \"~/rope_attach\" ser\u00e1 bem simples, pois ele n\u00e3o tem fun\u00e7\u00e3o de toggle, pois a caixa \u00e9 presa apenas uma vez e n\u00e3o \u00e9 solta ap\u00f3s isso, pois os drones pousam com ela, logo, esse bot\u00e3o vai mandar uma mensagem do tipo \"int\" com o valor booleano de sinal ( 1 ): void GUIExampleSpawnWidget::AttachButton() { gzmsg Rope attached message sent... std::endl; // Printa no terminal a frase msgs::Int attach_msg; // Cria uma msg do tipo int attach_msg.set_data(1); // Associa em seu valor usando o m\u00e9todo set_data o n\u00famero inteiro 1 , que tem como sentido ser um true booleano, apenas para enviar alguma coisa para o callback this- attach_pub- Publish(attach_msg); // Publica a mensagem } Certo, a mensagem foi publicada, agora o outro plugin, script, ou o que for, precisa recebe-la. Ent\u00e3o, precisaremos criar um node, um subscriber e um callback. O node e o subscriber tem a fun\u00e7\u00e3o de estar la para receber a mensagem, e o subscriber inicia o m\u00e9todo de callback sempre que recebe uma mensagem, enviando o objeto de msg recebido como par\u00e2metro para ele. Primeiro, precisamos definir as coisas na classe(obs: isso tudo pode ser feito direto, sem .h e sem declara\u00e7\u00f5es, mas isso vale apenas para os m\u00e9todos), assim, criaremos o subscriber, o node e o namespace(Serve para declara\u00e7\u00f5es do node handle, ver\u00e1 mais para a frente): private: transport::SubscriberPtr attach_sub; //Define o subscriber transport::NodePtr node_handle_; // Define o node_handle_ std::string namespace_; // Cria o namespace public: namespace_(kDefaultNamespace){} // M\u00e9todo do namespace void AttachCallback(ConstIntPtr msg); // Define o m\u00e9todo do callback Agora, com tudo criado, iremos para os m\u00e9todos come\u00e7ar a fazer tudo funcionar, primeiramente iremos no m\u00e9todo que roda ao in\u00edcio do funcionamento do gazebo, onde iremos receberemos o namespace(Caso existente), void attach_rope::Load(physics::WorldPtr _parent, sdf::ElementPtr _sdf) { this- world = _parent; if (_sdf- HasElement( robotNamespace )) //Aqui, ele observa se no sdf possui algum namespace, se tiver, ele assosia tal namespace \u00e0 nossa var\u00edavel namespace_ = _sdf- GetElement( robotNamespace )- Get std::string (); else gzerr [attach_rope] Please specify a robotNamespace.\\n ; //Desnecess\u00e1rio node_handle_ = transport::NodePtr(new transport::Node()); //Cria o node node_handle_- Init(namespace_); // Associa o namespace, vazio ou n\u00e3o ao node attach_sub = node_handle_- Subscribe( ~/rope_attach , attach_rope::AttachCallback, this); //**1** - Explicado abaixo gzmsg aaaaabriuuuu aqui krai: std::endl; // Print de informa\u00e7\u00f5es para debug... hehe } //**1** \u2192 Aqui \u00e9 inicializado o subscriber, tomem bastante cuidado, porque isso aqui da MUITO erro, e erros nada a ver... A partir do node handle, pegaremos um subscriber nele, e associaremos nele o t\u00f3pico que ele vai receber, passaremos o m\u00e9todo de callback como par\u00e2metro, e tamb\u00e9m passaremos a inst\u00e2ncia do plugin tamb\u00e9m com o \"this\". Certo, ap\u00f3s isso temos o subscriber inicializado temos que fazer alguma coisa com a mensagem recebida, no caso, o callback faz isso, ele \u00e9 um m\u00e9todo que \u00e9 chamado pelo subscriber toda vez que alguma mensagem \u00e9 recebida, e essa mensagem \u00e9 passada para esse calback, como exemplo temos o callback desse mesmo plugin, que vou explicar em coment\u00e1rios porque ele \u00e9 bem longo...: void attach_rope::AttachCallback(ConstIntPtr msg){ physics::JointPtr joint_1; physics::JointPtr joint_2; // Criar vari\u00e1veis de joint, que ser\u00e3o as que ligar\u00e3o as cordas nos drones ignition::math::Vector3d z_axis = ignition::math::Vector3d(0,0,1); ignition::math::Vector3d null_axis = ignition::math::Vector3d(0,0,0); ignition::math::Vector4d null_axis4D = ignition::math::Vector4d(1,0,0,0); // Cria algumas var\u00edaveis em vectors, de 3 e 4 dimens\u00f5es physics::ModelPtr corda_0 = this- world- ModelByName( swarm_box::swarm_box::Corda_0 ) physics::ModelPtr iris_0 = this- world- ModelByName( iris_0 ); physics::ModelPtr iris_1 = this- world- ModelByName( iris_1 ); physics::ModelPtr corda_1 = this- world- ModelByName( swarm_box::swarm_box::Corda ); physics::ModelPtr POSREF = this- world- ModelByName( POS_REF ); physics::ModelPtr NEGREF = this- world- ModelByName( NEG_REF ); physics::ModelPtr NULLREF = this- world- ModelByName( NULL_REF ); physics::ModelPtr FARREF = this- world- ModelByName( FAR_REF ); physics::ModelPtr spawn1 = this- world- ModelByName( spawn1 ); physics::ModelPtr spawn2 = this- world- ModelByName( spawn2 ); // Retorna os models necess\u00e1rios presentes no mundo bool f = false; bool t = true; try{//Aqui o ch\u00e3o de sustenta\u00e7\u00e3o \u00e9 removido para que n\u00e3o tenha conflito das colisions box das muitas joints da corda com o pr\u00f3rpio ch\u00e3o spawn1- SetWorldPose(FARREF- WorldPose()); spawn2- SetWorldPose(FARREF- WorldPose()); //Elas s\u00e3o removidas sem dar um delete (\u00e9 poss\u00edvel fazer isso sim! mas da mais problema) mas sim mandando elas para longe... kkkk gzmsg \\tDeleting ground... std::endl; } catch(std::runtime_error *e) { gzmsg GROUND REMOVE FAILED std::endl; } //Usando o esquema de try catch porque da muito erro isso de remover models mandando eles para longe. gzmsg \\tAttaching rope... std::endl; joint_1 = this- world- Physics()- CreateJoint( ball , corda_0); // Cria a joint na corda de tipo ball, que tem rota\u00e7\u00e3o 360\u00ba joint_1- Load(corda_0- GetLink( link_10 ), iris_0- GetLink( base_link ), NULLREF- WorldPose()); // Carrega a joint na sua posi\u00e7\u00e3o e no iris joint_1- Attach(corda_0- GetLink( link_10 ), iris_0- GetLink( base_link )); // Conecta ela no iris joint_1- Init(); // Inicia a joint joint_2 = this- world- Physics()- CreateJoint( ball , corda_1); // Cria a joint na corda de tipo ball, que tem rota\u00e7\u00e3o 360\u00ba joint_2- Load(corda_1- GetLink( link_10 ), iris_1- GetLink( base_link ), NULLREF- WorldPose()); // Carrega a joint na sua posi\u00e7\u00e3o e no iris joint_2- Attach(corda_1- GetLink( link_10 ) ,iris_1- GetLink( base_link )); // Conecta ela no iris joint_2- Init(); // Inicia a joint spawn1- SetWorldPose(NULLREF- WorldPose()); spawn2- SetWorldPose(NULLREF- WorldPose()); // Manda as bases do spawn pra mais longe ainda... N\u00e3o lembro por que fiz isso... Mas suave, se ta a\u00ed tem motivo KKKKKK } No caso, nesse plugin a msg n\u00e3o foi utilizada, pois o \u00fanico objetivo era ligar uma \u00fanica vez a joint caso o bot\u00e3o fosse apertado, por\u00e9m vou dar outro exemplo, dessa vez da msg sendo utilizada, o plugin que receber\u00e1 a msg ser\u00e1 o do vento, que tem um \"toggle\", que funciona recebendo ou 1 ou 0 de uma var\u00edavel int, tudo isso a partir de mais um bot\u00e3o na interface. O c\u00f3digo do callback \u00e9: void GazeboWindPlugin::WindToggleCallback(ConstIntPtr msg) { this- wind_status = msg- data(); // Atribui o n\u00faemro recebido no status do vento, que \u00e9 uma var\u00edavel do objeto do plugin gzmsg Wind toggle std::endl; // Mensagem no terminal } O callback \u00e9 bem curto, pois ele s\u00f3 altera o valor de uma vari\u00e1vel, que \u00e9 utilizada dentro do m\u00e9todo OnUpdate. O plugin do vento funciona assim: Ele pega o model em que ele est\u00e1 \"instalado\" e aplica uma for\u00e7a nele, assim se a vari\u00e1vek \"wind_status\" tiver valor 0, ele n\u00e3o mandar\u00e1 for\u00e7a nenhuma, caso contr\u00e1rio ir\u00e1 mandar a for\u00e7a do vento. O c\u00f3digo \u00e9 um pouquinho longo, vou colocar apenas algumas linhas dele, por\u00e9m ele est\u00e1 dentro do pacote simulation \u2192 https://github.com/SkyRats/simulation/blob/master/plugins/gazebo_wind_plugin.cpp void GazeboWindPlugin::OnUpdate(const common::UpdateInfo _info) { if(this- wind_status == false) return; . . . Continua... Dicas para programar pro gazebo: Improvisa mesmo, coloca umas caixas no mundo p/ dar getPose, colocar umas joint nada a v\u00ea, enche de bot\u00e3o, coloca os plugins p conversar, etc.. .etc... Sempre que for fazer algum c\u00f3digo pro gazebo, todas as informa\u00e7\u00f5es s\u00e3o bem abertas e bem leg\u00edveis de cada classe de cada m\u00e9todo e vari\u00e1vel do gazebo. A dica \u00e9 olhar no gazebo API, l\u00e1 tem TUDO, TUDO MESMO, e tudo bem explicadinho de cada m\u00e9todo... Ent\u00e3o sempre que precisar ver as coisas de uma classe procure: \" class reference gazebo, primeiro link e s\u00f3 vai... Ou pode entrar no site do Gazebo API: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/index.html","title":"Gazebo"},{"location":"Software/SIMULACAO_E_GAZEBO/#gazebo","text":"\u00c9 um simulador que usamos aqui na Skyrats para simular as miss\u00f5es que vamos realizar com o drone na vida real.","title":"Gazebo"},{"location":"Software/SIMULACAO_E_GAZEBO/#basicos","text":"Para instalar ele, as instru\u00e7\u00f5es no seguinte guia j\u00e1 fazem isso: https://github.com/SkyRats/knowledge_base/blob/main/guias/Instalacao.md ; se precisar de mais informa\u00e7\u00f5es sobre sua instala\u00e7\u00e3o: http://gazebosim.org/tutorials?tut=install_ubuntu . O comando abaixo abre o gazebo gazebo op\u00e7\u00f5es de inicializa\u00e7\u00e3o Mas tamb\u00e9m da para abr\u00ed-lo com mais condi\u00e7\u00f5es. Pode abrir diretamente um mundo usando o mesmo comando colocando o caminho para o .world , ou colocando o nome do arquivo estando na pasta world. Por exemplo: gazebo exemplo.world Mais uma explica\u00e7\u00e3o ou informa\u00e7es de uso sobre o comando ou codigo Tamb\u00e9m pode iniciar o gazebo fazendo a simula\u00e7\u00e3o da PX4. Estando na raiz do Firmware d\u00ea o comando: make px4_sitl gazebo E tamb\u00e9m pode inciar o Gazebo junto com o ROS usando o roslaunch, e \u00e9 bom por que da para abrir rosnodes, packages e outras fun\u00e7\u00f5es do ros junto. roslaunch gazebo_ros exemplo.launch No roslaunch pode colocar v\u00e1rios argumentos de incializa\u00e7\u00e3o, clique aqui para ver Tutorial de inicializa\u00e7\u00e3o do gazeb o","title":"B\u00e1sicos"},{"location":"Software/SIMULACAO_E_GAZEBO/#os-arquivos","text":"","title":"Os arquivos"},{"location":"Software/SIMULACAO_E_GAZEBO/#models","text":"S\u00e3o os modelos que aparecem no mundo, por exemplo: caixas, paredes, cen\u00e1rios, dummies e at\u00e9 o pr\u00f3prio drone. Dentro do gazebo, n\u00f3s temos dois jeitos para criar models e um para edi\u00e7\u00e3o, sendo eles: Na barra cima do painel de simula\u00e7\u00e3o: Esses 3 bot\u00f5es podem criar um cubo, uma bola e um cilindro, todos com propriedades de in\u00e9rcia e colis\u00e3o. Indo em Edit\u2192Building Editor Nessa parte voc\u00ea criar casas e outras constru\u00e7\u00f5es urbanas ou relacionadas, pois facilita bastante. Para usar: Para fazer as paredes, janelas, portas e escadas, voc\u00ea primeiramente seleciona o tipo, cor e textura no painel da esquerda, e \"desenha\" em vista superior na malha branca superior a constru\u00e7\u00e3o a ser feita. Pode tamb\u00e9m ver que tudo \u00e9 dividido em \"levels\", esses s\u00e3o os andares das constru\u00e7\u00f5es. Model Editor: Tem dois caminhos, o primeiro, a partir de nenhum objeto \u00e9: Edit\u2192Model editor, o outro voc\u00ea pode modificar um model existente, selecione ele, no display de simula\u00e7\u00e3o ou no painel esquerdo, depois clique com bot\u00e3o direito \u2192 Edit Model. Ambos v\u00e3o abrir o painel do model editor. Nesse painel, seu objeto selecionado a ser editado fica em laranja, o resto branco(ambos transparentes). No painel a esquerda, na aba insert, voc\u00ea pode fazer algumas coisas, como colocar mais objetos, sendo as \"simple shapes\", ou \"custom shapes\"(para outros models feitos fora do gazebo, vou explicar depois), na aba model, voc\u00ea pode deixar o objeto static, que deixa ele fixado no mundo(isso n\u00e3o afeta a caixa de colis\u00e3o, ele apenas n\u00e3o consegue se mover), pode adicionar plugins, e visualizar links e joints, e dar auto-disable.","title":"Models"},{"location":"Software/SIMULACAO_E_GAZEBO/#joints","text":"No model editor, na barra superior, assim como na imagem acima, voc\u00ea pode criar \"joints\", elas s\u00e3o liga\u00e7\u00f5es entre models, ou entre links de algum model, (links s\u00e3o \"models de models\", ou melhor, partes de um model que teem representa\u00e7\u00e3o pr\u00f3pria, no drone por exemplo, tem o link do frame, dos rotores e p\u00e1s, do LiDar, etc..). Essas liga\u00e7\u00f5es podem ser de v\u00e1rios tipos, cada um com sua caracter\u00edstica, por exemplo, a joint ball \u00e9 uma liga\u00e7\u00e3o com rota\u00e7\u00e3o livre em 6 eixos (x, y, z, roll, pitch, yaw), tem a revolute joint, que permite rota\u00e7\u00e3o em um eixo, o qual voc\u00ea seleciona o eixo no qual vai ser o livre, entre outros...","title":"Joints:"},{"location":"Software/SIMULACAO_E_GAZEBO/#corda-no-gazebo","text":"","title":"Corda no Gazebo"},{"location":"Software/SIMULACAO_E_GAZEBO/#funcionamento","text":"O pacote criado pela Skyrats possui um script capaz de criar um model que simula uma corda no Gazebo. A ideia principal \u00e9 utiliza-la para miss\u00f5es que envolvam o carregamento de objetos, como a Outdoor e Swarm. Como o Gazebo s\u00f3 \u00e9 capaz de simular corpos r\u00edgidos, que n\u00e3o \u00e9 o caso de uma corda, algumas adapta\u00e7\u00f5es precisaram ser feitas. A corda foi criada por meio da uni\u00e3o de v\u00e1rios links, no formato de cilindro, empilhados um acima do outro. Para uni-los, foi utilizado um joint do tipo ball, que permite rota\u00e7\u00e3o em todos os eixos. Assim, a corda \u00e9 formada por um conjunto de corpos r\u00edgidos unidos para dar a impress\u00e3o de que atuam como uma corda. Portanto, o realismo da simula\u00e7\u00e3o \u00e9 diretamente proporcional a quantidade de links. Quanto mais links o modelo tiver para um mesmo tamanho, maior ser\u00e1 a semelhan\u00e7a com uma corda real. Entretanto, um n\u00famero muito alto de links pode afetar o FPS e o real time factor, deixando a simula\u00e7\u00e3o lenta, o que, em alguns casos, chega a ser inutiliz\u00e1vel. Baseado em testes emp\u00edricos, 10 a 20 links para uma corda de um metro costuma ser o ideal para conciliar a performance e o desempenho.","title":"Funcionamento"},{"location":"Software/SIMULACAO_E_GAZEBO/#como-utilizar","text":"Para utilizar o script, basta entrar no diret\u00f3rio scripts do pacote de simula\u00e7\u00e3o e executar Corda.py. O programa ir\u00e1 pedir que voc\u00ea insira a quantidade de links desejados e o tamanho de cada link. Dessa forma, \u00e9 poss\u00edvel controlar o tamanho final da corda realizando uma conta simples: n\u00famero de links vezes tamanho do link. Ap\u00f3s digitar essas entradas, o model da corda estar\u00e1 na pasta models do pacote de simula\u00e7\u00e3o, onde \u00e9 poss\u00edvel utilizar diretamente no Gazebo utilizando a aba insert caso voc\u00ea tenha feito setup.bash.","title":"Como utilizar"},{"location":"Software/SIMULACAO_E_GAZEBO/#explicacao-do-script","text":"O script funciona de uma forma muito simples. Nele, existem duas fun\u00e7\u00f5es: uma para criar um link e outra para colocar uma joint entre dois links. A primeira, quando chamada, ir\u00e1 escrever no arquivo SDF que ser\u00e1 criado todos os atributos necess\u00e1rios (posi\u00e7\u00e3o, massa, momento de in\u00e9rcia e a geometria da caixa de colis\u00e3o e do visual) para criar o SDF de um link cil\u00edndrico. def buildLink(i,tamanho): f.write( link name=\\ link_ + str(i + 1) + \\ \\n ) f.write( pose 0 0 + str(i * tamanho) + /pose \\n ) f.write( inertial \\n ) f.write( mass + str(1 * tamanho) + /mass \\n ) f.write( /inertial \\n ) f.write( collision name=\\ + str(i + 1) + \\ \\n ) f.write( pose 0 0 0 /pose \\n ) f.write( geometry \\n ) f.write( cylinder \\n ) f.write( radius 0.012 /radius \\n ) f.write( length + str(tamanho) + /length \\n ) f.write( /cylinder \\n ) f.write( /geometry \\n ) f.write( /collision \\n ) f.write( visual name=\\ + str(i + 1) + \\ \\n ) f.write( pose 0 0 0 /pose \\n ) f.write( geometry \\n ) f.write( cylinder \\n ) f.write( radius 0.012 /radius \\n ) f.write( length + str(tamanho) + /length \\n ) f.write( /cylinder \\n ) f.write( /geometry \\n ) f.write( /visual \\n ) f.write( /link \\n ) A segunda fun\u00e7\u00e3o \u00e9 respons\u00e1vel por criar uma joint do tipo ball e coloc\u00e1-la na posi\u00e7\u00e3o correta entre dois links. def buildJoint (i, tamanho): f.write( joint name=\\ joint + str(i) + \\ type=\\ ball\\ \\n ) f.write( parent link_ + str(i + 1) + /parent \\n ) f.write( child link_ + str(i) + /child \\n ) f.write( pose 0 0 + str(0.5 * tamanho) + /pose \\n ) f.write( physics \\n ) f.write( /physics \\n ) f.write( /joint \\n ) Por fim, o resto do script \u00e9 respons\u00e1vel por abrir e fechar o arquivo, pedir que o usu\u00e1rio insira o tamanho e a quantidade de links, criar o cabe\u00e7alho do SDF e chamar as fun\u00e7\u00f5es buildLink e buildJoint quantas vezes for necess\u00e1rio. tamanho = float(input( Por favor, insira o tamanho de cada link: )) quantidade = int(input( Por favor, insira a quantidade de links: )) f = open( ../../models/Rope/model.sdf , w ) f.write( ?xml version=\\ 1.0\\ ? ) f.write( sdf version=\\ 1.5\\ \\n ) f.write( model name=\\ Corda\\ \\n ) f.write( self_collide true /self_collide \\n ) for i in range(quantidade): if i == 0: buildLink(i, tamanho) else: buildLink(i, tamanho) buildJoint(i, tamanho) f.write( /model \\n ) f.write( /sdf \\n ) f.close()","title":"Explicacao do Script"},{"location":"Software/SIMULACAO_E_GAZEBO/#como-funciona-o-arquivo-model","text":"Ele, basicamente precisa de dois arquivos, um sendo .config , e outro .sdf ou .urdf . Todos funcionando na linguagem XML. O .config tem esse estilo: https://github.com/SkyRats/simulation/blob/master/models/drone_indoor/model.config Onde \u00e9 declarado o nome do model, vers\u00e3o do model, a vers\u00e3o do sdf(1.6), configura\u00e7\u00f5es do autor e descri\u00e7\u00f5es do objeto. O .sdf tem esse estilo: https://github.com/SkyRats/simulation/blob/master/models/drone_indoor/model.sdf Todas as coisas do objeto est\u00e3o nesse arquivo, por exemplo, a mesh, plugins, orienta\u00e7\u00f5es, add de links, add de outros models, joints, materials, e todo o resto poss\u00edvel. Como \u00e9 muito grande as coisas, temos muitos exemplos no nosso reposit\u00f3rio simulation e outras infos sobre o .sdf e seus atributos aqui: http://sdformat.org/spec?ver=1.7 elem=model","title":"Como funciona o arquivo model?"},{"location":"Software/SIMULACAO_E_GAZEBO/#worlds","text":"Eles s\u00e3o os mundos no gazebo, ou seja, s\u00e3o meio que uma jun\u00e7\u00e3o de models com suas posi\u00e7\u00f5es e configura\u00e7\u00f5es. Eles podem ser configurados direto no gazebo, adicionando coisas no painel de simula\u00e7\u00e3o, sendo pelo painel esquerdo, adicionando modelos na parte \"insert\", e na aba world visualizar as configura\u00e7\u00f5es existentes do mundo, nas aba de cima, pode mudar a configura\u00e7\u00e3o de posi\u00e7\u00e3o, rota\u00e7\u00e3o e escala manualmente dos models, adicionar fontes de luz e mexer a camera. Pelo arquivo .world, da para fazer e adicionar todas as configura\u00e7\u00f5es do mundo, adicionando models, mudar posi\u00e7\u00e3o, rota\u00e7\u00e3o, escala dos mesmos, adicionar plugins de mundo e configurar a GUI, sendo essa infinitamente customiz\u00e1vel ( Vou explicar mais para frente ), como por exemplo, adicionar interfaces com bot\u00f5es, labels, etc, 100% customiz\u00e1veis, que podem fazer qualquer coisa dentro do gazebo, customizar configura\u00e7\u00f5es de ilumina\u00e7\u00e3o, c\u00e2mera e c\u00e9u, entre outros. Temos v\u00e1rios exemplos de .worlds no nosso reposit\u00f3rio simulation, al\u00e9m disso, todas as configura\u00e7\u00f5es para o .world tem aqui: http://sdformat.org/spec?ver=1.7 elem=world","title":"Worlds"},{"location":"Software/SIMULACAO_E_GAZEBO/#adicionar-meshs-de-outros-programas","text":"","title":"Adicionar Meshs de Outros Programas"},{"location":"Software/SIMULACAO_E_GAZEBO/#quais-os-arquivos","text":"No gazebo, p/ usar meshs externas, os principais tipos de arquivos suportados pelo sdf arquivos .dae, .obj, .stl. Com observa\u00e7\u00e3o de que o .obj e o .stl n\u00e3o suporta materiais/texturas, o .dae \u00e9 melhor n\u00e3o ser usado para transportar texturas pois ele d\u00e1 problemas com sombras fixas nesse transporte de arquivos; em rela\u00e7\u00e3o a desempenho/qualidade, o .dae \u00e9 o mais \"leve\", enquanto o .stl \u00e9 mais \"pesado\", por\u00e9m ambos s\u00e3o bem otimizados; como compara\u00e7\u00e3o o .stl \u00e9 superior na maioria dos casos. Em rela\u00e7\u00e3o as texturas, os tipos de arquivos citado acima n\u00e3o suportam/n\u00e3o suportam bem. O recomendado \u00e9 usar scripts de materiais. O seguinte link explica muito bem como fazer: http://gazebosim.org/tutorials?tut=color_model","title":"Quais os arquivos?"},{"location":"Software/SIMULACAO_E_GAZEBO/#como-adicionar-a-mesh","text":"Primeiro cria uma pasta para o model, exemplo: mkdir model; cd model , depois crie os arquivos de config, sdf, e outra pasta para guardar a mesh: mkdir meshes; touch model.config model.sdf Nisso, voc\u00ea coloca a mesh dentro da pasta, configura seus arquivos .sdf e .config. P/ adicionar a mesh no .sdf, s\u00f3 usar um \"include\" dentro da parte da configura\u00e7\u00e3o do link, como exemplo: geometry mesh uri model://model/meshes/mesh.stl /uri /mesh /geometry Lembre-se que deve-se colocar o link para a mesh na colision box e no visual.","title":"Como adicionar a mesh?"},{"location":"Software/SIMULACAO_E_GAZEBO/#programacao-no-gazebo-e-plugins","text":"Tudo que vimos at\u00e9 agora \u00e9 uma pequena parte do que da para fazer com o gazebo, com plugins, ele fica 100% configur\u00e1vel e ajust\u00e1vel p/ qualquer simula\u00e7\u00e3o. Por ser infinitamente longo, vou ensinar o jeito de como buscar e come\u00e7ar a fazer alguma programa\u00e7\u00e3o/plugin em cima do gazebo e explicar alguns c\u00f3digos.","title":"Programa\u00e7\u00e3o no Gazebo e Plugins"},{"location":"Software/SIMULACAO_E_GAZEBO/#como-funciona","text":"Os plugins do gazebo s\u00e3o em C++ OO e se dividem em 3 tipos principais, os de model, de world ou de GUI. Os de model s\u00e3o, como o nome j\u00e1 diz, inicializados em models, por exemplo, dentro do .sdf: include plugin name = 'wind_gazebo' filename = 'libgazebo_wind_plugin.so' robotNamespace/ linkName base_link /linkName xyzOffset 0 0 0 /xyzOffset windForceMean 10 /windForceMean windForceMax 50 /windForceMax windForceVariance 0 /windForceVariance windDirectionMean 0 1 0 /windDirectionMean windDirectionVariance 0 /windDirectionVariance /plugin uri model://model /uri /include Esse \u00e9 um exemplo de como adicionar um plugin com par\u00e2metros dentro do sdf, no caso o plugin do vento.","title":"Como funciona?"},{"location":"Software/SIMULACAO_E_GAZEBO/#como-declarar-os-tipos","text":"Para indicar qual o tipo de plugin, coloque no c\u00f3digo o seguinte comando, sendo para modelo, gui ou world. Coloque ele depois de tudo ou antes de tudo,(em cima ou embaixo dos m\u00e9todos, nunca dentro de nenhum). GZ_REGISTER_GUI_PLUGIN(NomeDaClasse) GZ_REGISTER_MODEL_PLUGIN(NomeDaClasse) GZ_REGISTER_WORLD_PLUGIN(NomeDaClasse) Al\u00e9m disso, os plugins de model possuem duas formas de rodar, uma \u00fanica no Load do model, e outra no OnUpdate(Como se fosse um while(1)... obs: n\u00e3o fa\u00e7am while(1) pfv). Como exemplo temos o m\u00e9todo load do plugin \"GetDropZonePositions\" public: void Load(physics::ModelPtr _parent, sdf::ElementPtr _sdf) { ignition::math::Pose3d dz_clean_pose = _parent- WorldPose(); ignition::math::Vector3 double dzc_p = dz_clean_pose.Pos(); double CP_V[3] = {dzc_p.X(), dzc_p.Y(), dzc_p.Z() }; gzmsg Dropzone pose: \\n\\tX = CP_V[0] \\n\\tY = CP_V[1] \\n\\tZ = CP_V[2] std::endl; } essa fun\u00e7\u00e3o load recebe dois atributos, no caso, o _parent que \u00e9 o pr\u00f3prio model dentro do mundo, e o _sdf que \u00e9 o sdf do model que foi inserido no mundo. No caso, a fun\u00e7\u00e3o dessa fun\u00e7\u00e3o .-. \u00e9 de dar no in\u00edcio do model a posi\u00e7\u00e3o dele no mapa, pois ele foi inserido de forma aleat\u00f3ria usando o modo population do .world. Primeiro, ele cria um objeto de Pose3d, que representa a posi\u00e7\u00e3o do objeto no mundo, e atribui a ele a posi\u00e7\u00e3o do mundo usando o m\u00e9todo WorldPose() do model _parent, depois disso, ele cria um vector3, que \u00e9 um objeto com informa\u00e7\u00f5es sobre posi\u00e7\u00e3o em x,y,z e nele atribui o vector3d de dentro do pose 3d usando o m\u00e9todo Pos(), e nisso ele coloca um vetor de 3 posi\u00e7\u00f5es cada uma das posi\u00e7\u00f5es e depois printa elas com gzmsg, p aparecer destacado no terminal como mensagem do gazebo. E como exemplo do m\u00e9todo OnUpdate temos o do plugin dos Dynamic Obstacles: public: void OnUpdate() { //1 if (!this- toggle_status) { this- model- SetLinearVel(ignition::math::Vector3d(0, 0, 0)); this- model- SetAngularVel(ignition::math::Vector3d(0, 0, 0)); return; } //2 double v; ignition::math::Vector3 double curr_pos = this- link- WorldCoGPose().Pos(); double x_direction = (curr_pos - this- point_0).Dot(this- direction); //3 if (this- goal_point == 1) { if (x_direction = this- distance) { v = this- vel; } else { v = -this- vel; this- goal_point = 0; } } //4 else { if (x_direction = 0) { v = -this- vel; } else { v = this- vel; this- goal_point = 1; } } //5 this- model- SetLinearVel(v*this- direction); this- model- SetAngularVel(ignition::math::Vector3d(0, 0, 0)); } A fun\u00e7\u00e3o est\u00e1 dividida em 5 partes, com os respectivos coment\u00e1rios. Como explicado anteriormente, a fun\u00e7\u00e3o OnUpdate roda a cada atualiza\u00e7\u00e3o do mundo(alguns milissegundos, tudo depende do Real Time Factor), parecido com a ideia do \"void loop()\" do arduino; come\u00e7ando pela parte da fun\u00e7\u00e3o //1 ; com o toggle_status, ele verifica se a movimenta\u00e7\u00e3o dos obst\u00e1culos foi ativada pelo usu\u00e1rio(veremos isso mais p frente em plugins de interface); se ela estiver desativada ele desliga a velocidade dos objetos, linear e angular, e retorna a fun\u00e7\u00e3o. No //2 , ele declara uma vari\u00e1vel double v, que mais para a frente vai receber valores de velocidade, depois ele cria uma vari\u00e1vel do tipo Vector3 em double, que \u00e9 como se fosse um vetor cartesiano, com 3 dimens\u00f5es, por\u00e9m em formato de objeto ao inv\u00e9s de vari\u00e1vel, e esse Vector3, com nome curr_pos, recebe a posi\u00e7\u00e3o do objeto naquele instante, usando o m\u00e9todo do m\u00e9todo do link \"WorldCoGPose().Pos()\" para retornar a posi\u00e7\u00e3o cartesiana do mesmo em Vector3, e em outra vari\u00e1vel double, a x_direction, recebe o produto escalar(.Dot()) entre a dire\u00e7\u00e3o entre o ponto inicial e final do ciclo(aparece em outras partes do c\u00f3digo) e a posi\u00e7\u00e3o atual dele, para assim saber o sentido que ele est\u00e1 percorrendo na trajet\u00f3ria. Em //3 , entra no loop assumido que o objeto est\u00e1 se movendo em dire\u00e7\u00e3o ao ponto 1 da trajet\u00f3ria, e nisso ele verifica se o x_direction, que \u00e9 o produto escalar entre o vetor posi\u00e7\u00e3o do objeto e da dire\u00e7\u00e3o, sendo ele maior que a dist\u00e2ncia se o x_direction coincidir com a sua chegada no ponto 1, se for verdadeiro, ele assume a velocidade positiva ao V, caso contr\u00e1rio, ele assume velocidade negativa e coloca como ponto de destino o ponto 0, assim, no //4 , estando em dire\u00e7\u00e3o do ponto 0(ponto de in\u00edcio), ele verifica se o x_direction \u00e9 maior/igual a zero, se for, ele ainda est\u00e1 em dire\u00e7\u00e3o ao ponto 0, assumindo velocidade negativa, caso contr\u00e1rio ele assume velocidade positiva e toma como dire\u00e7\u00e3o o ponto 1. E no //5 , ele coloca no objeto as velocidades, no caso sendo a angular como 0 fixa, para ele n\u00e3o ter movimenta\u00e7\u00e3o angular. Os plugins de mundo, tem como maior finalidade modificar o mundo em um instante inicial, pois ele s\u00f3 tem a condi\u00e7\u00e3o de ser realizado com o m\u00e9todo \"Load\", tem como o exemplo o m\u00e9todo do \"Attach Rope\" ( https://github.com/SkyRats/simulation/blob/master/plugins/attach_rope.cc )","title":"Como declarar os tipos?"},{"location":"Software/SIMULACAO_E_GAZEBO/#obs","text":"Por mais que os plugins tem os m\u00e9todos Load ou OnUpdate, que permitem que ele rode uma ou mais vezes, ou em Loop, temos o sistema de msgs, que abre mais infinitas op\u00e7\u00f5es... falarei mais para a frente","title":"OBS::"},{"location":"Software/SIMULACAO_E_GAZEBO/#plugins-de-gui","text":"Esses plugins permitem que n\u00f3s possamos criar uma nova interface para o gazebo, n\u00e3o s\u00f3 com bot\u00f5es, mas com displays, barras de inser\u00e7\u00f5es, e infinitas possiblidades. Como exemplo n\u00f3s temos do plugin feito em 2020 para facilitar e controlar as simula\u00e7\u00f5es, vou explicar resumidamente o c\u00f3digo: (Obs: vou mostrar o .cpp, mas vale muito a pena ir olhando o .h do c\u00f3digo, vai ajudar muito no entendimento) #include sstream #include gazebo/msgs/msgs.hh #include simulation/skyrats_interface.hh #include ignition/msgs.hh #include simulation/common.h #include fstream #include math.h using namespace gazebo; //1 GZ_REGISTER_GUI_PLUGIN(GUIExampleSpawnWidget) GUIExampleSpawnWidget::GUIExampleSpawnWidget()//1.1 : GUIPlugin() { gzmsg Hello world std::endl; this- counter = 0; this- wind_status = false; this- smoke_status = false; //2 this- setStyleSheet( QFrame { background-color : rgba(95, 139, 250, 255); color : blue; } ); //3 QHBoxLayout *mainLayout = new QHBoxLayout; //4 QFrame *mainFrame = new QFrame(); //5 QVBoxLayout *frameLayout = new QVBoxLayout(); //6 QPushButton *WindButton = new QPushButton(tr( ON/OFF WIND )); connect(WindButton, SIGNAL(clicked()), this, SLOT(WindButton())); QPushButton *SmokeButton = new QPushButton(tr( ON/OFF SMOKE )); connect(SmokeButton, SIGNAL(clicked()), this, SLOT(SmokeButton())); QPushButton *ObstacleButton = new QPushButton(tr( ON/OFF OBSTACLE )); connect(ObstacleButton, SIGNAL(clicked()), this, SLOT(ObstacleButton())); QPushButton *AttachButton = new QPushButton(tr( Rope Attach )); connect(AttachButton, SIGNAL(clicked()), this, SLOT(AttachButton())); //7 QLabel *Skyrats_txt = new QLabel(( Skyrats Simulator v1.0 )); //8 frameLayout- addWidget(Skyrats_txt); frameLayout- addWidget(WindButton); frameLayout- addWidget(SmokeButton); frameLayout- addWidget(ObstacleButton); QLabel *indoor_txt = new QLabel(( Indoor Simulation )); frameLayout- addWidget(indoor_txt); frameLayout- addWidget(AttachButton); QLabel *outdoor_txt = new QLabel(( Outdoor Simulation )); frameLayout- addWidget(outdoor_txt); //9 mainFrame- setLayout(frameLayout); //10 mainLayout- addWidget(mainFrame); //11 frameLayout- setContentsMargins(0, 0, 0, 0); mainLayout- setContentsMargins(0, 0, 0, 0); this- setLayout(mainLayout); this- move(10, 10); this- resize(160, 235); //12 this- node = transport::NodePtr(new transport::Node()); this- node- Init(); this- factoryPub = this- node- Advertise msgs::Factory ( ~/factory ); this- wind_toggle_pub = this- node- Advertise msgs::Int ( ~/wind_toggle ); this- smoke_pub = this- node- Advertise msgs::Scene ( ~/scene ); this- obstacle_toggle_pub = this- node- Advertise msgs::Int ( ~/obstacle_toggle ); this- attach_pub = this- node- Advertise msgs::Int ( ~/rope_attach ); } ///////////////////////////////////////////////// GUIExampleSpawnWidget::~GUIExampleSpawnWidget(){ } //13 void GUIExampleSpawnWidget::WindButton() { msgs::Int msg; this- wind_status = !this- wind_status; msg.set_data(this- wind_status); this- wind_toggle_pub- Publish(msg); gzmsg Wind status: wind_status std::endl; } void GUIExampleSpawnWidget::SmokeButton() { msgs::Scene smk_msg; msgs::Fog* fog = new msgs::Fog; this- smoke_status =! smoke_status; smk_msg.set_name( smoke_toggle ); if (smoke_status == 0){ smk_msg.clear_fog(); fog- set_start(10000.0); fog- set_density(0.0); fog- set_end(30000.0); smk_msg.set_allocated_fog(fog); } if (smoke_status == 1){ fog- set_start(0.1); fog- set_density(300.0); fog- set_end(10.0); smk_msg.set_allocated_fog(fog); } this- smoke_pub- Publish(smk_msg); gzmsg Smoke status: smoke_status std::endl; gzmsg A_Fog status: smk_msg.has_fog() std::endl; } void GUIExampleSpawnWidget::ObstacleButton() { msgs::Int obstacle_msg; this- obstacle_status = !this- obstacle_status; obstacle_msg.set_data(this- obstacle_status); this- obstacle_toggle_pub- Publish(obstacle_msg); gzmsg Obstacle status: obstacle_status std::endl; } void GUIExampleSpawnWidget::AttachButton() { gzmsg Rope attached message sent... std::endl; msgs::Int attach_msg; attach_msg.set_data(1); this- attach_pub- Publish(attach_msg); } O c\u00f3digo ta dividido em 13 partes para facilitar a explica\u00e7\u00e3o: //1 \u2192 \u00c9 registrado o plugin como plugin de interface(obs: isso pode ser declarado no come\u00e7o ou no final, embora na maioria dos plugins seja no final) //1.1 \u2192 Nos plugins de GUI, n\u00e3o existe m\u00e9todo \"Load\", o m\u00e9todo para plugins GUI, com o mesmo funcionamento \u00e9 o construtor. //2 \u2192 Define o estilo do \"fundo\" da interface adicionada ao gazebo, no caso foi utilizado o padr\u00e3o RGB, mas existem outros, tudo isso pode ser visto na documenta\u00e7\u00e3o do QWidgets. //3 \u2192 Cria um layout do QWidget em formato de caixa para guardar a interface //4 \u2192 Cria o frame principal(Obs: o frame \u00e9 a \u00e1rea toda ocupada pela interface, e o layout \u00e9 onde ficar\u00e3o os itens da interface). //5 \u2192 Cria uma layout para o frame. //6 \u2192 Aqui ele cria os bot\u00f5es da interface, criando um ponteiro para eles e chamando um construtor, enviando uma string, sendo essa string a que aparecer\u00e1 em cima do bot\u00e3o em sua implementa\u00e7\u00e3o, ale\u1e3f disso na pr\u00f3xima linha ele liga o bot\u00e3o ao seu m\u00e9todo, declarando seu tipo de funcionamento, como no exemplo, o cliked(), que funciona como um bot\u00e3o de press\u00e3o, que ele realiza uma \u00fanica vez o c\u00f3digo ao ser precionado, necessitando ser pressionado denovo para uma nova execu\u00e7\u00e3o do c\u00f3digo. //7 \u2192 Cria uma Label com uma string, sendo a Label alguma string/texto colocada no layout da interface. //8 \u2192 Ele adiciona todos os objetos criados no layout do frame, usando o m\u00e9todo addWidget(). Obs: Os objetos s\u00e3o colocados na ordem que s\u00e3o escritos no c\u00f3digo, sendo de cima para baixo, como se fosse uma fila. //9 \u2192 Aqui ele coloca o layout principal do frame como sendo o layout criado anteriormente em que foi adicionado todos os widgets. //10 \u2192 Adiciona o outro layout criado como um widget do frame. //11 \u2192 Configura a margem dos dois layouts criados e adicionados, no caso setando as duas como 0 em todas as dimens\u00f5es. //12 \u2192 Aqui ele cria os nodes e publishers que ser\u00e3o usados nos c\u00f3digos dos m\u00e9todos de cada bot\u00e3o, essa parte vou explicar com bastante detalhes mais para a frente. //13 \u2192 Aqui, por final ele cria os m\u00e9todos de cada bot\u00e3o adicionado. Em cada m\u00e9todo, que foi declarado no .h e associado a cada bot\u00e3o no passo 6 \u00e9 descrito o c\u00f3digo que rodar\u00e1 de acordo com o esquema de press\u00e3o do bot\u00e3o, no caso dos \"clicked()\", cada c\u00f3digo desse rodar\u00e1 uma vez a cada vez que o bot\u00e3o for pressionado.","title":"Plugins de GUI"},{"location":"Software/SIMULACAO_E_GAZEBO/#msgs-do-gazebo","text":"Al\u00e9m de tudo isso que j\u00e1 explicamos, outro jeito de modificar/criar coisas para simula\u00e7\u00e3o no gazebo \u00e9 atrav\u00e9s das msgs, sistema parecido com o ROS, onde cada pequena parte do gazebo se comunica com outras atrav\u00e9s dela, por exemplo temos os bot\u00f5es do nosso plugin Skyzebo 1.0, onde todos os bot\u00f5es criam publishers, e estes enviam mensagens para outras coisas, como por exemplo ligar a fuma\u00e7a, que cria uma msg do tipo \"Fog\", modifica ela para ter as caracter\u00edsticas da fuma\u00e7a, depois \u00e9 criado uma vari\u00e1vel do tipo scene, onde modificamos nela apenas a parte \"Fog\", onde \u00e9 inclu\u00edda a configura\u00e7\u00e3o feita, e ap\u00f3s isso a mensagem \u00e9 publicada para que chegue no t\u00f3pico \"~/scene\" e assim modifique ele aplicando fuma\u00e7a no mundo. O c\u00f3digo do m\u00e9todo desse bot\u00e3o \u00e9 esse, onde tem informa\u00e7\u00f5es explicadas em coment\u00e1rios: void GUIExampleSpawnWidget::SmokeButton() { msgs::Scene smk_msg; msgs::Fog* fog = new msgs::Fog; //Criar as msgs necess\u00e1rias this- smoke_status =! smoke_status; //Inverter o estado passado da fuma\u00e7a, para funcionar como um toggle smk_msg.set_name( smoke_toggle ); //Da o nome da msg da smoke if (smoke_status == 0){ smk_msg.clear_fog(); // Se o estado da fuma\u00e7a for 0 ele limpa a fog, al\u00e9m de inicializar ela bem longe do objeto que possui vis\u00e3o, como camera do drono ou nossa vis\u00e3o fog- set_start(10000.0); fog- set_density(0.0); fog- set_end(30000.0); smk_msg.set_allocated_fog(fog); // Coloca a msg modificada dentro da msg da scene } if (smoke_status == 1){ //Aqui, ele ativa a fuma\u00e7a, al\u00e9m de deixar seu \u00ednicio bem pr\u00f3ximo do objeto com vis\u00e3o. fog- set_start(0.1); fog- set_density(300.0); fog- set_end(10.0); smk_msg.set_allocated_fog(fog); // Coloca a msg modificada dentro da msg da scene } this- smoke_pub- Publish(smk_msg); // publica a mensagem gzmsg Smoke status: smoke_status std::endl; gzmsg A_Fog status: smk_msg.has_fog() std::endl; //printa as informa\u00e7\u00f5es no terminal } Mas para que a msg seja publicada, tamb\u00e9m \u00e9 necess\u00e1rio criar o publisher e associar o node do gazebo a ele. Nesse mesmo publisher, da fuma\u00e7a, o publisher \u00e9 criado assim: Primeiro, dentro da defini\u00e7\u00e3o da classe, voc\u00ea declara o node e cria o publisher: transport::NodePtr node; // Define o node onde vai ser associado o gazebo nele transport::PublisherPtr smoke_pub; // Define o publisher do bot\u00e3o de toggle da fuma\u00e7a Agora, dentro do m\u00e9todo \"Load\", que \u00e9 o que roda no in\u00edcio da simula\u00e7\u00e3o, ou para plugins de GUI, no construtor dele: this- node = transport::NodePtr(new transport::Node()); // Coloca um node dentro da var\u00edavel node criada this- node- Init(); // O m\u00e9todo Init inicia o node this- smoke_pub = this- node- Advertise msgs::Scene ( ~/scene ); // Declara a cria\u00e7\u00e3o do publisher, colocando nele o tipo de msg e tamb\u00e9m o t\u00f3pico Todo o sistema de msgs pode ser visualizado como \"mapa mental\" no site da api do gazebo: http://osrf-distributions.s3.amazonaws.com/gazebo/api/1.3.1/dir_856da1f3c0f82036884d2d586cbc0904.html Al\u00e9m disso, se precisar criar uma msg nova, a explica\u00e7\u00e3o est\u00e1 aqui: http://gazebosim.org/tutorials?tut=custom_messages cat=transport","title":"Msgs do Gazebo"},{"location":"Software/SIMULACAO_E_GAZEBO/#msgs-comunicacao-entre-pluginsscripts","text":"Al\u00e9m de usar as mgs para comunica\u00e7\u00e3o com o sistema do gazebo diretamente, podemos usar elas para comunica\u00e7\u00e3o entre plugins, funciona no mesmo esquema, a diferen\u00e7a \u00e9 que publicaremos em um t\u00f3pico para outro plugin dar subscribe e callback nele. Vou explicar com exemplos agora, pois com a no\u00e7\u00e3o dada acima j\u00e1 \u00e9 necess\u00e1rio para entender o funcionamento: Como exemplo vou usar a comunica\u00e7\u00e3o do \"rope_attach\", plugin utilizado para conectar as cordas de uma certa carga nos drones. Primeiramente, assim como no exemplo anterior \u00e9 declarado o node e o publisher dentro da declara\u00e7\u00e3o da classe ( Obs: O node s\u00f3 precisa ser criado em uma vez por plugin. ): transport::NodePtr node; transport::PublisherPtr attach_pub; E s\u00e3o iniciados ao iniciar do gazebo: this- node = transport::NodePtr(new transport::Node()); this- node- Init(); this- attach_pub = this- node- Advertise msgs::Int ( ~/rope_attach ); O c\u00f3digo do bot\u00e3o, para publicar a mensagem para esse t\u00f3pico \"~/rope_attach\" ser\u00e1 bem simples, pois ele n\u00e3o tem fun\u00e7\u00e3o de toggle, pois a caixa \u00e9 presa apenas uma vez e n\u00e3o \u00e9 solta ap\u00f3s isso, pois os drones pousam com ela, logo, esse bot\u00e3o vai mandar uma mensagem do tipo \"int\" com o valor booleano de sinal ( 1 ): void GUIExampleSpawnWidget::AttachButton() { gzmsg Rope attached message sent... std::endl; // Printa no terminal a frase msgs::Int attach_msg; // Cria uma msg do tipo int attach_msg.set_data(1); // Associa em seu valor usando o m\u00e9todo set_data o n\u00famero inteiro 1 , que tem como sentido ser um true booleano, apenas para enviar alguma coisa para o callback this- attach_pub- Publish(attach_msg); // Publica a mensagem } Certo, a mensagem foi publicada, agora o outro plugin, script, ou o que for, precisa recebe-la. Ent\u00e3o, precisaremos criar um node, um subscriber e um callback. O node e o subscriber tem a fun\u00e7\u00e3o de estar la para receber a mensagem, e o subscriber inicia o m\u00e9todo de callback sempre que recebe uma mensagem, enviando o objeto de msg recebido como par\u00e2metro para ele. Primeiro, precisamos definir as coisas na classe(obs: isso tudo pode ser feito direto, sem .h e sem declara\u00e7\u00f5es, mas isso vale apenas para os m\u00e9todos), assim, criaremos o subscriber, o node e o namespace(Serve para declara\u00e7\u00f5es do node handle, ver\u00e1 mais para a frente): private: transport::SubscriberPtr attach_sub; //Define o subscriber transport::NodePtr node_handle_; // Define o node_handle_ std::string namespace_; // Cria o namespace public: namespace_(kDefaultNamespace){} // M\u00e9todo do namespace void AttachCallback(ConstIntPtr msg); // Define o m\u00e9todo do callback Agora, com tudo criado, iremos para os m\u00e9todos come\u00e7ar a fazer tudo funcionar, primeiramente iremos no m\u00e9todo que roda ao in\u00edcio do funcionamento do gazebo, onde iremos receberemos o namespace(Caso existente), void attach_rope::Load(physics::WorldPtr _parent, sdf::ElementPtr _sdf) { this- world = _parent; if (_sdf- HasElement( robotNamespace )) //Aqui, ele observa se no sdf possui algum namespace, se tiver, ele assosia tal namespace \u00e0 nossa var\u00edavel namespace_ = _sdf- GetElement( robotNamespace )- Get std::string (); else gzerr [attach_rope] Please specify a robotNamespace.\\n ; //Desnecess\u00e1rio node_handle_ = transport::NodePtr(new transport::Node()); //Cria o node node_handle_- Init(namespace_); // Associa o namespace, vazio ou n\u00e3o ao node attach_sub = node_handle_- Subscribe( ~/rope_attach , attach_rope::AttachCallback, this); //**1** - Explicado abaixo gzmsg aaaaabriuuuu aqui krai: std::endl; // Print de informa\u00e7\u00f5es para debug... hehe } //**1** \u2192 Aqui \u00e9 inicializado o subscriber, tomem bastante cuidado, porque isso aqui da MUITO erro, e erros nada a ver... A partir do node handle, pegaremos um subscriber nele, e associaremos nele o t\u00f3pico que ele vai receber, passaremos o m\u00e9todo de callback como par\u00e2metro, e tamb\u00e9m passaremos a inst\u00e2ncia do plugin tamb\u00e9m com o \"this\". Certo, ap\u00f3s isso temos o subscriber inicializado temos que fazer alguma coisa com a mensagem recebida, no caso, o callback faz isso, ele \u00e9 um m\u00e9todo que \u00e9 chamado pelo subscriber toda vez que alguma mensagem \u00e9 recebida, e essa mensagem \u00e9 passada para esse calback, como exemplo temos o callback desse mesmo plugin, que vou explicar em coment\u00e1rios porque ele \u00e9 bem longo...: void attach_rope::AttachCallback(ConstIntPtr msg){ physics::JointPtr joint_1; physics::JointPtr joint_2; // Criar vari\u00e1veis de joint, que ser\u00e3o as que ligar\u00e3o as cordas nos drones ignition::math::Vector3d z_axis = ignition::math::Vector3d(0,0,1); ignition::math::Vector3d null_axis = ignition::math::Vector3d(0,0,0); ignition::math::Vector4d null_axis4D = ignition::math::Vector4d(1,0,0,0); // Cria algumas var\u00edaveis em vectors, de 3 e 4 dimens\u00f5es physics::ModelPtr corda_0 = this- world- ModelByName( swarm_box::swarm_box::Corda_0 ) physics::ModelPtr iris_0 = this- world- ModelByName( iris_0 ); physics::ModelPtr iris_1 = this- world- ModelByName( iris_1 ); physics::ModelPtr corda_1 = this- world- ModelByName( swarm_box::swarm_box::Corda ); physics::ModelPtr POSREF = this- world- ModelByName( POS_REF ); physics::ModelPtr NEGREF = this- world- ModelByName( NEG_REF ); physics::ModelPtr NULLREF = this- world- ModelByName( NULL_REF ); physics::ModelPtr FARREF = this- world- ModelByName( FAR_REF ); physics::ModelPtr spawn1 = this- world- ModelByName( spawn1 ); physics::ModelPtr spawn2 = this- world- ModelByName( spawn2 ); // Retorna os models necess\u00e1rios presentes no mundo bool f = false; bool t = true; try{//Aqui o ch\u00e3o de sustenta\u00e7\u00e3o \u00e9 removido para que n\u00e3o tenha conflito das colisions box das muitas joints da corda com o pr\u00f3rpio ch\u00e3o spawn1- SetWorldPose(FARREF- WorldPose()); spawn2- SetWorldPose(FARREF- WorldPose()); //Elas s\u00e3o removidas sem dar um delete (\u00e9 poss\u00edvel fazer isso sim! mas da mais problema) mas sim mandando elas para longe... kkkk gzmsg \\tDeleting ground... std::endl; } catch(std::runtime_error *e) { gzmsg GROUND REMOVE FAILED std::endl; } //Usando o esquema de try catch porque da muito erro isso de remover models mandando eles para longe. gzmsg \\tAttaching rope... std::endl; joint_1 = this- world- Physics()- CreateJoint( ball , corda_0); // Cria a joint na corda de tipo ball, que tem rota\u00e7\u00e3o 360\u00ba joint_1- Load(corda_0- GetLink( link_10 ), iris_0- GetLink( base_link ), NULLREF- WorldPose()); // Carrega a joint na sua posi\u00e7\u00e3o e no iris joint_1- Attach(corda_0- GetLink( link_10 ), iris_0- GetLink( base_link )); // Conecta ela no iris joint_1- Init(); // Inicia a joint joint_2 = this- world- Physics()- CreateJoint( ball , corda_1); // Cria a joint na corda de tipo ball, que tem rota\u00e7\u00e3o 360\u00ba joint_2- Load(corda_1- GetLink( link_10 ), iris_1- GetLink( base_link ), NULLREF- WorldPose()); // Carrega a joint na sua posi\u00e7\u00e3o e no iris joint_2- Attach(corda_1- GetLink( link_10 ) ,iris_1- GetLink( base_link )); // Conecta ela no iris joint_2- Init(); // Inicia a joint spawn1- SetWorldPose(NULLREF- WorldPose()); spawn2- SetWorldPose(NULLREF- WorldPose()); // Manda as bases do spawn pra mais longe ainda... N\u00e3o lembro por que fiz isso... Mas suave, se ta a\u00ed tem motivo KKKKKK } No caso, nesse plugin a msg n\u00e3o foi utilizada, pois o \u00fanico objetivo era ligar uma \u00fanica vez a joint caso o bot\u00e3o fosse apertado, por\u00e9m vou dar outro exemplo, dessa vez da msg sendo utilizada, o plugin que receber\u00e1 a msg ser\u00e1 o do vento, que tem um \"toggle\", que funciona recebendo ou 1 ou 0 de uma var\u00edavel int, tudo isso a partir de mais um bot\u00e3o na interface. O c\u00f3digo do callback \u00e9: void GazeboWindPlugin::WindToggleCallback(ConstIntPtr msg) { this- wind_status = msg- data(); // Atribui o n\u00faemro recebido no status do vento, que \u00e9 uma var\u00edavel do objeto do plugin gzmsg Wind toggle std::endl; // Mensagem no terminal } O callback \u00e9 bem curto, pois ele s\u00f3 altera o valor de uma vari\u00e1vel, que \u00e9 utilizada dentro do m\u00e9todo OnUpdate. O plugin do vento funciona assim: Ele pega o model em que ele est\u00e1 \"instalado\" e aplica uma for\u00e7a nele, assim se a vari\u00e1vek \"wind_status\" tiver valor 0, ele n\u00e3o mandar\u00e1 for\u00e7a nenhuma, caso contr\u00e1rio ir\u00e1 mandar a for\u00e7a do vento. O c\u00f3digo \u00e9 um pouquinho longo, vou colocar apenas algumas linhas dele, por\u00e9m ele est\u00e1 dentro do pacote simulation \u2192 https://github.com/SkyRats/simulation/blob/master/plugins/gazebo_wind_plugin.cpp void GazeboWindPlugin::OnUpdate(const common::UpdateInfo _info) { if(this- wind_status == false) return; . . . Continua...","title":"Msgs: Comunica\u00e7\u00e3o entre Plugins/Scripts"},{"location":"Software/SIMULACAO_E_GAZEBO/#dicas-para-programar-pro-gazebo","text":"Improvisa mesmo, coloca umas caixas no mundo p/ dar getPose, colocar umas joint nada a v\u00ea, enche de bot\u00e3o, coloca os plugins p conversar, etc.. .etc... Sempre que for fazer algum c\u00f3digo pro gazebo, todas as informa\u00e7\u00f5es s\u00e3o bem abertas e bem leg\u00edveis de cada classe de cada m\u00e9todo e vari\u00e1vel do gazebo. A dica \u00e9 olhar no gazebo API, l\u00e1 tem TUDO, TUDO MESMO, e tudo bem explicadinho de cada m\u00e9todo... Ent\u00e3o sempre que precisar ver as coisas de uma classe procure: \" class reference gazebo, primeiro link e s\u00f3 vai... Ou pode entrar no site do Gazebo API: https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/index.html","title":"Dicas para programar pro gazebo:"},{"location":"Workshops/workshop_oo/","text":"Workshop de Programa\u00e7\u00e3o Orientada a Objetos SOMOS O FELIPE E O BENTO E ESTAMOS DE REC NA MATERIA QUE VAMOS DAR PARA VOCES! TEMOS QUE FALAR UM POUCO DE COMO CRIAR UMA MAIN EU ACHO. 1 Paradigmas de Programa\u00e7\u00e3o Paradigma \u00e9 o jeito que a linguagem de programa\u00e7\u00e3o \u00e9 programada, por exemplo, o que voc\u00eas viram no workshop de introdu\u00e7\u00e3o era o paradigama imperativo, onde voc\u00ea manda um \"passo a passo\" para o programa rodar. Agora, o que vamos aprender \u00e9 o paradigma de orienta\u00e7\u00e3o a objetos, em que vai surgir a ideia de classes e objetos, que v\u00e3o ser um n\u00edvel de abstra\u00e7\u00e3o a mais! 2 B\u00e1sicos de C++ Depois do workshop de introdu\u00e7\u00e3o a programa\u00e7\u00e3o voc\u00eas j\u00e1 devem estar brabos em C e python hehe ent\u00e3o aqui temos umas novidades da linguagem C++ (que \u00e9 o C com MAIS MAIS coisas). 2.1 CIN e COUT Essas s\u00e3o as fun\u00e7\u00f5es de impress\u00e3o e leitura do C++! Em C para usar os famosos printf e scanf era necess\u00e1rio dar o #include , agora aqui em C++ para usar o cin (C in) e cout (C out), de #include . A fun\u00e7\u00e3o cin substitui o scanf, com ela podemos pegar dados do nosso teclado e atribui-los a uma vari\u00e1vel. A fun\u00e7\u00e3o cout substitui o printf, com ela podemos imprimir coisas no monitor. Mas pera ai, se o C++ \u00e9 um complemento do C, eu ainda posso usar o printf e scanf?? Sim!! Voc\u00ea pode continuar usando, mas os desenvolvedores criaram essas novas fun\u00e7\u00f5es para serem mais intuitvas, pois nelas o fluxo que o dado percorre \u00e9 mostrado com o \" \". Obs: o \"endl\" (end line) pula uma linha, assim como o \"\\n\". Exemplo: #include iostream using namespace std; int main(){ int minhaIdade; cin minhaIdade; cout Tenho minhaIdade anos! endl; } ./SkyratsIostream.exe 19 //deixar de outra cor eh o fuco Tenho 19 anos! 2.2 String Existe uma biblioteca chamada , com ela voc\u00ea pode representar palavras, frases ou textos, sem ter que usar o tal do Char. A string \u00e9 como se fosse um vetor de caracteres, mas muito mais simples, por exemplo, o programa a seguir: #include iostream #include string using namespace std; int main(){ string frase = A skyrats \u00e9 a melhor equipe da POLI! ; cout frase endl; } Vai ter como sa\u00edda isso: ./SkyratsString.exe A skyrats \u00e9 a melhor equipe da POLI! Obs: Para usar o \"cin e cout\" e as \"strings\" \u00e9 necessa\u00e1rio al\u00e9m da inclus\u00e3o das respectivas bibliotecas o uso do namespaece \"std\" que ser\u00e1 explicado mais pra frente do porqu\u00ea. 3 Conceitos B\u00e1sicos de OO A programa\u00e7\u00e3o orientada a objeto veio para abstrair a realidade! Nela transformamos conceitos da vida real em classes e m\u00e9todos, visando simplificar a implementa\u00e7\u00e3o de algumas coisas. Pra voc\u00ea que ta criando o c\u00f3digo, o trampo ainda \u00e9 grande, mas quem for usar ele vai te agradecer bastante. 3.1 Classe A classe vai ser um molde com diversas caracteristicas. Por exemplo, podemos criar a classe pizza que ter\u00e1 um atributo que indica o seu sabor e outro que indica a quantidade de fatias que ela tem. 3.2 Objetos O objeto \u00e9 a inst\u00e2ncia da classe, ou seja, se usarmos o molde(classe) da pizza, podemos criar diversas pizzas(objeto) e todas elas ter\u00e3o um sabor(atributo) e uma quantidade de fatias(atributo). 3.3 Atributos S\u00e3o as propriedades e estados de uma classe. 3.4 M\u00e9todos S\u00e3o a implementa\u00e7\u00e3o dos servi\u00e7os disponibilizados pelos objetos. Podemos criar para a classe pizza o met\u00f3do \"retirar_fatia()\", agora podemos diminuir o numero de fatias que ela tem por meio de um m\u00e9todo! #include string using namespace std; class Pizza{//Classe public: void retirar_fatia(){ //M\u00e9todo fatias--; } private: string sabor;//Atributo int fatias;//Atributo }; int main(){ Pizza *pizza1;//Cria\u00e7\u00e3o de um objeto Pizza } 3.4 Revis\u00e3o de Ponteiros (\"- \" ou \".\"?, e NULL) O ponteiro \u00e9 uma vari\u00e1vel que guarda um endere\u00e7o de mem\u00f3ria. Por exemplo, um ponteiro para o \"int valor\", ser\u00e1 algo parecido com 0x6453. Para declarar um ponteiro, \u00e9 so colocar um \"*\", desse jeito: int *x; cout x endl; Sa\u00edda: ./Ponteiro.exe 0x32a57c E se quisermos pegar o endere\u00e7o de uma vari\u00e1vel ja existente? Usa o \" \", desse jeito: int x = 10; cout x - x endl; Sa\u00edda: ./Ponteiro2.exe 0x7b65d2 - 10 Mas e agora, e se quisermos ir at\u00e9 a vari\u00e1vel tendo o endere\u00e7o dela? Usaremos tamb\u00e9m o \"*\", desse jeito: int x = 10; int* y = x; cout x - *y endl; Sa\u00edda: ./Ponteiro3.exe 10 - 10 Certo, sabendo disso podemos agora falar como isso tudo de ponteiros interfere em objetos. Um objeto n\u00e3o deixa de ser uma vari\u00e1vel, ele s\u00f3 possui um n\u00edvel de abstra\u00e7\u00e3o a mais. Logo, podemos criar vari\u00e1veis para guardar objetos e pegar seus endere\u00e7os guardando em ponteiros. Tome cuidado, pois ao mesmo tempo que existe coisas para facilitar, de come\u00e7o pode confundir um pouco. Quando vamos criar uma vari\u00e1vel para guardar um objeto, fazemos igual em um INT, por exemplo: cpp Carro celtinha; Desse jeito eu criei uma vari\u00e1vel do tipo carro com o nome celtinha. Mas tem uma coisa, objetos funcionam igual vari\u00e1veis, certo? SIM! Ent\u00e3o saindo de algum escopo ele tamb\u00e9m deixa de existir? SIM! Mas temos como resolver isso, que \u00e9 atrav\u00e9s dos ponteiros! Pois se usarmos continuamente o endere\u00e7o na qual o objeto est\u00e1 ele n\u00e3o vai deixar de existir, e assim podemos trabalhar de uma forma mais ampla com ele, podemos fazer assim: cpp Carro* celtinha; E nesse ponteiro celtinha, vamos guardar o ponteiro que aponta para o objeto, MAS PRESTE ATEN\u00c7\u00c3O!!! Devemos tomar MUITO cuidado em como vamo chamar os m\u00e9todos e atributos. Assim, se temos apenas um objeto(\"Carro celtinha;), chamamos os m\u00e9todos e atributos usando \".\", por exemplo: Carro celtinha = Carro(); //Esse m\u00e9todo \u00e9 um construtor, n\u00e3o se preocupe com ele agora, vamos explicar mais para a frente, apenas saiba que estamos colocando um objeto do tipo Carro na vari\u00e1vel celtinha.buzinar(); // Esse m\u00e9todo retorna no terminal a buzina cout Ano do carro: celtinha.ano endl; // Aqui ele chama o atributo que guarda o ano do carro Sa\u00edda: ./PonteiroCeltinha.exe Biiii Biiiiiii Ano do carro: 2006 Mas agora, se vamos guardar um objeto numa vari\u00e1vel de ponteiro, teremos que chamar os m\u00e9todos e atributos desreferenciando o ponteiro, assim: (*celtinha).buzinar(); Mas em C++ existe uma coisa que facilita muito mais do que ficar desreferenciando o ponteiro toda hora, que \u00e9 so usar uma setinha(\"- \"), assim, podemos chamar o m\u00e9todo desse jeito: celtinha- buzinar(); Exemplo completo: Carro celtinha = Carro(); Carro *ponteiroCeltinha = celtinha; (*ponteiroCeltinha).buzinar(); ponteiroCeltinha- buzinar(); cout Ano do carro: (*ponteiroCeltinha).ano endl; cout Ano do carro: ponteiroCeltinha- ano endl; Sa\u00edda: ./PonteiroCeltinha.exe Biiii Biiiiiii Biiii Biiiiiii Ano do carro: 2006 Ano do carro: 2006 E mais uma \u00faltima coisa! E se quisermos guardar um \"nada\" dentro de um ponteiro, como fazemos? Usamos \"NULL\", assim o ponteiro n\u00e3o estar\u00e1 apontando para nenhum lugar. Carro *ponteiroCeltinha = NULL; ponteiroCeltinha- buzinar(); Sa\u00edda: ./PonteiroCeltinha.exe 4 Encapsulamento Encapsulamento \u00e9 indicar quem tem acesso a um m\u00e9todo ou atributo. 4.1 Private Os atributos e m\u00e9todos \"encapsulados\" dentro do \"private\", s\u00f3 podem ser acessados dentro de m\u00e9todos da pr\u00f3pria classe, nem mesmo de classes filhas, coisas que veremos mais para a frente. 4.2 Public Os atributos e m\u00e9todos \"encapsulados\" dentro do \"public\", podem ser acessados em qualquer lugar, seja na main, em m\u00e9todos de outras classes, etc... 4.3 Protected Os atributos e m\u00e9todos \"encapsulados\" dentro do \"protected\", tem acesso parecido com os encapsulados em \"private\", mas neste, m\u00e9todos e atributos podem ser acessados apenas por ela mesma e por classes filhas (explicadas mais para frente). 4.4 Headers(.h e .hpp) e Sources(.cpp) Uma das grandes vantagens da OO \u00e9 a modulariza\u00e7\u00e3o dos c\u00f3digos, ou seja, cada parte pode ser compilada individualmente. Na pr\u00e1tica isso significa que caso seja feito uma pequena altera\u00e7\u00e3o, s\u00f3 precisamos compilar o c\u00f3digo modificado. Al\u00e9m disso, uma boa pr\u00e1tica \u00e9 criar arquivos diferentes para a defini\u00e7\u00e3o e implementa\u00e7\u00e3o de uma classe. O arquivo de defini\u00e7\u00e3o \u00e9 o Header (.h) e (.hpp). O arquivo de implementa\u00e7\u00e3o \u00e9 o Source (.cpp) Ex: Rel\u00f3gio.h class Relogio{ private: int hora; int minuto; public: int getHora(); int getMinuto(); }; Ex: Rel\u00f3gio.cpp #include Relogio.h int Relogio::getHora(){ return hora; } int Relogio::getMinuto(){ return minuto; } 4.5 \"#ifndef - #endif\" e \"#define\" Quando programamos \u00e9 normal incluirmos varios arquivos no inicio do programa, por\u00e9m no meio desse monte de inclus\u00e3o \u00e9 muito f\u00e1cil acabarmos incluindo o mesmo Header mais de uma vez, pois dentro de classes incluimos outras classes, o que pode ocasionar em um erro de definirmos multiplas vezes a mesma coisa. Para evitar isso, \u00e9 recomendado que sempre que criarmos um Header usarmos o modelo: #ifndef CLASSE_H // Se a classe n\u00e3o estiver definida #define CLASSE_H // Define a classe class Classe{ ... }; #endif //Fim do ifndef 5 Getters e Setter Normalmente na programa\u00e7\u00e3o orientada a objetos, os atributos ser\u00e3o privados por uma quest\u00e3o de seguran\u00e7a, e para outras classes poderem acessa-los usaremos os m\u00e9todos (normalmente p\u00fablicos) getters e setters. Os getter s\u00e3os m\u00e9todos usados para retornar valores de atributos, e os setters para aplicar valores neles. Como \u00e9 bem simples, com o exemplo \u00e9 entend\u00edvel sua utilidade: class Carro{ public: int getCombustivel(){ return combustivel; } void setCombustivel(int valor){ combustivel = valor; } private: int combustivel; }; int main() { Carro Celtinha = Carro(); Celtinha.setCombustivel(30); cout Combustivel: Celtinha.getCombustivel() endl; } Tem como sa\u00edda: ./Celtinha.exe Combust\u00edvel: 30 6 Construtor e Destrutor 6.1 Construtor O construtor \u00e9 a primeira fun\u00e7\u00e3o que \u00e9 executada quando instanciamos um objeto, nela ser\u00e3o iniciadas alguns atributos. Existem duas principais formas de fazer esse processo: Aloca\u00e7\u00e3o Din\u00e2mica: Carro* Celtinha = new Carro(); Ele cria um objeto e atribui seu \"Ponteiro\" dinamicamente, ou seja, a vari\u00e1vel ser\u00e1 mantida mesmo depois do fechamento de escopo, assim, precisa ser desalocada manualmente. Aloca\u00e7\u00e3o Est\u00e1tica: Carro* Celtinha = (Carro()); Aqui a o ponteiro do objeto constru\u00eddo \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel Celtinha, e por ser aloca\u00e7\u00e3o est\u00e1tica, ele n\u00e3o precisa ser destru\u00eddo manualmente, embora seja poss\u00edvel. Quando estamos fazendo a classe podemos escrever um c\u00f3digo para o construtor, e nisso podemos setar valores, criar vari\u00e1veis, dar uns couts, uns cins, e fazer todo o poss\u00edvel para uma fun\u00e7\u00e3o normal, para isso devemos criar um m\u00e9todo com o nome da pr\u00f3pria classe. Obs: Usamos o \"this- \" para nos referirmos a um atributo ou m\u00e9todo do objeto que o chamou. Podemos assim diferenciar coisas com o mesmo nome. class carro{ public: carro(string nome, int ano){ this- nome = nome; //O this- nome se refere ao atributo da classe. this- ano = ano; cout Carro nome do ano ano constru\u00eddo!!! endl; } private: string nome; //Atributo int ano; }; int main() { carro Celtinha = carro( Celta , 2006); } Sa\u00edda: ./ConstrutorDoCeltinha.exe Carro Celta do ano 2006 constru\u00eddo!!! 6.2 Destrutor Se voc\u00ea criou um objeto, ele vai ocupar espa\u00e7o na mem\u00f3ria! Portanto, \u00e9 bom sabermos que podemos destru\u00ed-los, e para isso usamos o comando \"delete\", e esse comando chama o destrutor, uma fun\u00e7\u00e3o bemmm parecida com o construtor, s\u00f3 que com um til atr\u00e1s, \"~NomeDaClasse()\", ele funciona assim: class Comida{ public: Comida(string nome, bool vencida){ this- nome = nome; this- vencida = vencida; } ~Comida(){ if(vencida == true) cout Parab\u00e9ns!, voc\u00ea jogou sua(seu) nome vencida(o) fora! endl; else cout Que feio! voc\u00ea jogou sua(seu) nome nova(o) fora! N\u00e3o desperdice comida : } private: string nome; bool vencida; } int main(){ Comida* cenoura = new Comida( Cenoura , true); Comida* beringela = new Comida( Beringela , false); delete cenoura; delete beringela; } Sa\u00edda: ./Comida.exe Parab\u00e9ns!, voc\u00ea jogou sua(seu) Cenoura vencida(o) fora! Que feio! voc\u00ea jogou sua(seu) Beringela nova(o) fora! N\u00e3o desperdice comida : 7 Vetor de Objetos Em C++, podemos criar vetores de vari\u00e1veis simples, como: INTs, FLOATs... e PONTEIROS! Mas tamb\u00e9m podemos criar um vetor de objetos, guardando em cada posi\u00e7\u00e3o do vetor um ponteiro para esse objeto, e podemos fazer isso de duas formas, est\u00e1ticamente ou dinamicamente: Construcao* predios[tamanho]; //Est\u00e1tica predios[2] = PredioAzul; if(predios[2] == PredioAzul) cout Deu certo! endl; Construcao** predios2 = new Construcao*[tamanho]; predios2[2] = PredioAzul; if(predios2[2] == PredioAzul) cout Deu certo! endl; ./Predios.exe Deu certo! Deu certo! Obs: Para destruir vetores din\u00e2micos, j\u00e1 que ele n\u00e3o deixa de ser um tipo de objeto, voc\u00ea usa o \"delete[] nomeDoVetor;\". 8 Heran\u00e7a e Polimorfismo 8.1 O que \u00e9 um filho Ter filhos... \u00c9 quando voc\u00ea cria uma classe a partir de outra, l\u00f3gico... Lembrem-se: USEM PROTE\u00c7\u00c3O!!! Coloquem os atributos em private... Quando voc\u00ea cria uma classe filha de uma outra, essa classe filha vai herdar todas as caracter\u00edsticas da classe pai, m\u00e9todos, atributos, etc... E al\u00e9m disso voc\u00ea pode colocar mais coisas ainda. \u00c9 mais f\u00e1cil de entender com exemplo: #include string #include iostream using namespace std; class Pessoa { public: Pessoa(string nome, int idade){ this- nome = nome; this- idade = idade; } protected: string nome; int idade; }; class Bento : public Pessoa { //Para indicarmos que a classe \u00e9 Bento \u00e9 filha de Pessoa public: Bento(string nome, int idade, bool Politreco) : Pessoa( Bento , idade) { // Colocamos o : e chamamos o construtor da classe Pai e mandamos nesse construtor os atributos que v\u00e3o para a classe Pai this- Politreco = Politreco; } void bentoPolitreco() { if(Politreco) cout Bento eh politreco endl; else cout Bento nao eh politreco endl; } private: bool Politreco; }; int main() { Bento* bento = new Bento( Bento , 19, true); bento- bentoPolitreco(); } Sa\u00edda: ./Bento.exe Bento eh politreco 8.2 Princ\u00edpio da Substitui\u00e7\u00e3o Se F \u00e9 filha de P, os objetos do tipo F devem se comportar com P caso sejam tratados como P. Ou seja, o filho tem tudo que o pai tem, ent\u00e3o se usarmos o filho tratando ele como pai, deve se comportar como pai. Pensa assim, se voc\u00ea usar o C++ pensando que ta programando em C, ele vai se comportar igualzinho como C! 8.3 Protected Agora que sabemos o que s\u00e3o filhos e pais no meio do OO, podemos entender o encapsulamento Protected, que como explicado antes, funciona igual o \"Private\", mas a diferen\u00e7a \u00e9 que ele pode ser acessado pelos filhos, por exemplo, se eu tenho uma classe Pai, com um atributo Private Nome e um Protected Idade, e uma classe Filha de Pai, se nela chamarmos o atributo Nome, daria erro de compila\u00e7\u00e3o, ja se chamassemos o atributo Idade n\u00e3o, por outro lado, se estivessemos em uma outra classe, sem rela\u00e7\u00e3o com as duas, daria erro de compila\u00e7\u00e3o se chamassemos os dois atributos. class Pai{ //01 private: //02 string Nome; //03 protected: //04 int Idade; //05 }; //06 class Filho{ //07 public: //08 int getIdade{ //09 return idade;//10 } //11 string getNome{ //12 return nome; //13 } //14 }; //15 int main(){ //16 Pai pai = Pai(); //17 cout pai.Nome endl; //18 cout pai.Idade endl;//19 return 0; //20 } Sa\u00edda: gcc -c Protected.c Erro nas linhas 10, 18 e 19 9 Informa\u00e7\u00f5es a mais 9.1 Const \u00c9 possivel criar constantes em C++! Isso pode evitar que durante a implementa\u00e7\u00e3o de um programa alguem mude algo indevidamente. Ex: const float pi = 3.14 ou const Lampada *L1 = new Lampada( Branca ); Dessa forma, caso mudem o valor de PI ou a cor da lampada, um erro de compila\u00e7\u00e3o ser\u00e1 gerado. 9.2 Virtual Quando declaramos um m\u00e9todo como virtual, o c\u00f3digo, no momento da execu\u00e7\u00e3o, decide se o m\u00e9todo chamado vai ser da classe pai, filho, etc... O programa executa o m\u00e9todo com base no tipo espec\u00edfico do objeto! Obs: \u00c9 sempre bom declarar todos os m\u00e9todos como virtuais, e como obriga\u00e7\u00e3o declarar todos os destrutores como virtuais, por que tem casos em que certos destrutores n\u00e3o s\u00e3o chamados. Exemplo: class Passaro { public: virtual void canta() { cout Piuu Piuuu endl;} }; class Arara : public Passaro { public: virtual void canta() { cout Araraaa Araraa endl;} }; int main(){ Passaro* passaro = new Passaro(); Arara* arara = new Arara(); passaro- canta(); arara- canta(); return 0; } Sa\u00edda: ./Passaros.exe Piuu Piuuu Araraaa Araraa 9.3 Namespace e STD Namespaces s\u00e3o jeitos de n\u00e3o se repetirem nomes ao usar vari\u00e1veis, por exemplo, se voc\u00ea cria um namespace para uma class X, toda vez que voc\u00ea for usar alguma coisa dessa classe, voc\u00ea ter\u00e1 que indicar o namespace, por exemplo: namespace UM { class UM { void metodoUm(){} } } ***Em outro arquivo...*** #include UM.h using namespace UM; //Aqui voc\u00ea indica o namespace usado com o using int main(){ metodoUm(); return 0; } ***Em outro arquivo...*** #include UM.h int main(){ UM::metodoUm(); //Aqui voc\u00ea indica o namespace usado com o :: return 0; } Por isso que temos que usar o \"using namespace std;\" pois assim n\u00e3o precisamos escrever em cada COUT ou String o \"std::\" antes, apenas para facilitar.","title":"Programa\u00e7\u00e3o Orientada a Objetos em C++"},{"location":"Workshops/workshop_oo/#workshop-de-programacao-orientada-a-objetos","text":"SOMOS O FELIPE E O BENTO E ESTAMOS DE REC NA MATERIA QUE VAMOS DAR PARA VOCES! TEMOS QUE FALAR UM POUCO DE COMO CRIAR UMA MAIN EU ACHO.","title":"Workshop de Programa\u00e7\u00e3o Orientada a Objetos"},{"location":"Workshops/workshop_oo/#1-paradigmas-de-programacao","text":"Paradigma \u00e9 o jeito que a linguagem de programa\u00e7\u00e3o \u00e9 programada, por exemplo, o que voc\u00eas viram no workshop de introdu\u00e7\u00e3o era o paradigama imperativo, onde voc\u00ea manda um \"passo a passo\" para o programa rodar. Agora, o que vamos aprender \u00e9 o paradigma de orienta\u00e7\u00e3o a objetos, em que vai surgir a ideia de classes e objetos, que v\u00e3o ser um n\u00edvel de abstra\u00e7\u00e3o a mais!","title":"1 Paradigmas de Programa\u00e7\u00e3o"},{"location":"Workshops/workshop_oo/#2-basicos-de-c","text":"Depois do workshop de introdu\u00e7\u00e3o a programa\u00e7\u00e3o voc\u00eas j\u00e1 devem estar brabos em C e python hehe ent\u00e3o aqui temos umas novidades da linguagem C++ (que \u00e9 o C com MAIS MAIS coisas).","title":"2 B\u00e1sicos de C++"},{"location":"Workshops/workshop_oo/#21-cin-e-cout","text":"Essas s\u00e3o as fun\u00e7\u00f5es de impress\u00e3o e leitura do C++! Em C para usar os famosos printf e scanf era necess\u00e1rio dar o #include , agora aqui em C++ para usar o cin (C in) e cout (C out), de #include . A fun\u00e7\u00e3o cin substitui o scanf, com ela podemos pegar dados do nosso teclado e atribui-los a uma vari\u00e1vel. A fun\u00e7\u00e3o cout substitui o printf, com ela podemos imprimir coisas no monitor. Mas pera ai, se o C++ \u00e9 um complemento do C, eu ainda posso usar o printf e scanf?? Sim!! Voc\u00ea pode continuar usando, mas os desenvolvedores criaram essas novas fun\u00e7\u00f5es para serem mais intuitvas, pois nelas o fluxo que o dado percorre \u00e9 mostrado com o \" \". Obs: o \"endl\" (end line) pula uma linha, assim como o \"\\n\". Exemplo: #include iostream using namespace std; int main(){ int minhaIdade; cin minhaIdade; cout Tenho minhaIdade anos! endl; } ./SkyratsIostream.exe 19 //deixar de outra cor eh o fuco Tenho 19 anos!","title":"2.1 CIN e COUT"},{"location":"Workshops/workshop_oo/#22-string","text":"Existe uma biblioteca chamada , com ela voc\u00ea pode representar palavras, frases ou textos, sem ter que usar o tal do Char. A string \u00e9 como se fosse um vetor de caracteres, mas muito mais simples, por exemplo, o programa a seguir: #include iostream #include string using namespace std; int main(){ string frase = A skyrats \u00e9 a melhor equipe da POLI! ; cout frase endl; } Vai ter como sa\u00edda isso: ./SkyratsString.exe A skyrats \u00e9 a melhor equipe da POLI! Obs: Para usar o \"cin e cout\" e as \"strings\" \u00e9 necessa\u00e1rio al\u00e9m da inclus\u00e3o das respectivas bibliotecas o uso do namespaece \"std\" que ser\u00e1 explicado mais pra frente do porqu\u00ea.","title":"2.2 String"},{"location":"Workshops/workshop_oo/#3-conceitos-basicos-de-oo","text":"A programa\u00e7\u00e3o orientada a objeto veio para abstrair a realidade! Nela transformamos conceitos da vida real em classes e m\u00e9todos, visando simplificar a implementa\u00e7\u00e3o de algumas coisas. Pra voc\u00ea que ta criando o c\u00f3digo, o trampo ainda \u00e9 grande, mas quem for usar ele vai te agradecer bastante.","title":"3 Conceitos B\u00e1sicos de OO"},{"location":"Workshops/workshop_oo/#31-classe","text":"A classe vai ser um molde com diversas caracteristicas. Por exemplo, podemos criar a classe pizza que ter\u00e1 um atributo que indica o seu sabor e outro que indica a quantidade de fatias que ela tem.","title":"3.1 Classe"},{"location":"Workshops/workshop_oo/#32-objetos","text":"O objeto \u00e9 a inst\u00e2ncia da classe, ou seja, se usarmos o molde(classe) da pizza, podemos criar diversas pizzas(objeto) e todas elas ter\u00e3o um sabor(atributo) e uma quantidade de fatias(atributo).","title":"3.2 Objetos"},{"location":"Workshops/workshop_oo/#33-atributos","text":"S\u00e3o as propriedades e estados de uma classe.","title":"3.3 Atributos"},{"location":"Workshops/workshop_oo/#34-metodos","text":"S\u00e3o a implementa\u00e7\u00e3o dos servi\u00e7os disponibilizados pelos objetos. Podemos criar para a classe pizza o met\u00f3do \"retirar_fatia()\", agora podemos diminuir o numero de fatias que ela tem por meio de um m\u00e9todo! #include string using namespace std; class Pizza{//Classe public: void retirar_fatia(){ //M\u00e9todo fatias--; } private: string sabor;//Atributo int fatias;//Atributo }; int main(){ Pizza *pizza1;//Cria\u00e7\u00e3o de um objeto Pizza }","title":"3.4 M\u00e9todos"},{"location":"Workshops/workshop_oo/#34-revisao-de-ponteiros-ou-e-null","text":"O ponteiro \u00e9 uma vari\u00e1vel que guarda um endere\u00e7o de mem\u00f3ria. Por exemplo, um ponteiro para o \"int valor\", ser\u00e1 algo parecido com 0x6453. Para declarar um ponteiro, \u00e9 so colocar um \"*\", desse jeito: int *x; cout x endl; Sa\u00edda: ./Ponteiro.exe 0x32a57c E se quisermos pegar o endere\u00e7o de uma vari\u00e1vel ja existente? Usa o \" \", desse jeito: int x = 10; cout x - x endl; Sa\u00edda: ./Ponteiro2.exe 0x7b65d2 - 10 Mas e agora, e se quisermos ir at\u00e9 a vari\u00e1vel tendo o endere\u00e7o dela? Usaremos tamb\u00e9m o \"*\", desse jeito: int x = 10; int* y = x; cout x - *y endl; Sa\u00edda: ./Ponteiro3.exe 10 - 10 Certo, sabendo disso podemos agora falar como isso tudo de ponteiros interfere em objetos. Um objeto n\u00e3o deixa de ser uma vari\u00e1vel, ele s\u00f3 possui um n\u00edvel de abstra\u00e7\u00e3o a mais. Logo, podemos criar vari\u00e1veis para guardar objetos e pegar seus endere\u00e7os guardando em ponteiros. Tome cuidado, pois ao mesmo tempo que existe coisas para facilitar, de come\u00e7o pode confundir um pouco. Quando vamos criar uma vari\u00e1vel para guardar um objeto, fazemos igual em um INT, por exemplo: cpp Carro celtinha; Desse jeito eu criei uma vari\u00e1vel do tipo carro com o nome celtinha. Mas tem uma coisa, objetos funcionam igual vari\u00e1veis, certo? SIM! Ent\u00e3o saindo de algum escopo ele tamb\u00e9m deixa de existir? SIM! Mas temos como resolver isso, que \u00e9 atrav\u00e9s dos ponteiros! Pois se usarmos continuamente o endere\u00e7o na qual o objeto est\u00e1 ele n\u00e3o vai deixar de existir, e assim podemos trabalhar de uma forma mais ampla com ele, podemos fazer assim: cpp Carro* celtinha; E nesse ponteiro celtinha, vamos guardar o ponteiro que aponta para o objeto, MAS PRESTE ATEN\u00c7\u00c3O!!! Devemos tomar MUITO cuidado em como vamo chamar os m\u00e9todos e atributos. Assim, se temos apenas um objeto(\"Carro celtinha;), chamamos os m\u00e9todos e atributos usando \".\", por exemplo: Carro celtinha = Carro(); //Esse m\u00e9todo \u00e9 um construtor, n\u00e3o se preocupe com ele agora, vamos explicar mais para a frente, apenas saiba que estamos colocando um objeto do tipo Carro na vari\u00e1vel celtinha.buzinar(); // Esse m\u00e9todo retorna no terminal a buzina cout Ano do carro: celtinha.ano endl; // Aqui ele chama o atributo que guarda o ano do carro Sa\u00edda: ./PonteiroCeltinha.exe Biiii Biiiiiii Ano do carro: 2006 Mas agora, se vamos guardar um objeto numa vari\u00e1vel de ponteiro, teremos que chamar os m\u00e9todos e atributos desreferenciando o ponteiro, assim: (*celtinha).buzinar(); Mas em C++ existe uma coisa que facilita muito mais do que ficar desreferenciando o ponteiro toda hora, que \u00e9 so usar uma setinha(\"- \"), assim, podemos chamar o m\u00e9todo desse jeito: celtinha- buzinar(); Exemplo completo: Carro celtinha = Carro(); Carro *ponteiroCeltinha = celtinha; (*ponteiroCeltinha).buzinar(); ponteiroCeltinha- buzinar(); cout Ano do carro: (*ponteiroCeltinha).ano endl; cout Ano do carro: ponteiroCeltinha- ano endl; Sa\u00edda: ./PonteiroCeltinha.exe Biiii Biiiiiii Biiii Biiiiiii Ano do carro: 2006 Ano do carro: 2006 E mais uma \u00faltima coisa! E se quisermos guardar um \"nada\" dentro de um ponteiro, como fazemos? Usamos \"NULL\", assim o ponteiro n\u00e3o estar\u00e1 apontando para nenhum lugar. Carro *ponteiroCeltinha = NULL; ponteiroCeltinha- buzinar(); Sa\u00edda: ./PonteiroCeltinha.exe","title":"3.4 Revis\u00e3o de Ponteiros (\"-&gt;\" ou \".\"?, e NULL)"},{"location":"Workshops/workshop_oo/#4-encapsulamento","text":"Encapsulamento \u00e9 indicar quem tem acesso a um m\u00e9todo ou atributo.","title":"4 Encapsulamento"},{"location":"Workshops/workshop_oo/#41-private","text":"Os atributos e m\u00e9todos \"encapsulados\" dentro do \"private\", s\u00f3 podem ser acessados dentro de m\u00e9todos da pr\u00f3pria classe, nem mesmo de classes filhas, coisas que veremos mais para a frente.","title":"4.1 Private"},{"location":"Workshops/workshop_oo/#42-public","text":"Os atributos e m\u00e9todos \"encapsulados\" dentro do \"public\", podem ser acessados em qualquer lugar, seja na main, em m\u00e9todos de outras classes, etc...","title":"4.2 Public"},{"location":"Workshops/workshop_oo/#43-protected","text":"Os atributos e m\u00e9todos \"encapsulados\" dentro do \"protected\", tem acesso parecido com os encapsulados em \"private\", mas neste, m\u00e9todos e atributos podem ser acessados apenas por ela mesma e por classes filhas (explicadas mais para frente).","title":"4.3 Protected"},{"location":"Workshops/workshop_oo/#44-headersh-e-hpp-e-sourcescpp","text":"Uma das grandes vantagens da OO \u00e9 a modulariza\u00e7\u00e3o dos c\u00f3digos, ou seja, cada parte pode ser compilada individualmente. Na pr\u00e1tica isso significa que caso seja feito uma pequena altera\u00e7\u00e3o, s\u00f3 precisamos compilar o c\u00f3digo modificado. Al\u00e9m disso, uma boa pr\u00e1tica \u00e9 criar arquivos diferentes para a defini\u00e7\u00e3o e implementa\u00e7\u00e3o de uma classe. O arquivo de defini\u00e7\u00e3o \u00e9 o Header (.h) e (.hpp). O arquivo de implementa\u00e7\u00e3o \u00e9 o Source (.cpp) Ex: Rel\u00f3gio.h class Relogio{ private: int hora; int minuto; public: int getHora(); int getMinuto(); }; Ex: Rel\u00f3gio.cpp #include Relogio.h int Relogio::getHora(){ return hora; } int Relogio::getMinuto(){ return minuto; }","title":"4.4 Headers(.h e .hpp) e Sources(.cpp)"},{"location":"Workshops/workshop_oo/#45-ifndef-endif-e-define","text":"Quando programamos \u00e9 normal incluirmos varios arquivos no inicio do programa, por\u00e9m no meio desse monte de inclus\u00e3o \u00e9 muito f\u00e1cil acabarmos incluindo o mesmo Header mais de uma vez, pois dentro de classes incluimos outras classes, o que pode ocasionar em um erro de definirmos multiplas vezes a mesma coisa. Para evitar isso, \u00e9 recomendado que sempre que criarmos um Header usarmos o modelo: #ifndef CLASSE_H // Se a classe n\u00e3o estiver definida #define CLASSE_H // Define a classe class Classe{ ... }; #endif //Fim do ifndef","title":"4.5 \"#ifndef - #endif\" e \"#define\""},{"location":"Workshops/workshop_oo/#5-getters-e-setter","text":"Normalmente na programa\u00e7\u00e3o orientada a objetos, os atributos ser\u00e3o privados por uma quest\u00e3o de seguran\u00e7a, e para outras classes poderem acessa-los usaremos os m\u00e9todos (normalmente p\u00fablicos) getters e setters. Os getter s\u00e3os m\u00e9todos usados para retornar valores de atributos, e os setters para aplicar valores neles. Como \u00e9 bem simples, com o exemplo \u00e9 entend\u00edvel sua utilidade: class Carro{ public: int getCombustivel(){ return combustivel; } void setCombustivel(int valor){ combustivel = valor; } private: int combustivel; }; int main() { Carro Celtinha = Carro(); Celtinha.setCombustivel(30); cout Combustivel: Celtinha.getCombustivel() endl; } Tem como sa\u00edda: ./Celtinha.exe Combust\u00edvel: 30","title":"5 Getters e Setter"},{"location":"Workshops/workshop_oo/#6-construtor-e-destrutor","text":"","title":"6 Construtor e Destrutor"},{"location":"Workshops/workshop_oo/#61-construtor","text":"O construtor \u00e9 a primeira fun\u00e7\u00e3o que \u00e9 executada quando instanciamos um objeto, nela ser\u00e3o iniciadas alguns atributos. Existem duas principais formas de fazer esse processo: Aloca\u00e7\u00e3o Din\u00e2mica: Carro* Celtinha = new Carro(); Ele cria um objeto e atribui seu \"Ponteiro\" dinamicamente, ou seja, a vari\u00e1vel ser\u00e1 mantida mesmo depois do fechamento de escopo, assim, precisa ser desalocada manualmente. Aloca\u00e7\u00e3o Est\u00e1tica: Carro* Celtinha = (Carro()); Aqui a o ponteiro do objeto constru\u00eddo \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel Celtinha, e por ser aloca\u00e7\u00e3o est\u00e1tica, ele n\u00e3o precisa ser destru\u00eddo manualmente, embora seja poss\u00edvel. Quando estamos fazendo a classe podemos escrever um c\u00f3digo para o construtor, e nisso podemos setar valores, criar vari\u00e1veis, dar uns couts, uns cins, e fazer todo o poss\u00edvel para uma fun\u00e7\u00e3o normal, para isso devemos criar um m\u00e9todo com o nome da pr\u00f3pria classe. Obs: Usamos o \"this- \" para nos referirmos a um atributo ou m\u00e9todo do objeto que o chamou. Podemos assim diferenciar coisas com o mesmo nome. class carro{ public: carro(string nome, int ano){ this- nome = nome; //O this- nome se refere ao atributo da classe. this- ano = ano; cout Carro nome do ano ano constru\u00eddo!!! endl; } private: string nome; //Atributo int ano; }; int main() { carro Celtinha = carro( Celta , 2006); } Sa\u00edda: ./ConstrutorDoCeltinha.exe Carro Celta do ano 2006 constru\u00eddo!!!","title":"6.1 Construtor"},{"location":"Workshops/workshop_oo/#62-destrutor","text":"Se voc\u00ea criou um objeto, ele vai ocupar espa\u00e7o na mem\u00f3ria! Portanto, \u00e9 bom sabermos que podemos destru\u00ed-los, e para isso usamos o comando \"delete\", e esse comando chama o destrutor, uma fun\u00e7\u00e3o bemmm parecida com o construtor, s\u00f3 que com um til atr\u00e1s, \"~NomeDaClasse()\", ele funciona assim: class Comida{ public: Comida(string nome, bool vencida){ this- nome = nome; this- vencida = vencida; } ~Comida(){ if(vencida == true) cout Parab\u00e9ns!, voc\u00ea jogou sua(seu) nome vencida(o) fora! endl; else cout Que feio! voc\u00ea jogou sua(seu) nome nova(o) fora! N\u00e3o desperdice comida : } private: string nome; bool vencida; } int main(){ Comida* cenoura = new Comida( Cenoura , true); Comida* beringela = new Comida( Beringela , false); delete cenoura; delete beringela; } Sa\u00edda: ./Comida.exe Parab\u00e9ns!, voc\u00ea jogou sua(seu) Cenoura vencida(o) fora! Que feio! voc\u00ea jogou sua(seu) Beringela nova(o) fora! N\u00e3o desperdice comida :","title":"6.2 Destrutor"},{"location":"Workshops/workshop_oo/#7-vetor-de-objetos","text":"Em C++, podemos criar vetores de vari\u00e1veis simples, como: INTs, FLOATs... e PONTEIROS! Mas tamb\u00e9m podemos criar um vetor de objetos, guardando em cada posi\u00e7\u00e3o do vetor um ponteiro para esse objeto, e podemos fazer isso de duas formas, est\u00e1ticamente ou dinamicamente: Construcao* predios[tamanho]; //Est\u00e1tica predios[2] = PredioAzul; if(predios[2] == PredioAzul) cout Deu certo! endl; Construcao** predios2 = new Construcao*[tamanho]; predios2[2] = PredioAzul; if(predios2[2] == PredioAzul) cout Deu certo! endl; ./Predios.exe Deu certo! Deu certo! Obs: Para destruir vetores din\u00e2micos, j\u00e1 que ele n\u00e3o deixa de ser um tipo de objeto, voc\u00ea usa o \"delete[] nomeDoVetor;\".","title":"7 Vetor de Objetos"},{"location":"Workshops/workshop_oo/#8-heranca-e-polimorfismo","text":"","title":"8 Heran\u00e7a e Polimorfismo"},{"location":"Workshops/workshop_oo/#81-o-que-e-um-filho","text":"Ter filhos... \u00c9 quando voc\u00ea cria uma classe a partir de outra, l\u00f3gico... Lembrem-se: USEM PROTE\u00c7\u00c3O!!! Coloquem os atributos em private... Quando voc\u00ea cria uma classe filha de uma outra, essa classe filha vai herdar todas as caracter\u00edsticas da classe pai, m\u00e9todos, atributos, etc... E al\u00e9m disso voc\u00ea pode colocar mais coisas ainda. \u00c9 mais f\u00e1cil de entender com exemplo: #include string #include iostream using namespace std; class Pessoa { public: Pessoa(string nome, int idade){ this- nome = nome; this- idade = idade; } protected: string nome; int idade; }; class Bento : public Pessoa { //Para indicarmos que a classe \u00e9 Bento \u00e9 filha de Pessoa public: Bento(string nome, int idade, bool Politreco) : Pessoa( Bento , idade) { // Colocamos o : e chamamos o construtor da classe Pai e mandamos nesse construtor os atributos que v\u00e3o para a classe Pai this- Politreco = Politreco; } void bentoPolitreco() { if(Politreco) cout Bento eh politreco endl; else cout Bento nao eh politreco endl; } private: bool Politreco; }; int main() { Bento* bento = new Bento( Bento , 19, true); bento- bentoPolitreco(); } Sa\u00edda: ./Bento.exe Bento eh politreco","title":"8.1 O que \u00e9 um filho"},{"location":"Workshops/workshop_oo/#82-principio-da-substituicao","text":"Se F \u00e9 filha de P, os objetos do tipo F devem se comportar com P caso sejam tratados como P. Ou seja, o filho tem tudo que o pai tem, ent\u00e3o se usarmos o filho tratando ele como pai, deve se comportar como pai. Pensa assim, se voc\u00ea usar o C++ pensando que ta programando em C, ele vai se comportar igualzinho como C!","title":"8.2 Princ\u00edpio da Substitui\u00e7\u00e3o"},{"location":"Workshops/workshop_oo/#83-protected","text":"Agora que sabemos o que s\u00e3o filhos e pais no meio do OO, podemos entender o encapsulamento Protected, que como explicado antes, funciona igual o \"Private\", mas a diferen\u00e7a \u00e9 que ele pode ser acessado pelos filhos, por exemplo, se eu tenho uma classe Pai, com um atributo Private Nome e um Protected Idade, e uma classe Filha de Pai, se nela chamarmos o atributo Nome, daria erro de compila\u00e7\u00e3o, ja se chamassemos o atributo Idade n\u00e3o, por outro lado, se estivessemos em uma outra classe, sem rela\u00e7\u00e3o com as duas, daria erro de compila\u00e7\u00e3o se chamassemos os dois atributos. class Pai{ //01 private: //02 string Nome; //03 protected: //04 int Idade; //05 }; //06 class Filho{ //07 public: //08 int getIdade{ //09 return idade;//10 } //11 string getNome{ //12 return nome; //13 } //14 }; //15 int main(){ //16 Pai pai = Pai(); //17 cout pai.Nome endl; //18 cout pai.Idade endl;//19 return 0; //20 } Sa\u00edda: gcc -c Protected.c Erro nas linhas 10, 18 e 19","title":"8.3 Protected"},{"location":"Workshops/workshop_oo/#9-informacoes-a-mais","text":"","title":"9 Informa\u00e7\u00f5es a mais"},{"location":"Workshops/workshop_oo/#91-const","text":"\u00c9 possivel criar constantes em C++! Isso pode evitar que durante a implementa\u00e7\u00e3o de um programa alguem mude algo indevidamente. Ex: const float pi = 3.14 ou const Lampada *L1 = new Lampada( Branca ); Dessa forma, caso mudem o valor de PI ou a cor da lampada, um erro de compila\u00e7\u00e3o ser\u00e1 gerado.","title":"9.1 Const"},{"location":"Workshops/workshop_oo/#92-virtual","text":"Quando declaramos um m\u00e9todo como virtual, o c\u00f3digo, no momento da execu\u00e7\u00e3o, decide se o m\u00e9todo chamado vai ser da classe pai, filho, etc... O programa executa o m\u00e9todo com base no tipo espec\u00edfico do objeto! Obs: \u00c9 sempre bom declarar todos os m\u00e9todos como virtuais, e como obriga\u00e7\u00e3o declarar todos os destrutores como virtuais, por que tem casos em que certos destrutores n\u00e3o s\u00e3o chamados. Exemplo: class Passaro { public: virtual void canta() { cout Piuu Piuuu endl;} }; class Arara : public Passaro { public: virtual void canta() { cout Araraaa Araraa endl;} }; int main(){ Passaro* passaro = new Passaro(); Arara* arara = new Arara(); passaro- canta(); arara- canta(); return 0; } Sa\u00edda: ./Passaros.exe Piuu Piuuu Araraaa Araraa","title":"9.2 Virtual"},{"location":"Workshops/workshop_oo/#93-namespace-e-std","text":"Namespaces s\u00e3o jeitos de n\u00e3o se repetirem nomes ao usar vari\u00e1veis, por exemplo, se voc\u00ea cria um namespace para uma class X, toda vez que voc\u00ea for usar alguma coisa dessa classe, voc\u00ea ter\u00e1 que indicar o namespace, por exemplo: namespace UM { class UM { void metodoUm(){} } } ***Em outro arquivo...*** #include UM.h using namespace UM; //Aqui voc\u00ea indica o namespace usado com o using int main(){ metodoUm(); return 0; } ***Em outro arquivo...*** #include UM.h int main(){ UM::metodoUm(); //Aqui voc\u00ea indica o namespace usado com o :: return 0; } Por isso que temos que usar o \"using namespace std;\" pois assim n\u00e3o precisamos escrever em cada COUT ou String o \"std::\" antes, apenas para facilitar.","title":"9.3 Namespace e STD"}]}