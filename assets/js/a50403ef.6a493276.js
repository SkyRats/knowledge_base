"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[7389],{3905:function(e,o,a){a.d(o,{Zo:function(){return m},kt:function(){return p}});var n=a(7294);function s(e,o,a){return o in e?Object.defineProperty(e,o,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[o]=a,e}function t(e,o){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);o&&(n=n.filter((function(o){return Object.getOwnPropertyDescriptor(e,o).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var o=1;o<arguments.length;o++){var a=null!=arguments[o]?arguments[o]:{};o%2?t(Object(a),!0).forEach((function(o){s(e,o,a[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):t(Object(a)).forEach((function(o){Object.defineProperty(e,o,Object.getOwnPropertyDescriptor(a,o))}))}return e}function r(e,o){if(null==e)return{};var a,n,s=function(e,o){if(null==e)return{};var a,n,s={},t=Object.keys(e);for(n=0;n<t.length;n++)a=t[n],o.indexOf(a)>=0||(s[a]=e[a]);return s}(e,o);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(n=0;n<t.length;n++)a=t[n],o.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var d=n.createContext({}),l=function(e){var o=n.useContext(d),a=o;return e&&(a="function"==typeof e?e(o):i(i({},o),e)),a},m=function(e){var o=l(e.components);return n.createElement(d.Provider,{value:o},e.children)},u={inlineCode:"code",wrapper:function(e){var o=e.children;return n.createElement(n.Fragment,{},o)}},c=n.forwardRef((function(e,o){var a=e.components,s=e.mdxType,t=e.originalType,d=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),c=l(a),p=s,g=c["".concat(d,".").concat(p)]||c[p]||u[p]||t;return a?n.createElement(g,i(i({ref:o},m),{},{components:a})):n.createElement(g,i({ref:o},m))}));function p(e,o){var a=arguments,s=o&&o.mdxType;if("string"==typeof e||s){var t=a.length,i=new Array(t);i[0]=c;var r={};for(var d in o)hasOwnProperty.call(o,d)&&(r[d]=o[d]);r.originalType=e,r.mdxType="string"==typeof e?e:s,i[1]=r;for(var l=2;l<t;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},4379:function(e,o,a){a.r(o),a.d(o,{frontMatter:function(){return r},contentTitle:function(){return d},metadata:function(){return l},toc:function(){return m},default:function(){return c}});var n=a(7462),s=a(3366),t=(a(7294),a(3905)),i=["components"],r={},d="Gazebo",l={unversionedId:"Simuladores/Gazebo",id:"Simuladores/Gazebo",isDocsHomePage:!1,title:"Gazebo",description:"\xc9 um simulador que usamos aqui na Skyrats para simular as miss\xf5es que vamos realizar com o drone na vida real.",source:"@site/../docs/Simuladores/Gazebo.md",sourceDirName:"Simuladores",slug:"/Simuladores/Gazebo",permalink:"/knowledge_base/docs/Simuladores/Gazebo",editUrl:"https://github.com/SkyRats/knowledge_base/tree/main/docs/../docs/Simuladores/Gazebo.md",tags:[],version:"current",frontMatter:{},sidebar:"docssidebar",previous:{title:"Transfer\xeancia de Arquivos",permalink:"/knowledge_base/docs/Linux/TransArqv"},next:{title:"Solucionando erros",permalink:"/knowledge_base/docs/Tello/errors"}},m=[{value:"B\xe1sicos",id:"b\xe1sicos",children:[],level:2},{value:"Os arquivos",id:"os-arquivos",children:[{value:"Models",id:"models",children:[],level:3},{value:"Joints:",id:"joints",children:[],level:3}],level:2},{value:"Corda no Gazebo",id:"corda-no-gazebo",children:[{value:"Funcionamento",id:"funcionamento",children:[],level:3},{value:"Como utilizar",id:"como-utilizar",children:[],level:3},{value:"Explicacao do Script",id:"explicacao-do-script",children:[],level:3}],level:2},{value:"Como funciona o arquivo model?",id:"como-funciona-o-arquivo-model",children:[],level:2},{value:"Worlds",id:"worlds",children:[],level:2},{value:"Adicionar Meshs de Outros Programas",id:"adicionar-meshs-de-outros-programas",children:[{value:"Quais os arquivos?",id:"quais-os-arquivos",children:[],level:3},{value:"Como adicionar a mesh?",id:"como-adicionar-a-mesh",children:[],level:3}],level:2},{value:"Programa\xe7\xe3o no Gazebo e Plugins",id:"programa\xe7\xe3o-no-gazebo-e-plugins",children:[{value:"Como funciona?",id:"como-funciona",children:[],level:3},{value:"Como declarar os tipos?",id:"como-declarar-os-tipos",children:[],level:3},{value:"OBS::",id:"obs",children:[],level:3},{value:"Plugins de GUI",id:"plugins-de-gui",children:[],level:3}],level:2},{value:"Msgs do Gazebo",id:"msgs-do-gazebo",children:[{value:"Msgs: Comunica\xe7\xe3o entre Plugins/Scripts",id:"msgs-comunica\xe7\xe3o-entre-pluginsscripts",children:[],level:3}],level:2},{value:"Dicas para programar pro gazebo:",id:"dicas-para-programar-pro-gazebo",children:[],level:2}],u={toc:m};function c(e){var o=e.components,r=(0,s.Z)(e,i);return(0,t.kt)("wrapper",(0,n.Z)({},u,r,{components:o,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"gazebo"},"Gazebo"),(0,t.kt)("p",null,"\xc9 um simulador que usamos aqui na Skyrats para simular as miss\xf5es que vamos realizar com o drone na vida real."),(0,t.kt)("h2",{id:"b\xe1sicos"},"B\xe1sicos"),(0,t.kt)("p",null,"Para instalar ele, as instru\xe7\xf5es no seguinte guia j\xe1 fazem isso: ",(0,t.kt)("a",{parentName:"p",href:"https://github.com/SkyRats/knowledge_base/blob/main/guias/Instalacao.md"},"https://github.com/SkyRats/knowledge_base/blob/main/guias/Instalacao.md"),"; se precisar de mais informa\xe7\xf5es sobre sua instala\xe7\xe3o: ",(0,t.kt)("a",{parentName:"p",href:"http://gazebosim.org/tutorials?tut=install_ubuntu"},"http://gazebosim.org/tutorials?tut=install_ubuntu"),"."),(0,t.kt)("p",null,"O comando abaixo abre o gazebo"),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"gazebo <op\xe7\xf5es de inicializa\xe7\xe3o>")),(0,t.kt)("p",null,"Mas tamb\xe9m da para abr\xed-lo com mais condi\xe7\xf5es. Pode abrir diretamente um mundo usando o mesmo comando colocando o caminho para o\xa0",(0,t.kt)("inlineCode",{parentName:"p"},".world"),", ou colocando o nome do arquivo estando na pasta world. Por exemplo:\xa0",(0,t.kt)("inlineCode",{parentName:"p"},"gazebo exemplo.world"),"\xa0Mais uma explica\xe7\xe3o ou informa\xe7es de uso sobre o comando ou codigo"),(0,t.kt)("p",null,"Tamb\xe9m pode iniciar o gazebo fazendo a simula\xe7\xe3o da PX4. Estando na raiz do Firmware d\xea o comando:"),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"make px4_sitl gazebo")),(0,t.kt)("p",null,"E tamb\xe9m pode inciar o Gazebo junto com o ROS usando o roslaunch, e \xe9 bom por que da para abrir rosnodes, packages e outras fun\xe7\xf5es do ros junto."),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"roslaunch gazebo_ros <exemplo.launch>")),(0,t.kt)("p",null,"No roslaunch pode colocar v\xe1rios argumentos de incializa\xe7\xe3o,\xa0",(0,t.kt)("a",{parentName:"p",href:"http://gazebosim.org/tutorials/?tut=ros_roslaunch"},"clique aqui para ver")),(0,t.kt)("p",null,(0,t.kt)("a",{parentName:"p",href:"http://gazebosim.org/tutorials?tut=quick_start"},"Tutorial de inicializa\xe7\xe3o do gazeb"),"o"),(0,t.kt)("h2",{id:"os-arquivos"},"Os arquivos"),(0,t.kt)("h3",{id:"models"},"Models"),(0,t.kt)("p",null,"S\xe3o os modelos que aparecem no mundo, por exemplo: caixas, paredes, cen\xe1rios, dummies e at\xe9 o pr\xf3prio drone."),(0,t.kt)("p",null,"Dentro do gazebo, n\xf3s temos dois jeitos para criar models e um para edi\xe7\xe3o, sendo eles:"),(0,t.kt)("p",null,"Na barra cima do painel de simula\xe7\xe3o:"),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"imgs/Untitled.png",src:a(675).Z})),(0,t.kt)("p",null,"Esses 3 bot\xf5es podem criar um cubo, uma bola e um cilindro, todos com propriedades de in\xe9rcia e colis\xe3o."),(0,t.kt)("p",null,"Indo em Edit\u2192Building Editor"),(0,t.kt)("p",null,"![imgs/Untitled%201.png]","(./assets/Untitled 1.png)"),(0,t.kt)("p",null,"Nessa parte voc\xea criar casas e outras constru\xe7\xf5es urbanas ou relacionadas, pois facilita bastante."),(0,t.kt)("p",null,"Para usar:"),(0,t.kt)("p",null,'Para fazer as paredes, janelas, portas e escadas, voc\xea primeiramente seleciona o tipo, cor e textura no painel da esquerda, e "desenha" em vista superior na malha branca superior a constru\xe7\xe3o a ser feita. Pode tamb\xe9m ver que tudo \xe9 dividido em "levels", esses s\xe3o os andares das constru\xe7\xf5es.'),(0,t.kt)("p",null,"Model Editor:"),(0,t.kt)("p",null,"Tem dois caminhos, o primeiro, a partir de nenhum objeto \xe9: Edit\u2192Model editor, o outro voc\xea pode modificar um model existente, selecione ele, no display de simula\xe7\xe3o ou no painel esquerdo, depois clique com bot\xe3o direito \u2192 Edit Model."),(0,t.kt)("p",null,"Ambos v\xe3o abrir o painel do model editor."),(0,t.kt)("p",null,"Nesse painel, seu objeto selecionado a ser editado fica em laranja, o resto branco(ambos transparentes)."),(0,t.kt)("p",null,'No painel a esquerda, na aba insert, voc\xea pode fazer algumas coisas, como colocar mais objetos, sendo as "simple shapes", ou "custom shapes"(para outros models feitos fora do gazebo, vou explicar depois), na aba model, voc\xea pode deixar o objeto static, que deixa ele fixado no mundo(isso n\xe3o afeta a caixa de colis\xe3o, ele apenas n\xe3o consegue se mover), pode adicionar plugins, e visualizar links e joints, e dar auto-disable.'),(0,t.kt)("h3",{id:"joints"},"Joints:"),(0,t.kt)("p",null,"![imgs/Untitled%202.png]","(./assets/Untitled 2.png)"),(0,t.kt)("p",null,'No model editor, na barra superior, assim como na imagem acima, voc\xea pode criar "joints", elas s\xe3o liga\xe7\xf5es entre models, ou entre links de algum model, (links s\xe3o "models de models", ou melhor, partes de um model que teem representa\xe7\xe3o pr\xf3pria, no drone por exemplo, tem o link do frame, dos rotores e p\xe1s, do LiDar, etc..). Essas liga\xe7\xf5es podem ser de v\xe1rios tipos, cada um com sua caracter\xedstica, por exemplo, a joint ball \xe9 uma liga\xe7\xe3o com rota\xe7\xe3o livre em 6 eixos (x, y, z, roll, pitch, yaw), tem a revolute joint, que permite rota\xe7\xe3o em um eixo, o qual voc\xea seleciona o eixo no qual vai ser o livre, entre outros...'),(0,t.kt)("h2",{id:"corda-no-gazebo"},"Corda no Gazebo"),(0,t.kt)("h3",{id:"funcionamento"},"Funcionamento"),(0,t.kt)("p",null,"O pacote criado pela Skyrats possui um script capaz de criar um model que simula uma corda no Gazebo. A ideia principal \xe9 utiliza-la para miss\xf5es que envolvam o carregamento de objetos, como a Outdoor e Swarm."),(0,t.kt)("p",null,"Como o Gazebo s\xf3 \xe9 capaz de simular corpos r\xedgidos, que n\xe3o \xe9 o caso de uma corda, algumas adapta\xe7\xf5es precisaram ser feitas. A corda foi criada por meio da uni\xe3o de v\xe1rios links, no formato de cilindro, empilhados um acima do outro. Para uni-los, foi utilizado um joint do tipo ball, que permite rota\xe7\xe3o em todos os eixos. Assim, a corda \xe9 formada por um conjunto de corpos r\xedgidos unidos para dar a impress\xe3o de que atuam como uma corda."),(0,t.kt)("p",null,"Portanto, o realismo da simula\xe7\xe3o \xe9 diretamente proporcional a quantidade de links. Quanto mais links o modelo tiver para um mesmo tamanho, maior ser\xe1 a semelhan\xe7a com uma corda real. Entretanto, um n\xfamero muito alto de links pode afetar o FPS e o real time factor, deixando a simula\xe7\xe3o lenta, o que, em alguns casos, chega a ser inutiliz\xe1vel. Baseado em testes emp\xedricos, 10 a 20 links para uma corda de um metro costuma ser o ideal para conciliar a performance e o desempenho."),(0,t.kt)("h3",{id:"como-utilizar"},"Como utilizar"),(0,t.kt)("p",null,"Para utilizar o script, basta entrar no diret\xf3rio scripts do pacote de simula\xe7\xe3o e executar Corda.py. O programa ir\xe1 pedir que voc\xea insira a quantidade de links desejados e o tamanho de cada link. Dessa forma, \xe9 poss\xedvel controlar o tamanho final da corda realizando uma conta simples: n\xfamero de links vezes tamanho do link. Ap\xf3s digitar essas entradas, o model da corda estar\xe1 na pasta models do pacote de simula\xe7\xe3o, onde \xe9 poss\xedvel utilizar diretamente no Gazebo utilizando a aba insert caso voc\xea tenha feito setup.bash."),(0,t.kt)("h3",{id:"explicacao-do-script"},"Explicacao do Script"),(0,t.kt)("p",null,"O script funciona de uma forma muito simples. Nele, existem duas fun\xe7\xf5es: uma para criar um link e outra para colocar uma joint entre dois links. A primeira, quando chamada, ir\xe1 escrever no arquivo SDF que ser\xe1 criado todos os atributos necess\xe1rios (posi\xe7\xe3o, massa, momento de in\xe9rcia e a geometria da caixa de colis\xe3o e do visual) para criar o SDF de um link cil\xedndrico. "),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'def buildLink(i,tamanho):\n    f.write("   <link name=\\"link_" + str(i + 1) + "\\">\\n")\n    f.write("    <pose>0 0 " + str(i * tamanho) + "</pose>\\n")\n    f.write("    <inertial>\\n")\n    f.write("    <mass>" + str(1 * tamanho) + "</mass>\\n")\n    f.write("    </inertial>\\n")\n    f.write("    <collision name=\\"" + str(i + 1) + "\\">\\n")\n    f.write("      <pose>0 0 0</pose>\\n")\n    f.write("      <geometry>\\n")\n    f.write("       <cylinder>\\n")\n    f.write("        <radius>0.012</radius>\\n")\n    f.write("        <length>" + str(tamanho) + "</length>\\n")\n    f.write("       </cylinder>\\n")\n    f.write("      </geometry>\\n")\n    f.write("     </collision>\\n")\n    f.write("     <visual name=\\"" + str(i + 1) + "\\">\\n")\n    f.write("      <pose>0 0 0</pose>\\n")\n    f.write("      <geometry>\\n")\n    f.write("       <cylinder>\\n")\n    f.write("        <radius>0.012</radius>\\n")\n    f.write("        <length>" + str(tamanho) + "</length>\\n")\n    f.write("       </cylinder>\\n")\n    f.write("      </geometry>\\n")\n    f.write("     </visual>\\n")\n    f.write("   </link>\\n")\n')),(0,t.kt)("p",null,"A segunda fun\xe7\xe3o \xe9 respons\xe1vel por criar uma joint do tipo ball e coloc\xe1-la na posi\xe7\xe3o correta entre dois links."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'def buildJoint (i, tamanho):\n    f.write("   <joint name=\\"joint " + str(i) + "\\" type=\\"ball\\">\\n")\n    f.write("    <parent>link_"+ str(i + 1) + "</parent>\\n")\n    f.write("    <child>link_" + str(i) + "</child>\\n")\n    f.write("    <pose>0 0 " + str(0.5 * tamanho) + "</pose>\\n")\n    f.write("    <physics>\\n")\n    f.write("    </physics>\\n")\n    f.write("   </joint>\\n")\n')),(0,t.kt)("p",null,"Por fim, o resto do script \xe9 respons\xe1vel por abrir e fechar o arquivo, pedir que o usu\xe1rio insira o tamanho e a quantidade de links, criar o cabe\xe7alho do SDF e chamar as fun\xe7\xf5es buildLink e buildJoint quantas vezes for necess\xe1rio."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'tamanho = float(input("Por favor, insira o tamanho de cada link: "))\nquantidade = int(input("Por favor, insira a quantidade de links: "))\nf = open("../../models/Rope/model.sdf", "w")\nf.write("<?xml version=\\"1.0\\"?>")\nf.write("<sdf version=\\"1.5\\">\\n")\nf.write(" <model name=\\"Corda\\">\\n")\nf.write("  <self_collide>true</self_collide>\\n")\nfor i in range(quantidade):\n    if i == 0:\n        buildLink(i, tamanho)\n    else:\n        buildLink(i, tamanho)\n        buildJoint(i, tamanho)\n\nf.write("</model>\\n")\nf.write("</sdf>\\n")\nf.close()\n')),(0,t.kt)("h2",{id:"como-funciona-o-arquivo-model"},"Como funciona o arquivo model?"),(0,t.kt)("p",null,"Ele, basicamente precisa de dois arquivos, um sendo ",(0,t.kt)("inlineCode",{parentName:"p"},".config"),", e outro ",(0,t.kt)("inlineCode",{parentName:"p"},".sdf"),"ou ",(0,t.kt)("inlineCode",{parentName:"p"},".urdf"),". Todos funcionando na linguagem XML."),(0,t.kt)("p",null,"O .config tem esse estilo:"),(0,t.kt)("p",null,(0,t.kt)("a",{parentName:"p",href:"https://github.com/SkyRats/simulation/blob/master/models/drone_indoor/model.config"},"https://github.com/SkyRats/simulation/blob/master/models/drone_indoor/model.config")),(0,t.kt)("p",null,"Onde \xe9 declarado o nome do model, vers\xe3o do model, a vers\xe3o do sdf(1.6), configura\xe7\xf5es do autor e descri\xe7\xf5es do objeto."),(0,t.kt)("p",null,"O .sdf tem esse estilo:"),(0,t.kt)("p",null,(0,t.kt)("a",{parentName:"p",href:"https://github.com/SkyRats/simulation/blob/master/models/drone_indoor/model.sdf"},"https://github.com/SkyRats/simulation/blob/master/models/drone_indoor/model.sdf")),(0,t.kt)("p",null,"Todas as coisas do objeto est\xe3o nesse arquivo, por exemplo, a mesh, plugins, orienta\xe7\xf5es, add de links, add de outros models, joints, materials, e todo o resto poss\xedvel."),(0,t.kt)("p",null,"Como \xe9 muito grande as coisas, temos muitos exemplos no nosso reposit\xf3rio simulation e outras infos sobre o .sdf e seus atributos aqui: ",(0,t.kt)("a",{parentName:"p",href:"http://sdformat.org/spec?ver=1.7&elem=model"},"http://sdformat.org/spec?ver=1.7&elem=model")),(0,t.kt)("h2",{id:"worlds"},"Worlds"),(0,t.kt)("p",null,"Eles s\xe3o os mundos no gazebo, ou seja, s\xe3o meio que uma jun\xe7\xe3o de models com suas posi\xe7\xf5es e configura\xe7\xf5es."),(0,t.kt)("p",null,'Eles podem ser configurados direto no gazebo, adicionando coisas no painel de simula\xe7\xe3o, sendo pelo painel esquerdo, adicionando modelos na parte "insert", e na aba world visualizar as configura\xe7\xf5es existentes do mundo, nas aba de cima, pode mudar a configura\xe7\xe3o de posi\xe7\xe3o, rota\xe7\xe3o e escala manualmente dos models, adicionar fontes de luz e mexer a camera.'),(0,t.kt)("p",null,"Pelo arquivo .world, da para fazer e adicionar todas as configura\xe7\xf5es do mundo, adicionando models, mudar posi\xe7\xe3o, rota\xe7\xe3o, escala dos mesmos, adicionar plugins de mundo e configurar a GUI, sendo essa infinitamente customiz\xe1vel ( Vou explicar mais para frente ), como por exemplo, adicionar interfaces com bot\xf5es, labels, etc, 100% customiz\xe1veis, que podem fazer qualquer coisa dentro do gazebo, customizar configura\xe7\xf5es de ilumina\xe7\xe3o, c\xe2mera e c\xe9u, entre outros."),(0,t.kt)("p",null,"Temos v\xe1rios exemplos de .worlds no nosso reposit\xf3rio simulation, al\xe9m disso, todas as configura\xe7\xf5es para o .world tem aqui: ",(0,t.kt)("a",{parentName:"p",href:"http://sdformat.org/spec?ver=1.7&elem=world"},"http://sdformat.org/spec?ver=1.7&elem=world")),(0,t.kt)("h2",{id:"adicionar-meshs-de-outros-programas"},"Adicionar Meshs de Outros Programas"),(0,t.kt)("h3",{id:"quais-os-arquivos"},"Quais os arquivos?"),(0,t.kt)("p",null,'No gazebo, p/ usar meshs externas, os principais tipos de arquivos suportados pelo sdf arquivos .dae, .obj, .stl. Com observa\xe7\xe3o de que o .obj e o .stl n\xe3o suporta materiais/texturas, o .dae \xe9 melhor n\xe3o ser usado para transportar texturas pois ele d\xe1 problemas com sombras fixas nesse transporte de arquivos; em rela\xe7\xe3o a desempenho/qualidade, o .dae \xe9 o mais "leve", enquanto o .stl \xe9 mais "pesado", por\xe9m ambos s\xe3o bem otimizados; como compara\xe7\xe3o o .stl \xe9 superior na maioria dos casos.'),(0,t.kt)("p",null,"Em rela\xe7\xe3o as texturas, os tipos de arquivos citado acima n\xe3o suportam/n\xe3o suportam bem. O recomendado \xe9 usar scripts de materiais. O seguinte link explica muito bem como fazer: ",(0,t.kt)("a",{parentName:"p",href:"http://gazebosim.org/tutorials?tut=color_model"},"http://gazebosim.org/tutorials?tut=color_model")),(0,t.kt)("h3",{id:"como-adicionar-a-mesh"},"Como adicionar a mesh?"),(0,t.kt)("p",null,"Primeiro cria uma pasta para o model, exemplo: ",(0,t.kt)("inlineCode",{parentName:"p"},"mkdir model; cd model")," , depois crie os arquivos de config, sdf, e outra pasta para guardar a mesh: ",(0,t.kt)("inlineCode",{parentName:"p"},"mkdir meshes; touch model.config model.sdf")," "),(0,t.kt)("p",null,'Nisso, voc\xea coloca a mesh dentro da pasta, configura seus arquivos .sdf e .config. P/ adicionar a mesh no .sdf, s\xf3 usar um "include" dentro da parte da configura\xe7\xe3o do link, como exemplo:'),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-xml"},"<geometry>\n       <mesh>\n            <uri>model://model/meshes/mesh.stl</uri>\n      </mesh>\n</geometry>\n")),(0,t.kt)("p",null,"Lembre-se que deve-se colocar o link para a mesh na colision box e no visual."),(0,t.kt)("h2",{id:"programa\xe7\xe3o-no-gazebo-e-plugins"},"Programa\xe7\xe3o no Gazebo e Plugins"),(0,t.kt)("p",null,"Tudo que vimos at\xe9 agora \xe9 uma pequena parte do que da para fazer com o gazebo, com plugins, ele fica 100% configur\xe1vel e ajust\xe1vel p/ qualquer simula\xe7\xe3o."),(0,t.kt)("p",null,"Por ser infinitamente longo, vou ensinar o jeito de como buscar e come\xe7ar a fazer alguma programa\xe7\xe3o/plugin em cima do gazebo e explicar alguns c\xf3digos."),(0,t.kt)("h3",{id:"como-funciona"},"Como funciona?"),(0,t.kt)("p",null,"Os plugins do gazebo s\xe3o em C++ OO e se dividem em 3 tipos principais, os de model, de world ou de GUI."),(0,t.kt)("p",null,"Os de model s\xe3o, como o nome j\xe1 diz, inicializados em models, por exemplo, dentro do .sdf:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-xml"},"                <include>\n            <plugin name = 'wind_gazebo' filename = 'libgazebo_wind_plugin.so'>\n                <robotNamespace/>\n                <linkName>base_link</linkName>\n                <xyzOffset>0 0 0</xyzOffset>\n                <windForceMean>10</windForceMean>\n                <windForceMax>50</windForceMax>\n                <windForceVariance>0</windForceVariance>\n                <windDirectionMean>0 1 0</windDirectionMean>\n                <windDirectionVariance>0</windDirectionVariance>\n            </plugin>\n            <uri>model://model</uri>\n        </include>\n")),(0,t.kt)("p",null,"Esse \xe9 um exemplo de como adicionar um plugin com par\xe2metros dentro do sdf, no caso o plugin do vento."),(0,t.kt)("h3",{id:"como-declarar-os-tipos"},"Como declarar os tipos?"),(0,t.kt)("p",null,"Para indicar qual o tipo de plugin, coloque no c\xf3digo o seguinte comando, sendo para modelo, gui ou world. Coloque ele depois de tudo ou antes de tudo,(em cima ou embaixo dos m\xe9todos, nunca dentro de nenhum)."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"GZ_REGISTER_GUI_PLUGIN(NomeDaClasse)\nGZ_REGISTER_MODEL_PLUGIN(NomeDaClasse)\nGZ_REGISTER_WORLD_PLUGIN(NomeDaClasse)\n")),(0,t.kt)("p",null,"Al\xe9m disso, os plugins de model possuem duas formas de rodar, uma \xfanica no Load do model, e outra no OnUpdate(Como se fosse um while(1)... obs: n\xe3o fa\xe7am while(1) pfv)."),(0,t.kt)("p",null,'Como exemplo temos o m\xe9todo load do plugin "GetDropZonePositions"'),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},'public: void Load(physics::ModelPtr _parent, sdf::ElementPtr _sdf)\n        {\n            ignition::math::Pose3d dz_clean_pose = _parent->WorldPose();\n            ignition::math::Vector3<double> dzc_p = dz_clean_pose.Pos();\n            double CP_V[3] = {dzc_p.X(), dzc_p.Y(), dzc_p.Z() };\n            gzmsg << "Dropzone pose:"<< "\\n\\tX = " << CP_V[0] << "\\n\\tY = " << CP_V[1] << "\\n\\tZ = " << CP_V[2] << std::endl;\n        }\n')),(0,t.kt)("p",null,"essa fun\xe7\xe3o load recebe dois atributos, no caso, o _parent que \xe9 o pr\xf3prio model dentro do mundo, e o _sdf que \xe9 o sdf do model que foi inserido no mundo. No caso, a fun\xe7\xe3o dessa fun\xe7\xe3o .-. \xe9 de dar no in\xedcio do model a posi\xe7\xe3o dele no mapa, pois ele foi inserido de forma aleat\xf3ria usando o modo population do .world."),(0,t.kt)("p",null,"Primeiro, ele cria um objeto de Pose3d, que representa a posi\xe7\xe3o do objeto no mundo, e atribui a ele a posi\xe7\xe3o do mundo usando o m\xe9todo WorldPose() do model _parent, depois disso, ele cria um vector3, que \xe9 um objeto com informa\xe7\xf5es sobre posi\xe7\xe3o em x,y,z e nele atribui o vector3d de dentro do pose 3d usando o m\xe9todo Pos(), e nisso ele coloca um vetor de 3 posi\xe7\xf5es cada uma das posi\xe7\xf5es e depois printa elas com gzmsg, p aparecer destacado no terminal como mensagem do gazebo."),(0,t.kt)("p",null,"E como exemplo do m\xe9todo OnUpdate temos o do plugin dos Dynamic Obstacles:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"public: void OnUpdate()\n        {\n                        //1\n            if (!this->toggle_status)\n            {\n                this->model->SetLinearVel(ignition::math::Vector3d(0, 0, 0));\n                this->model->SetAngularVel(ignition::math::Vector3d(0, 0, 0));\n                return;\n            }\n                        //2\n            double v;\n            ignition::math::Vector3<double> curr_pos = this->link->WorldCoGPose().Pos();         \n            double x_direction = (curr_pos - this->point_0).Dot(this->direction);\n            //3\n            if (this->goal_point == 1)\n            {\n                if (x_direction <= this->distance)\n                {\n                    v = this->vel;\n                }\n                else\n                {\n                    v = -this->vel;\n                    this->goal_point = 0;\n                }\n            }\n                        //4\n            else\n            {\n                if (x_direction >= 0) {\n                    v = -this->vel;\n                }\n                else\n                {\n                    v = this->vel;\n                    this->goal_point = 1;\n                }\n            }\n                        //5\n            this->model->SetLinearVel(v*this->direction);\n            this->model->SetAngularVel(ignition::math::Vector3d(0, 0, 0));\n        }\n")),(0,t.kt)("p",null,'A fun\xe7\xe3o est\xe1 dividida em 5 partes, com os respectivos coment\xe1rios. Como explicado anteriormente, a fun\xe7\xe3o OnUpdate roda a cada atualiza\xe7\xe3o do mundo(alguns milissegundos, tudo depende do Real Time Factor), parecido com a ideia do "void loop()" do arduino; come\xe7ando pela parte  da fun\xe7\xe3o  ',(0,t.kt)("inlineCode",{parentName:"p"},"//1"),"; com o toggle_status, ele verifica se a movimenta\xe7\xe3o dos obst\xe1culos foi ativada pelo  usu\xe1rio(veremos isso mais p frente em plugins de interface); se ela estiver desativada ele desliga a velocidade dos objetos, linear e angular, e retorna a fun\xe7\xe3o. No ",(0,t.kt)("inlineCode",{parentName:"p"},"//2"),' , ele declara uma vari\xe1vel double v, que mais para a frente vai receber valores de velocidade, depois ele cria uma vari\xe1vel do tipo Vector3 em double, que \xe9 como se fosse um vetor cartesiano, com 3 dimens\xf5es, por\xe9m em formato de objeto ao inv\xe9s de vari\xe1vel, e esse Vector3, com nome curr_pos, recebe a posi\xe7\xe3o do objeto naquele instante, usando o m\xe9todo do m\xe9todo do link "WorldCoGPose().Pos()" para retornar a posi\xe7\xe3o cartesiana do mesmo em Vector3, e em outra vari\xe1vel double, a x_direction, recebe o produto escalar(.Dot()) entre a dire\xe7\xe3o entre o ponto inicial e final do ciclo(aparece em outras partes do c\xf3digo) e a posi\xe7\xe3o atual dele, para assim saber o sentido que ele est\xe1 percorrendo na trajet\xf3ria. Em ',(0,t.kt)("inlineCode",{parentName:"p"},"//3")," , entra no loop assumido que o objeto est\xe1 se movendo em dire\xe7\xe3o ao ponto 1 da trajet\xf3ria, e nisso ele verifica se o x_direction, que \xe9 o produto escalar entre o vetor posi\xe7\xe3o do objeto e da dire\xe7\xe3o, sendo ele maior que a dist\xe2ncia se o x_direction coincidir com a sua chegada no ponto 1, se for verdadeiro, ele assume a velocidade positiva ao V, caso contr\xe1rio, ele assume velocidade negativa e coloca como ponto de destino o ponto 0, assim, no ",(0,t.kt)("inlineCode",{parentName:"p"},"//4")," , estando em dire\xe7\xe3o do ponto 0(ponto de in\xedcio), ele verifica se o x_direction \xe9 maior/igual a zero, se for, ele ainda est\xe1 em dire\xe7\xe3o ao ponto 0, assumindo velocidade negativa, caso contr\xe1rio ele assume velocidade positiva e toma como dire\xe7\xe3o o ponto 1. E no ",(0,t.kt)("inlineCode",{parentName:"p"},"//5")," , ele coloca no objeto as velocidades, no caso sendo a angular como 0 fixa, para ele n\xe3o ter movimenta\xe7\xe3o angular."),(0,t.kt)("p",null,'Os plugins de mundo, tem como maior finalidade modificar o mundo em um instante inicial, pois ele s\xf3 tem a condi\xe7\xe3o de ser realizado com o m\xe9todo "Load", tem como o exemplo o m\xe9todo do "Attach Rope" (',(0,t.kt)("a",{parentName:"p",href:"https://github.com/SkyRats/simulation/blob/master/plugins/attach_rope.cc"},"https://github.com/SkyRats/simulation/blob/master/plugins/attach_rope.cc"),")"),(0,t.kt)("h3",{id:"obs"},"OBS::"),(0,t.kt)("p",null,"Por mais que os plugins tem os m\xe9todos Load ou OnUpdate, que permitem que ele rode uma ou mais vezes, ou em Loop, temos o sistema de msgs, que abre mais infinitas op\xe7\xf5es... falarei mais para a frente"),(0,t.kt)("h3",{id:"plugins-de-gui"},"Plugins de GUI"),(0,t.kt)("p",null,"Esses plugins permitem que n\xf3s possamos criar uma nova interface para o gazebo, n\xe3o s\xf3 com bot\xf5es, mas com displays, barras de inser\xe7\xf5es, e infinitas possiblidades."),(0,t.kt)("p",null,"![imgs/Untitled%203.png]","(./assets/Untitled 3.png)"),(0,t.kt)("p",null,"Como exemplo n\xf3s temos do plugin feito em 2020 para facilitar e controlar as simula\xe7\xf5es, vou explicar resumidamente o c\xf3digo:"),(0,t.kt)("p",null,"(Obs: vou mostrar o .cpp, mas vale muito a pena ir olhando o .h do c\xf3digo, vai ajudar muito no entendimento)"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <sstream>\n#include <gazebo/msgs/msgs.hh>\n#include "simulation/skyrats_interface.hh"\n#include <ignition/msgs.hh>\n#include "simulation/common.h"\n#include <fstream>\n#include <math.h>\n\nusing namespace gazebo;\n\n//1\nGZ_REGISTER_GUI_PLUGIN(GUIExampleSpawnWidget)\n\nGUIExampleSpawnWidget::GUIExampleSpawnWidget()//1.1\n  : GUIPlugin()\n{\n  gzmsg << "Hello world" << std::endl;\n  this->counter = 0;\n  this->wind_status = false;\n  this->smoke_status = false;\n\n  //2\n  this->setStyleSheet(\n      "QFrame { background-color : rgba(95, 139, 250, 255); color : blue; }");\n\n  //3\n  QHBoxLayout *mainLayout = new QHBoxLayout;\n\n  //4\n  QFrame *mainFrame = new QFrame();\n\n  //5\n  QVBoxLayout *frameLayout = new QVBoxLayout();\n\n  //6\n  QPushButton *WindButton = new QPushButton(tr("ON/OFF WIND"));\n  connect(WindButton, SIGNAL(clicked()), this, SLOT(WindButton()));\n\n  QPushButton *SmokeButton = new QPushButton(tr("ON/OFF SMOKE"));\n  connect(SmokeButton, SIGNAL(clicked()), this, SLOT(SmokeButton()));\n\n  QPushButton *ObstacleButton = new QPushButton(tr("ON/OFF OBSTACLE"));\n  connect(ObstacleButton, SIGNAL(clicked()), this, SLOT(ObstacleButton()));\n\n  QPushButton *AttachButton = new QPushButton(tr("Rope Attach"));\n  connect(AttachButton, SIGNAL(clicked()), this, SLOT(AttachButton()));\n\n    //7\n  QLabel *Skyrats_txt = new QLabel(("Skyrats Simulator v1.0"));\n\n  //8\n  frameLayout->addWidget(Skyrats_txt);\n\n  frameLayout->addWidget(WindButton);\n\n  frameLayout->addWidget(SmokeButton);\n\n  frameLayout->addWidget(ObstacleButton);\n\n  QLabel *indoor_txt = new QLabel(("Indoor Simulation"));\n  \n  frameLayout->addWidget(indoor_txt);\n\n  frameLayout->addWidget(AttachButton);\n\n  QLabel *outdoor_txt = new QLabel(("Outdoor Simulation"));\n  \n  frameLayout->addWidget(outdoor_txt);\n\n  //9\n  mainFrame->setLayout(frameLayout);\n\n  //10\n  mainLayout->addWidget(mainFrame);\n\n  //11\n  frameLayout->setContentsMargins(0, 0, 0, 0);\n  mainLayout->setContentsMargins(0, 0, 0, 0);\n\n  this->setLayout(mainLayout);\n\n \n  this->move(10, 10);\n  this->resize(160, 235);\n\n  //12\n  this->node = transport::NodePtr(new transport::Node());\n  this->node->Init();\n  this->factoryPub = this->node->Advertise<msgs::Factory>("~/factory");  \n\n  this->wind_toggle_pub = this->node->Advertise<msgs::Int>("~/wind_toggle");\n\n  this->smoke_pub = this->node->Advertise<msgs::Scene>("~/scene");\n\n  this->obstacle_toggle_pub = this->node->Advertise<msgs::Int>("~/obstacle_toggle");\n\n  this->attach_pub = this->node->Advertise<msgs::Int>("~/rope_attach");\n}\n\n/////////////////////////////////////////////////\nGUIExampleSpawnWidget::~GUIExampleSpawnWidget(){\n}\n//13\nvoid GUIExampleSpawnWidget::WindButton()\n{\n  msgs::Int msg;\n  this->wind_status = !this->wind_status;\n  msg.set_data(this->wind_status);\n  this->wind_toggle_pub->Publish(msg);\n  gzmsg << "Wind status: " << wind_status << std::endl;\n}\n\nvoid GUIExampleSpawnWidget::SmokeButton()\n{\n  msgs::Scene smk_msg;\n  msgs::Fog* fog = new msgs::Fog;\n  this->smoke_status =! smoke_status;\n  smk_msg.set_name("smoke_toggle");\n  if (smoke_status == 0){\n    smk_msg.clear_fog();\n\n    fog->set_start(10000.0);\n    fog->set_density(0.0);\n    fog->set_end(30000.0);\n\n    smk_msg.set_allocated_fog(fog);\n  }\n  if (smoke_status == 1){\n    fog->set_start(0.1);\n    fog->set_density(300.0);\n    fog->set_end(10.0);\n\n    smk_msg.set_allocated_fog(fog);\n  }\n  \n  this->smoke_pub->Publish(smk_msg);\n  gzmsg << "Smoke status: " << smoke_status << std::endl;\n  gzmsg << "A_Fog status: " << smk_msg.has_fog() << std::endl;\n}\n\nvoid GUIExampleSpawnWidget::ObstacleButton()\n{\n  msgs::Int obstacle_msg;\n  this->obstacle_status = !this->obstacle_status;\n  obstacle_msg.set_data(this->obstacle_status);\n  this->obstacle_toggle_pub->Publish(obstacle_msg);\n  gzmsg << "Obstacle status: " << obstacle_status << std::endl;\n}\n\nvoid GUIExampleSpawnWidget::AttachButton()\n{\n  gzmsg << "Rope attached message sent..." << std::endl;\n  msgs::Int attach_msg;\n  attach_msg.set_data(1);\n  this->attach_pub->Publish(attach_msg);\n}\n')),(0,t.kt)("p",null,"O c\xf3digo ta dividido em 13 partes para facilitar a explica\xe7\xe3o:"),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//1")," \u2192 \xc9 registrado o plugin como plugin de interface(obs: isso pode ser declarado no come\xe7o ou no final, embora na maioria dos plugins seja no final)"),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//1.1"),' \u2192 Nos plugins de GUI, n\xe3o existe m\xe9todo "Load", o m\xe9todo para plugins GUI, com o mesmo funcionamento \xe9 o construtor.'),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//2"),' \u2192 Define o estilo do "fundo" da interface adicionada ao gazebo, no caso foi utilizado o padr\xe3o RGB, mas existem outros, tudo isso pode ser visto na documenta\xe7\xe3o do QWidgets.'),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//3")," \u2192 Cria um layout do QWidget em formato de caixa para guardar a interface"),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//4")," \u2192 Cria o frame principal(Obs: o frame \xe9 a \xe1rea toda ocupada pela interface, e o layout \xe9 onde ficar\xe3o os itens da interface)."),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//5")," \u2192 Cria uma layout para o frame."),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//6")," \u2192 Aqui ele cria os bot\xf5es da interface, criando um ponteiro para eles e chamando um construtor, enviando uma string, sendo essa string a que aparecer\xe1 em cima do bot\xe3o em sua implementa\xe7\xe3o, ale\u1e3f disso na pr\xf3xima linha ele liga o bot\xe3o ao seu m\xe9todo, declarando seu tipo de funcionamento, como no exemplo, o cliked(), que funciona como um bot\xe3o de press\xe3o, que ele realiza uma \xfanica vez o c\xf3digo ao ser precionado, necessitando ser pressionado denovo para uma nova execu\xe7\xe3o do c\xf3digo."),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//7")," \u2192 Cria uma Label com uma string, sendo a Label alguma string/texto colocada no layout da interface."),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//8")," \u2192 Ele adiciona todos os objetos criados no layout do frame, usando o m\xe9todo addWidget(). Obs: Os objetos s\xe3o colocados na ordem que s\xe3o escritos no c\xf3digo, sendo de cima para baixo, como se fosse uma fila."),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//9")," \u2192 Aqui ele coloca o layout principal do frame como sendo o layout criado anteriormente em que foi adicionado todos os widgets."),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//10")," \u2192 Adiciona o outro layout criado como um widget do frame."),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//11")," \u2192 Configura a margem dos dois layouts criados e adicionados, no caso setando as duas como 0 em todas as dimens\xf5es."),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//12")," \u2192 Aqui ele cria os nodes e publishers que ser\xe3o usados nos c\xf3digos dos m\xe9todos de cada bot\xe3o, essa parte vou explicar com bastante detalhes mais para a frente."),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//13"),' \u2192 Aqui, por final ele cria os m\xe9todos de cada bot\xe3o adicionado. Em cada m\xe9todo, que foi declarado no .h e associado a cada bot\xe3o no passo 6 \xe9 descrito o c\xf3digo que rodar\xe1 de acordo com o esquema de press\xe3o do bot\xe3o, no caso dos "clicked()", cada c\xf3digo desse rodar\xe1 uma vez a cada vez que o bot\xe3o for pressionado.'),(0,t.kt)("h2",{id:"msgs-do-gazebo"},"Msgs do Gazebo"),(0,t.kt)("p",null,'Al\xe9m de tudo isso que j\xe1 explicamos, outro jeito de modificar/criar coisas para simula\xe7\xe3o no gazebo \xe9 atrav\xe9s das msgs, sistema parecido com o ROS, onde cada pequena parte do gazebo se comunica com outras atrav\xe9s dela, por exemplo temos os bot\xf5es do nosso plugin Skyzebo 1.0, onde todos os bot\xf5es criam publishers, e estes enviam mensagens para outras coisas, como por exemplo ligar a fuma\xe7a, que cria uma msg do tipo "Fog", modifica ela para ter as caracter\xedsticas da fuma\xe7a, depois \xe9 criado uma vari\xe1vel do tipo scene, onde modificamos nela apenas a parte "Fog", onde \xe9 inclu\xedda a configura\xe7\xe3o feita, e ap\xf3s isso a mensagem \xe9 publicada para que chegue no t\xf3pico "~/scene" e assim modifique ele aplicando fuma\xe7a no mundo. O c\xf3digo do m\xe9todo desse bot\xe3o \xe9 esse, onde tem informa\xe7\xf5es explicadas em coment\xe1rios:'),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},'void GUIExampleSpawnWidget::SmokeButton()\n{\n  msgs::Scene smk_msg;\n  msgs::Fog* fog = new msgs::Fog; //Criar as msgs necess\xe1rias\n  this->smoke_status =! smoke_status; //Inverter o estado passado da fuma\xe7a, para funcionar como um "toggle"\n  smk_msg.set_name("smoke_toggle"); //Da o nome da msg da smoke\n  if (smoke_status == 0){\n    smk_msg.clear_fog(); // Se o estado da fuma\xe7a for 0 ele limpa a fog, al\xe9m de inicializar ela bem longe do objeto que possui vis\xe3o, como camera do drono ou nossa vis\xe3o\n\n    fog->set_start(10000.0);\n    fog->set_density(0.0);\n    fog->set_end(30000.0);\n\n    smk_msg.set_allocated_fog(fog); // Coloca a msg modificada dentro da msg da scene\n  }\n  if (smoke_status == 1){ //Aqui, ele ativa a fuma\xe7a, al\xe9m de deixar seu \xednicio bem pr\xf3ximo do objeto com vis\xe3o.\n    fog->set_start(0.1);\n    fog->set_density(300.0);\n    fog->set_end(10.0);\n\n    smk_msg.set_allocated_fog(fog); // Coloca a msg modificada dentro da msg da scene\n  }\n\nthis->smoke_pub->Publish(smk_msg); // publica a mensagem \n  gzmsg << "Smoke status: " << smoke_status << std::endl;\n  gzmsg << "A_Fog status: " << smk_msg.has_fog() << std::endl; //printa as informa\xe7\xf5es no terminal\n}\n')),(0,t.kt)("p",null,"Mas para que a msg seja publicada, tamb\xe9m \xe9 necess\xe1rio criar o publisher e associar o node do gazebo a ele. Nesse mesmo publisher, da fuma\xe7a, o publisher \xe9 criado assim:"),(0,t.kt)("p",null,"Primeiro, dentro da defini\xe7\xe3o da classe, voc\xea declara o node e cria o publisher:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"transport::NodePtr node; // Define o node onde vai ser associado o gazebo nele\n\ntransport::PublisherPtr smoke_pub; // Define o publisher do bot\xe3o de toggle da fuma\xe7a\n")),(0,t.kt)("p",null,'Agora, dentro do m\xe9todo "Load", que \xe9 o que roda no in\xedcio da simula\xe7\xe3o, ou para plugins de GUI, no construtor dele:'),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},'this->node = transport::NodePtr(new transport::Node()); // Coloca um node dentro da var\xedavel node criada\nthis->node->Init(); // O m\xe9todo "Init" inicia o node\n\nthis->smoke_pub = this->node->Advertise<msgs::Scene>("~/scene"); // Declara a cria\xe7\xe3o do publisher, colocando nele o tipo de msg e tamb\xe9m o t\xf3pico\n')),(0,t.kt)("p",null,'Todo o sistema de msgs pode ser visualizado como "mapa mental" no site da api do gazebo: ',(0,t.kt)("a",{parentName:"p",href:"http://osrf-distributions.s3.amazonaws.com/gazebo/api/1.3.1/dir_856da1f3c0f82036884d2d586cbc0904.html"},"http://osrf-distributions.s3.amazonaws.com/gazebo/api/1.3.1/dir_856da1f3c0f82036884d2d586cbc0904.html")),(0,t.kt)("p",null,"Al\xe9m disso, se precisar criar uma msg nova, a explica\xe7\xe3o est\xe1 aqui: ",(0,t.kt)("a",{parentName:"p",href:"http://gazebosim.org/tutorials?tut=custom_messages&cat=transport"},"http://gazebosim.org/tutorials?tut=custom_messages&cat=transport")),(0,t.kt)("h3",{id:"msgs-comunica\xe7\xe3o-entre-pluginsscripts"},"Msgs: Comunica\xe7\xe3o entre Plugins/Scripts"),(0,t.kt)("p",null,"Al\xe9m de usar as mgs para comunica\xe7\xe3o com o sistema do gazebo diretamente, podemos usar elas para comunica\xe7\xe3o entre plugins, funciona no mesmo esquema, a diferen\xe7a \xe9 que publicaremos em um t\xf3pico para outro plugin dar subscribe e callback nele. Vou explicar com exemplos agora, pois com a no\xe7\xe3o dada acima j\xe1 \xe9 necess\xe1rio para entender o funcionamento:"),(0,t.kt)("p",null,'Como exemplo vou usar a comunica\xe7\xe3o do "rope_attach", plugin utilizado para conectar as cordas de uma certa carga nos drones.'),(0,t.kt)("p",null,"Primeiramente, assim como no exemplo anterior \xe9 declarado o node e o publisher dentro da declara\xe7\xe3o da classe ( Obs: O node s\xf3 precisa ser criado em uma vez por plugin. ):"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"transport::NodePtr node;\n\ntransport::PublisherPtr attach_pub;\n")),(0,t.kt)("p",null,"E s\xe3o iniciados ao iniciar do gazebo:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},'this->node = transport::NodePtr(new transport::Node());\nthis->node->Init();\n\nthis->attach_pub = this->node->Advertise<msgs::Int>("~/rope_attach");\n')),(0,t.kt)("p",null,'O c\xf3digo do bot\xe3o, para publicar a mensagem para esse t\xf3pico "~/rope_attach" ser\xe1 bem simples, pois ele n\xe3o tem fun\xe7\xe3o de toggle, pois a caixa \xe9 presa apenas uma vez e n\xe3o \xe9 solta ap\xf3s isso, pois os drones pousam com ela, logo, esse bot\xe3o vai mandar uma mensagem do tipo "int" com o valor booleano de sinal ( 1 ):'),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},'void GUIExampleSpawnWidget::AttachButton()\n{\n  gzmsg << "Rope attached message sent..." << std::endl; // Printa no terminal a frase\n  msgs::Int attach_msg; // Cria uma msg do tipo int\n  attach_msg.set_data(1); // Associa em seu valor usando o m\xe9todo set_data o n\xfamero inteiro "1", que tem como sentido ser um "true" booleano, apenas para enviar alguma coisa para o callback\n  this->attach_pub->Publish(attach_msg); // Publica a mensagem\n}\n')),(0,t.kt)("p",null,"Certo, a mensagem foi publicada, agora o outro plugin, script, ou o que for, precisa recebe-la. Ent\xe3o, precisaremos criar um node, um subscriber e um callback. O node e o subscriber tem a fun\xe7\xe3o de estar la para receber a mensagem, e o subscriber inicia o m\xe9todo de callback sempre que recebe uma mensagem, enviando o objeto de msg recebido como par\xe2metro para ele."),(0,t.kt)("p",null,"Primeiro, precisamos definir as coisas na classe(obs: isso tudo pode ser feito direto, sem .h e sem declara\xe7\xf5es, mas isso vale apenas para os m\xe9todos), assim, criaremos o subscriber, o node e o namespace(Serve para declara\xe7\xf5es do node handle, ver\xe1 mais para a frente):"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"private:   \n        transport::SubscriberPtr attach_sub; //Define o subscriber\n        transport::NodePtr node_handle_; // Define o node_handle_\n        std::string namespace_; // Cria o namespace\n\npublic:\n        namespace_(kDefaultNamespace){} // M\xe9todo do namespace\n        void AttachCallback(ConstIntPtr &msg); // Define o m\xe9todo do callback\n")),(0,t.kt)("p",null,"Agora, com tudo criado, iremos para os m\xe9todos come\xe7ar a fazer tudo funcionar, primeiramente iremos no m\xe9todo que roda ao in\xedcio do funcionamento do gazebo, onde iremos receberemos o namespace(Caso existente), "),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},'void attach_rope::Load(physics::WorldPtr _parent, sdf::ElementPtr _sdf)\n    {\n        this->world = _parent;\n\n        if (_sdf->HasElement("robotNamespace")) //Aqui, ele observa se no sdf possui algum namespace, se tiver, ele assosia tal namespace \xe0 nossa var\xedavel\n            namespace_ = _sdf->GetElement("robotNamespace")->Get<std::string>();\n        else\n            gzerr << "[attach_rope] Please specify a robotNamespace.\\n"; //Desnecess\xe1rio\n\n        node_handle_ = transport::NodePtr(new transport::Node()); //Cria o node\n        node_handle_->Init(namespace_); // Associa o namespace, vazio ou n\xe3o ao node\n\n        attach_sub = node_handle_->Subscribe("~/rope_attach", &attach_rope::AttachCallback, this); //**1** -> Explicado abaixo\n        gzmsg << "aaaaabriuuuu aqui krai: " << std::endl; // Print de informa\xe7\xf5es para debug... hehe\n    }\n')),(0,t.kt)("p",null,(0,t.kt)("inlineCode",{parentName:"p"},"//**1**"),' \u2192 Aqui \xe9 inicializado o subscriber, tomem bastante cuidado, porque isso aqui da MUITO erro, e erros nada a ver... A partir do node handle, pegaremos um subscriber nele, e associaremos nele o t\xf3pico que ele vai receber, passaremos o m\xe9todo de callback como par\xe2metro, e tamb\xe9m passaremos a inst\xe2ncia do plugin tamb\xe9m com o "this".'),(0,t.kt)("p",null,"Certo, ap\xf3s isso temos o subscriber inicializado temos que fazer alguma coisa com a mensagem recebida, no caso, o callback faz isso, ele \xe9 um m\xe9todo que \xe9 chamado pelo subscriber toda vez que alguma mensagem \xe9 recebida, e essa mensagem \xe9 passada para esse calback, como exemplo temos o callback desse mesmo plugin, que vou explicar em coment\xe1rios porque ele \xe9 bem longo...:"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},'void attach_rope::AttachCallback(ConstIntPtr &msg){\n        \n        physics::JointPtr joint_1;\n        physics::JointPtr joint_2; // Criar vari\xe1veis de joint, que ser\xe3o as que ligar\xe3o as cordas nos drones\n\n        ignition::math::Vector3d  z_axis = ignition::math::Vector3d(0,0,1);\n        ignition::math::Vector3d  null_axis = ignition::math::Vector3d(0,0,0);\n        ignition::math::Vector4d  null_axis4D = ignition::math::Vector4d(1,0,0,0); // Cria algumas var\xedaveis em vectors, de 3 e 4 dimens\xf5es\n        \n        physics::ModelPtr corda_0 = this->world->ModelByName("swarm_box::swarm_box::Corda_0")\n        physics::ModelPtr iris_0 = this->world->ModelByName("iris_0");\n        physics::ModelPtr iris_1 =  this->world->ModelByName("iris_1");\n        physics::ModelPtr corda_1 = this->world->ModelByName("swarm_box::swarm_box::Corda");\n        physics::ModelPtr POSREF = this->world->ModelByName("POS_REF");\n        physics::ModelPtr NEGREF = this->world->ModelByName("NEG_REF");\n        physics::ModelPtr NULLREF = this->world->ModelByName("NULL_REF");\n        physics::ModelPtr FARREF = this->world->ModelByName("FAR_REF");\n        physics::ModelPtr spawn1 = this->world->ModelByName("spawn1");\n        physics::ModelPtr spawn2 = this->world->ModelByName("spawn2"); // Retorna os models necess\xe1rios presentes no mundo\n\n        bool f = false;\n        bool t = true;\n        try{//Aqui o ch\xe3o de sustenta\xe7\xe3o \xe9 removido para que n\xe3o tenha conflito das colisions box das muitas joints da corda com o pr\xf3rpio ch\xe3o\n        spawn1->SetWorldPose(FARREF->WorldPose());\n        spawn2->SetWorldPose(FARREF->WorldPose()); //Elas s\xe3o removidas sem dar um "delete" (\xe9 poss\xedvel fazer isso sim! mas da mais problema) mas sim mandando elas para longe... kkkk\n        gzmsg << " \\tDeleting ground..." << std::endl; \n        } catch(std::runtime_error *e) {\n            gzmsg << "GROUND REMOVE FAILED" << std::endl;\n        } //Usando o esquema de try catch porque da muito erro isso de remover models mandando eles para longe.\n\n        gzmsg << "\\tAttaching rope..." << std::endl;\n        joint_1 = this->world->Physics()->CreateJoint("ball", corda_0); // Cria a joint na corda de tipo ball, que tem rota\xe7\xe3o 360\xba\n        joint_1->Load(corda_0->GetLink("link_10"), iris_0->GetLink("base_link"), NULLREF->WorldPose()); // Carrega a joint na sua posi\xe7\xe3o e no iris\n        joint_1->Attach(corda_0->GetLink("link_10"), iris_0->GetLink("base_link")); // Conecta ela no iris\n        joint_1->Init(); // Inicia a joint \n\n        joint_2 = this->world->Physics()->CreateJoint("ball", corda_1); // Cria a joint na corda de tipo ball, que tem rota\xe7\xe3o 360\xba\n        joint_2->Load(corda_1->GetLink("link_10"), iris_1->GetLink("base_link"), NULLREF->WorldPose()); // Carrega a joint na sua posi\xe7\xe3o e no iris\n        joint_2->Attach(corda_1->GetLink("link_10") ,iris_1->GetLink("base_link"));  // Conecta ela no iris\n        joint_2->Init(); // Inicia a joint \n\n        spawn1->SetWorldPose(NULLREF->WorldPose());\n        spawn2->SetWorldPose(NULLREF->WorldPose()); // Manda as bases do spawn pra mais longe ainda... N\xe3o lembro por que fiz isso... Mas suave, se ta a\xed tem motivo KKKKKK\n    }\n')),(0,t.kt)("p",null,'No caso, nesse plugin a msg n\xe3o foi utilizada, pois o \xfanico objetivo era ligar uma \xfanica vez a joint caso o bot\xe3o fosse apertado, por\xe9m vou dar outro exemplo, dessa vez da msg sendo utilizada, o plugin que receber\xe1 a msg ser\xe1 o do vento, que tem um "toggle", que funciona recebendo ou 1 ou 0 de uma var\xedavel int, tudo isso a partir de mais um bot\xe3o na interface. O c\xf3digo do callback \xe9:'),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},'void GazeboWindPlugin::WindToggleCallback(ConstIntPtr &msg)\n{\n  this->wind_status = msg->data(); // Atribui o n\xfaemro recebido no status do vento, que \xe9 uma var\xedavel do objeto do plugin\n  gzmsg << "Wind toggle" << std::endl; // Mensagem no terminal\n}\n')),(0,t.kt)("p",null,"O callback \xe9 bem curto, pois ele s\xf3 altera o valor de uma vari\xe1vel, que \xe9 utilizada dentro do m\xe9todo OnUpdate."),(0,t.kt)("p",null,'O plugin do vento funciona assim: Ele pega o model em que ele est\xe1 "instalado" e aplica uma for\xe7a nele, assim se a vari\xe1vek "wind_status" tiver valor 0, ele n\xe3o mandar\xe1 for\xe7a nenhuma, caso contr\xe1rio ir\xe1 mandar a for\xe7a do vento. O c\xf3digo \xe9 um pouquinho longo, vou colocar apenas algumas linhas dele, por\xe9m ele est\xe1 dentro do pacote simulation \u2192 ',(0,t.kt)("a",{parentName:"p",href:"https://github.com/SkyRats/simulation/blob/master/plugins/gazebo_wind_plugin.cpp"},"https://github.com/SkyRats/simulation/blob/master/plugins/gazebo_wind_plugin.cpp")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"void GazeboWindPlugin::OnUpdate(const common::UpdateInfo& _info) {\n  \n  if(this->wind_status == false)\n    return;\n.\n.\n. \nContinua...\n")),(0,t.kt)("h2",{id:"dicas-para-programar-pro-gazebo"},"Dicas para programar pro gazebo:"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Improvisa mesmo, coloca umas caixas no mundo p/ dar getPose, colocar umas joint nada a v\xea, enche de bot\xe3o, coloca os plugins p conversar, etc.. .etc..."),(0,t.kt)("li",{parentName:"ul"},"Sempre que for fazer algum c\xf3digo pro gazebo, todas as informa\xe7\xf5es s\xe3o bem abertas e bem leg\xedveis de cada classe de cada m\xe9todo e vari\xe1vel do gazebo. A dica \xe9 olhar no gazebo API, l\xe1 tem TUDO, TUDO MESMO, e tudo bem explicadinho de cada m\xe9todo... Ent\xe3o sempre que precisar ver as coisas de uma classe procure: ",(0,t.kt)("inlineCode",{parentName:"li"},"<nome da classe>")," class reference gazebo, primeiro link e s\xf3 vai... Ou pode entrar no site do Gazebo API: ",(0,t.kt)("a",{parentName:"li",href:"https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/index.html"},"https://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/index.html"))))}c.isMDXComponent=!0},675:function(e,o){o.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAAWCAYAAACVIF9YAAAF1ElEQVRYCd1Wa1NTSRDND9LyX+gPslT4YG7eD9SE8EhAQsEKsotgIIguzyQkN+SJJCFBEASs0t9xtk7fTN7hsbtVW+uHrrl3prunz/TpnjE9ePAAv7KY7t27B8r9+/cbouZ6jdRT+jetK91eesqH2refjtJrHTt11T5qbF03PXr0CP9Hefjw4a3iNg0ODqApgxgcpLTO/ZffKp7OsV9M3bGbNE2DEovFAkOac2qtOZqhaUqu0+tes1g0UAxf9KG+O0djjbFYrVbYbDYRfnOun52hz/Wmb5PalCMdOZ0ucdo6r0Cr4MxmFYARWLuuAaJ1jgHRh83GYBnkzXa0YTxDQ0Pw+33w+/3ybbfbBWCrf+XP5XLB7Xa3rTcA8nS4ODk5IY4VKLvNBpfTiaGhFxgeHsbExARmZ2ex+O4dVlZWMDMzI3Yq8NaNrVYLHA47JicnEYlE8OnTJ6yvf8DCwlsEAgEwWOq02vDb5XJiamoKOzs7yOVyODg4EMlkMtje3kZ4aqrLjgcyNjYm8Wtmc8NnG0Cv14vXr1/D4XDUqWoRQB8/rmM3FkMqlUI+n8fh4SHKlbJIoVjE2loUo2MjcDhpZ2SQgXu9Hiwu/iE25UoFpXIJxUIO6bSOjY2N+l7dIEcCAQF2dnaGs/NzfLu4wPm3b7i4vMTp16/I5nJyqAZlm7QPBoOYng6DDFNxdAHkaTvs9gbA5eVlcfr17AxfvnxBtVZDtVrF0VEFRwRZ+iyAY/EYXvleNRyTXnNzczg5OZEgGSjtmA1mRddTiMdicurUVQFZNA0ToRDK5TIIUAGT8eICJ6encmBMRqsdM3gtQFKMfJcMtgBcWl4WpyrAYrGIQqEgkisUkKfk89iN7cLn80OrNwGfzwdd13F5dYUfP37g+/fv4ufzQdEAmNaRSMQRWYnA4/VCq2eeAEOhECqVCs7Pz8XmqFoVwGQLaRqLxe6ewX4AmUGC42bMAMERUKckEgn4/H5omtHFpqenUSqXcXV1hZ8/f+Ly8lKyzwPKZPaRSqewl9zD1vYW/MPDdcZokAxOTAhA7lur1QxwhQL2c1k5tN3dXXjc7rZm2CuDLJMGRQmQae9HUVLkOoA8VXY6bsQamH+7IIBIbYI7PT2VoHkw+r6OlG4AZOZHR0e7KFo5OgJtCbBUKsmBZrIZpHQdtwdobQfYi6LMIHl/E8BmBg2A4XAYhUJeAmS9lg4/S/az2ayAS+pJyeD2zrZ0Z9W1WYuKop0A05m02N4WIH11ZbCzBgmQ4LgZa6EXRXP5PJLJpEHReg2+fPkSW1ubYM0ViwatGaCeNrKXTCWRSCbk+iBzmHnVaBRAlkWtVsXh4YFkUGX+HwHspOji4iKOj48bdGENkWatQNlsuCkbC5sMA+Udx5bNOtvPZrFPeqVTIDBmj+A2tzYRHA+KrgLHMRQMCi15qNVaVbLPPfdZu6mU3I9uV/uDpFcN0ldbBrspqkl98HKtHR+DdxlbvDSYQkE6mp5OI5FMYW1tDUMvXrRlwuV24c3cHHbjMeyl9hBPxEEqE/SfmxuYCofbWr2A1DQ5qHg8LldMuVzCwUERpDazTx9LS0tdj4QGwPBt7sHGRa9Jp3I4nHJ9fFhfx8raByz8/g7TM7MIhkLwDY/A6x6Cw+5o62oMll2Md1VgJCB34spKRF4/b357A7/PD5vVBms94wKu8UgwXlV8JS2/X0ZkdRUslfn5eYyPj4PxtOrzmwC5xldOn4veIqfi8bhhk0dtsyYYKCnn9njkznI53bDbnbDbHPUMGI/gzk3VP0Hy+eWhvccjT7/WS1rptY7cky8qPh9pw5HvZJut++VDOwJ0u13yeuK38mUi2rvI8+d302/3/RxmM+WuPv6unRmmx48f41cW07NnA+glAwODPed76XLu6dNnePLkacPmrvadfv8te9Pq6iqi0SjUGF2Ntv9HjX/q9BPaUt5HIk2dut+oGq+xV35X63s3/43YlA8VY7+xU49+/gJrSYAheETT2AAAAABJRU5ErkJggg=="}}]);