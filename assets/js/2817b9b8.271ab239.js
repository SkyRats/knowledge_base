"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[290],{3905:function(e,n,a){a.d(n,{Zo:function(){return c},kt:function(){return v}});var o=a(7294);function t(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,o)}return a}function i(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){t(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,o,t=function(e,n){if(null==e)return{};var a,o,t={},r=Object.keys(e);for(o=0;o<r.length;o++)a=r[o],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)a=r[o],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var l=o.createContext({}),d=function(e){var n=o.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):i(i({},n),e)),a},c=function(e){var n=d(e.components);return o.createElement(l.Provider,{value:n},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var a=e.components,t=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=d(a),u=t,v=m["".concat(l,".").concat(u)]||m[u]||p[u]||r;return a?o.createElement(v,i(i({ref:n},c),{},{components:a})):o.createElement(v,i({ref:n},c))}));function v(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var r=a.length,i=new Array(r);i[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[m]="string"==typeof e?e:t,i[1]=s;for(var d=2;d<r;d++)i[d]=a[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9132:function(e,n,a){a.r(n),a.d(n,{contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return c}});var o=a(7462),t=a(3366),r=(a(7294),a(3905)),i=["components"],s={},l="MAVLINK",d={unversionedId:"old/Hardware/Firmware/Introdu\xe7\xe3o ao MAVLink",id:"old/Hardware/Firmware/Introdu\xe7\xe3o ao MAVLink",isDocsHomePage:!1,title:"MAVLINK",description:"Introdu\xe7\xe3o",source:"@site/../docs/old/Hardware/Firmware/Introdu\xe7\xe3o ao MAVLink.md",sourceDirName:"old/Hardware/Firmware",slug:"/old/Hardware/Firmware/Introdu\xe7\xe3o ao MAVLink",permalink:"/knowledge_base/docs/old/Hardware/Firmware/Introdu\xe7\xe3o ao MAVLink",editUrl:"https://github.com/SkyRats/knowledge_base/tree/main/docs/../docs/old/Hardware/Firmware/Introdu\xe7\xe3o ao MAVLink.md",tags:[],version:"current",frontMatter:{},sidebar:"docssidebar",previous:{title:"Compilamento do Firmware e Calibra\xe7\xe3o do Drone",permalink:"/knowledge_base/docs/old/Hardware/Firmware/IntroPX4"},next:{title:"COMO SE CONECTAR A INTERNET PELO TERMINAL DO LINUX",permalink:"/knowledge_base/docs/old/Hardware/Linux/INTERNET_PELO_TERMIAL_LINUX"}},c=[{value:"Introdu\xe7\xe3o",id:"introdu\xe7\xe3o",children:[],level:2},{value:"Mensagens",id:"mensagens",children:[{value:"Heartbeat/Connection Protocol",id:"heartbeatconnection-protocol",children:[],level:3},{value:"Mission Protocol",id:"mission-protocol",children:[],level:3},{value:"Parameter Protocols",id:"parameter-protocols",children:[],level:3},{value:"Command Protocol",id:"command-protocol",children:[],level:3}],level:2},{value:"Bibliotecas",id:"bibliotecas",children:[{value:"MAVSDK",id:"mavsdk",children:[],level:3},{value:"Pymavlink",id:"pymavlink",children:[],level:3}],level:2},{value:"Projetos ja feitos:",id:"projetos-ja-feitos",children:[],level:2},{value:"Distance sensor externo a FCU (TFMini)",id:"distance-sensor-externo-a-fcu-tfmini",children:[{value:"Driver TFMini",id:"driver-tfmini",children:[],level:3}],level:2}],m={toc:c},p="wrapper";function u(e){var n=e.components,a=(0,t.Z)(e,i);return(0,r.kt)(p,(0,o.Z)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"mavlink"},"MAVLINK"),(0,r.kt)("h2",{id:"introdu\xe7\xe3o"},"Introdu\xe7\xe3o"),(0,r.kt)("p",null,"MAVLink \xe9 um protocolo utilizado para a comunica\xe7\xe3o de ve\xedculos aereos n\xe3o tripulados entre si e com o computador de bordo e a esta\xe7\xe3o de controle."),(0,r.kt)("p",null,"Existem duas vers\xf5es. Na MAVLink v1.0, cada mensagem possui entre 8 e 263 bytes, sendo 255 de carga \xfatil m\xe1xima. Na vers\xe3o 2.0, as mensagens variam entre 11 e 279 bytes, tendo a mesma carga \xfatil."),(0,r.kt)("p",null,"Por meio da MAVLink, \xe9 poss\xedvel mandar comandos para tirar foto, pedir para o drone ir at\xe9 um ponto, realizar download do log de voo e requisitar informa\xe7\xf5es como altitude, velocidade, posi\xe7\xe3o etc."),(0,r.kt)("p",null,"A MAVLink tamb\xe9m \xe9 uma parte fundamental da QGroundControl. A QGC funciona como uma interface gr\xe1fica que recebe, exibe e envia as informa\xe7\xf5es do drone por meio do protoc\xf3lo MAVLink"),(0,r.kt)("h2",{id:"mensagens"},"Mensagens"),(0,r.kt)("p",null,"As mensagens j\xe1 prontas da MAVLink se dividem por alguns servi\xe7os."),(0,r.kt)("h3",{id:"heartbeatconnection-protocol"},"Heartbeat/Connection Protocol"),(0,r.kt)("p",null,"Esse servi\xe7o \xe9 respons\xe1vel por conectar o Drone \xe0 Ground Station. Por meio dele, o Drone envia regularmente uma mensagem chamada Heartbeat que serve para avisar que o drone est\xe1 conectado e dispon\xedvel"),(0,r.kt)("h3",{id:"mission-protocol"},"Mission Protocol"),(0,r.kt)("p",null,"Serve para realizar download, upload e modificar planos de voo."),(0,r.kt)("h3",{id:"parameter-protocols"},"Parameter Protocols"),(0,r.kt)("p",null,"Esse servi\xe7o serve para exibir os par\xe2metros utilizados pelo drone e seus componentes. Ele \xe9 bastante \xfatil porque permite que a gente visualize todos os par\xe2metros por meio da QGroundControl e da Mission Planner."),(0,r.kt)("h3",{id:"command-protocol"},"Command Protocol"),(0,r.kt)("p",null,"Permite mandar comandos para o drone. Por exemplo, v\xe1 para o ponto x."),(0,r.kt)("h2",{id:"bibliotecas"},"Bibliotecas"),(0,r.kt)("p",null,"O projeto MAVLink possui algumas bibliotecas que podem ser utilizadas para transmitir e receber mensagens utilizando o protocolo."),(0,r.kt)("p",null,"A primeira e de mais baixo n\xedvel \xe9 a ",(0,r.kt)("a",{parentName:"p",href:"https://mavlink.io/en/"},"MAVLink"),". Ela \xe9 a oficial da equipe que desenvolve o protocolo, por\xe9m us\xe1-la \xe9 bastante trabalhoso. S\xf3 vale a pena para escrever mensagens personalizadas, o que \xe9 um caso raro j\xe1 que as mensagens j\xe1 dispon\xedveis por padr\xe3o na PX4 costumam ser suficientes. Por isso utilizamos outras ferramentas:"),(0,r.kt)("h3",{id:"mavsdk"},"MAVSDK"),(0,r.kt)("p",null,"\xc9 uma API criada pela equipe que mantem a MAVLink para facilitar o envio e recebimento de mensagens. Com ela, \xe9 poss\xedvel programar em ",(0,r.kt)("a",{parentName:"p",href:"https://mavsdk.mavlink.io/main/en/cpp/api_reference/"},"C++")," e ",(0,r.kt)("a",{parentName:"p",href:"http://mavsdk-python-docs.s3-website.eu-central-1.amazonaws.com/"},"Python"),"."),(0,r.kt)("p",null,"Para instalar a vers\xe3o para Python \xe9 simples, basta digitar no terminal:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"pip3 install mavsdk\npip3 install aioconsole\n")),(0,r.kt)("h3",{id:"pymavlink"},"Pymavlink"),(0,r.kt)("p",null,"Outra alternativa, dispon\xedvel apenas com Python, \xe9 a ",(0,r.kt)("a",{parentName:"p",href:"https://pypi.org/project/pymavlink/"},"Pymavlink"),". Ela \xe9 a mais simples de todas e \xe9 a que utilizamos para fazer a transmiss\xe3o de dados do TFMini na Odroid para a PX4."),(0,r.kt)("h2",{id:"projetos-ja-feitos"},"Projetos ja feitos:"),(0,r.kt)("h2",{id:"distance-sensor-externo-a-fcu-tfmini"},"Distance sensor externo a FCU (TFMini)"),(0,r.kt)("h3",{id:"driver-tfmini"},"Driver TFMini"),(0,r.kt)("p",null,"O TFMini por ser serial foi conectado ao GPIO da Odroid xu4, mais precisamente nos pinos 4 e 6, respectivamente RX e TX da Odroid.\nPara fazer a leitura dos dados do GPIO foi utilizada a biblioteca Odroid Wiring Pi."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Python"},"#!/usr/bin/env python\nimport odroid_wiringpi as wpi\nimport time\n")),(0,r.kt)("p",null,'No c\xf3digo ent\xe3o foi criado uma classe "TFMini", p/ que ela possa ser utilizada facilmente em outros c\xf3digos, precisando apenas ser incluida e inicializada.'),(0,r.kt)("p",null,"A conex\xe3o com o TFMini fica dentro do construtor, onde ele abre a porta serial em que est\xe1 conectado fisicamente o TFMini e declara a Baudrate; e \xe9 encerrada a conex\xe3o em seu destrutor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Python"},"class tfmini:\n\n    def __init__(self):\n        self.serial = wpi.serialOpen('/dev/ttySAC0', 115200)\n\n    def __del__(self):              \n        wpi.serialClose(self.serial)    \n")),(0,r.kt)("p",null,"O m\xe9todo medir fica respons\xe1vel por pegar as informa\xe7\xf5es recebidas pela serial, onde ele transforma os respectivos bits recebidos em cada pacote em sua informa\xe7\xe3o, cujos valores e significados est\xe3o no datasheet do sensor."),(0,r.kt)("p",null,"Tamb\xe9m existe uma main, por\xe9m ela roda apenas quando o script \xe9 rodado direto."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python="},"    def medir(self):\n        cont = 0\n        cont2 = 0\n        cont3 = 0\n        distancia = -1\n        strenght = -1\n        bit3 = 0\n        bit4 = 0\n        bit5 = 0\n        bit6 = 0\n        wpi.serialFlush(self.serial)\n        while cont < 9:\n            output = wpi.serialGetchar(self.serial)\n            cont += 1\n            if cont == 3 or cont == 4:\n                #print(output)\n                cont2 += 1\n\n                #Leitura de bits ( 3 e 4 distance, 5 e 6 strenght )\n                if cont == 3:\n                    bit3 = output\n                if cont == 4:\n                    bit4 = output\n\n                # Calcular distance\n                if cont2 == 2:\n                    cont2 = 0\n                    distancia = bit3 + ( bit4 * 256 )\n\n            if cont == 5 or cont == 6:\n                #print(output)\n                cont2 += 1\n\n                #Leitura de bits ( 5 e 6 strenght )\n                if cont == 5:\n                    bit5 = output\n                if cont == 6:\n                    bit6 = output\n                # Calcular distance e strenght\n                if cont2 == 2:\n                    cont2 = 0\n                    strenght = bit5 + ( bit6 * 256 )\n\n        #print('Distance = ' + str(distancia) + ' || Strenght = ' + str(strenght))\n        return [distancia, strenght]                \n\nif __name__ == '__main__':\n    tfmini = tfmini()\n    medidas = tfmini.medir()\n    print('Distance = ' + str(medidas[0]) + ' || Strenght = ' + str(medidas[1]))\n    #print(medidas)\n")),(0,r.kt)("p",null,'Agora, a conex\xe3o com a FCU foi feita atravez de MAVLink, com a biblioteca mavutil, que envia a msg de "distance_sensor", onde estabelecemos a conex\xe3o com a FCU usando o comando "mavlink_connection" da biblioteca mavutil, usando no caso de USB a respectiva porta conectada, a ACM0. Mas caso ele n\xe3o conecte com as portas citadas abaixo, seja qual for a forma de conex\xe3o, ela pode ser detectada utilizando o comando ',(0,r.kt)("inlineCode",{parentName:"p"},"bash dmesg "),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python="},"#!/usr/bin/env python3\n\nfrom pymavlink import mavutil\nimport time\nimport tfmini as lidar\n \nif __name__ == \"__main__\":\n    #Telemetria:\n    mav = mavutil.mavlink_connection(\"/dev/ttyUSB0\", autoreconnect=True, baud=57600)\n\n    #USB:\n    #mav = mavutil.mavlink_connection(\"/dev/ttyACM0\", autoreconnect=True, baud=57600)\n\n    #Gazebo:\n    #mav = mavutil.mavlink_connection('udpin:localhost:1450')\n\n    print(\"Conectou\")\n\n    for i in range(3):\n        print(\"Testando:\")\n        print(mav.wait_heartbeat())\n        time.sleep(1)\n    \n    tfmini = lidar()\n    \n    while(True):\n        distance = tfmini.medir()\n        #'time_boot_ms', 'min_distance', 'max_distance', 'current_distance', 'type', 'id', 'orientation', and 'covariance'\n        mav.mav.distance_sensor_send(10, 20, 1200, distance, 0, 0, 25, 255)\n        print(\"SENT\")\n        #print(dir(mav.mav.distance_sensor_send()))\n    \n")))}u.isMDXComponent=!0}}]);