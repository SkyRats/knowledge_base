"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[8919],{3905:function(e,a,o){o.d(a,{Zo:function(){return d},kt:function(){return v}});var n=o(7294);function s(e,a,o){return a in e?Object.defineProperty(e,a,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[a]=o,e}function r(e,a){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),o.push.apply(o,n)}return o}function t(e){for(var a=1;a<arguments.length;a++){var o=null!=arguments[a]?arguments[a]:{};a%2?r(Object(o),!0).forEach((function(a){s(e,a,o[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(o,a))}))}return e}function i(e,a){if(null==e)return{};var o,n,s=function(e,a){if(null==e)return{};var o,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)o=r[n],a.indexOf(o)>=0||(s[o]=e[o]);return s}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)o=r[n],a.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(s[o]=e[o])}return s}var l=n.createContext({}),u=function(e){var a=n.useContext(l),o=a;return e&&(o="function"==typeof e?e(a):t(t({},a),e)),o},d=function(e){var a=u(e.components);return n.createElement(l.Provider,{value:a},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},p=n.forwardRef((function(e,a){var o=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=u(o),p=s,v=m["".concat(l,".").concat(p)]||m[p]||c[p]||r;return o?n.createElement(v,t(t({ref:a},d),{},{components:o})):n.createElement(v,t({ref:a},d))}));function v(e,a){var o=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var r=o.length,t=new Array(r);t[0]=p;var i={};for(var l in a)hasOwnProperty.call(a,l)&&(i[l]=a[l]);i.originalType=e,i[m]="string"==typeof e?e:s,t[1]=i;for(var u=2;u<r;u++)t[u]=o[u];return n.createElement.apply(null,t)}return n.createElement.apply(null,o)}p.displayName="MDXCreateElement"},4187:function(e,a,o){o.r(a),o.d(a,{contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return d}});var n=o(7462),s=o(3366),r=(o(7294),o(3905)),t=["components"],i={},l="Workshop de Programa\xe7\xe3o Orientada a Objetos",u={unversionedId:"old/Software/POO/oo_cpp_python",id:"old/Software/POO/oo_cpp_python",isDocsHomePage:!1,title:"Workshop de Programa\xe7\xe3o Orientada a Objetos",description:"1 Paradigmas de Programa\xe7\xe3o",source:"@site/../docs/old/Software/POO/oo_cpp_python.md",sourceDirName:"old/Software/POO",slug:"/old/Software/POO/oo_cpp_python",permalink:"/knowledge_base/docs/old/Software/POO/oo_cpp_python",editUrl:"https://github.com/SkyRats/knowledge_base/tree/main/docs/../docs/old/Software/POO/oo_cpp_python.md",tags:[],version:"current",frontMatter:{},sidebar:"docssidebar",previous:{title:"V\xf4o Aut\xf4nomo",permalink:"/knowledge_base/docs/old/Software/VooAutonomo"},next:{title:"Guia dos Componentes",permalink:"/knowledge_base/docs/old/not_used/Componentes"}},d=[{value:"1 Paradigmas de Programa\xe7\xe3o",id:"1-paradigmas-de-programa\xe7\xe3o",children:[],level:2},{value:"2 B\xe1sicos de C++",id:"2-b\xe1sicos-de-c",children:[{value:"2.1 CIN e COUT",id:"21-cin-e-cout",children:[],level:3},{value:"2.2 String",id:"22-string",children:[],level:3}],level:2},{value:"3 Conceitos B\xe1sicos de OO",id:"3-conceitos-b\xe1sicos-de-oo",children:[{value:"3.1 Classe",id:"31-classe",children:[],level:3},{value:"3.2 Objetos",id:"32-objetos",children:[],level:3},{value:"3.3 Atributos",id:"33-atributos",children:[],level:3},{value:"3.4 M\xe9todos",id:"34-m\xe9todos",children:[],level:3},{value:"3.4 Revis\xe3o de Ponteiros (&quot;-&gt;&quot; ou &quot;.&quot;?, e NULL)",id:"34-revis\xe3o-de-ponteiros---ou--e-null",children:[],level:3}],level:2},{value:"4 Encapsulamento",id:"4-encapsulamento",children:[{value:"4.1 Private",id:"41-private",children:[],level:3},{value:"4.2 Public",id:"42-public",children:[],level:3},{value:"4.3 Protected",id:"43-protected",children:[],level:3},{value:"4.4 Headers(.h e .hpp) e Sources(.cpp)",id:"44-headersh-e-hpp-e-sourcescpp",children:[],level:3},{value:"4.5 &quot;#ifndef - #endif&quot; e &quot;#define&quot;",id:"45-ifndef---endif-e-define",children:[],level:3}],level:2},{value:"5 Getters e Setter",id:"5-getters-e-setter",children:[],level:2},{value:"6 Construtor e Destrutor",id:"6-construtor-e-destrutor",children:[{value:"6.1 Construtor",id:"61-construtor",children:[],level:3},{value:"6.2 Destrutor",id:"62-destrutor",children:[],level:3}],level:2},{value:"7 Vetor de Objetos",id:"7-vetor-de-objetos",children:[],level:2},{value:"8 Heran\xe7a e Polimorfismo",id:"8-heran\xe7a-e-polimorfismo",children:[{value:"8.1 O que \xe9 um filho",id:"81-o-que-\xe9-um-filho",children:[],level:3},{value:"8.2 Princ\xedpio da Substitui\xe7\xe3o",id:"82-princ\xedpio-da-substitui\xe7\xe3o",children:[],level:3},{value:"8.3 Protected",id:"83-protected",children:[],level:3}],level:2},{value:"9 Informa\xe7\xf5es a mais",id:"9-informa\xe7\xf5es-a-mais",children:[{value:"9.1 Const",id:"91-const",children:[],level:3},{value:"9.2 Virtual",id:"92-virtual",children:[],level:3},{value:"9.3 Namespace e STD",id:"93-namespace-e-std",children:[],level:3}],level:2},{value:"1 Conceitos B\xe1sicos de OO",id:"1-conceitos-b\xe1sicos-de-oo",children:[],level:2},{value:"2 Criando a Classe",id:"2-criando-a-classe",children:[],level:2},{value:"3 Heran\xe7a",id:"3-heran\xe7a",children:[],level:2},{value:"4 Organiza\xe7\xe3o dos Arquivos",id:"4-organiza\xe7\xe3o-dos-arquivos",children:[],level:2},{value:"5 Saiba Mais hihih",id:"5-saiba-mais-hihih",children:[{value:"5.1 Objetos em python",id:"51-objetos-em-python",children:[],level:3},{value:"5.2 M\xe9todos especiais",id:"52-m\xe9todos-especiais",children:[],level:3},{value:"5.3 Encapsulamento",id:"53-encapsulamento",children:[],level:3}],level:2}],m={toc:d},c="wrapper";function p(e){var a=e.components,o=(0,s.Z)(e,t);return(0,r.kt)(c,(0,n.Z)({},m,o,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"workshop-de-programa\xe7\xe3o-orientada-a-objetos"},"Workshop de Programa\xe7\xe3o Orientada a Objetos"),(0,r.kt)("h2",{id:"1-paradigmas-de-programa\xe7\xe3o"},"1 Paradigmas de Programa\xe7\xe3o"),(0,r.kt)("p",null,'Paradigma \xe9 o jeito que a linguagem de programa\xe7\xe3o \xe9 programada, por exemplo, o que voc\xeas viram no workshop de introdu\xe7\xe3o era o paradigama imperativo, onde voc\xea manda um "passo a passo" para o programa rodar.'),(0,r.kt)("p",null,"Agora, o que vamos aprender \xe9 o paradigma de orienta\xe7\xe3o a objetos, em que vai surgir a ideia de classes e objetos, que v\xe3o ser um n\xedvel de abstra\xe7\xe3o a mais!"),(0,r.kt)("h2",{id:"2-b\xe1sicos-de-c"},"2 B\xe1sicos de C++"),(0,r.kt)("p",null,"Depois do workshop de introdu\xe7\xe3o a programa\xe7\xe3o voc\xeas j\xe1 devem estar brabos em C e python hehe ent\xe3o aqui temos umas novidades da linguagem C++ (que \xe9 o C com MAIS MAIS coisas)."),(0,r.kt)("h3",{id:"21-cin-e-cout"},"2.1 CIN e COUT"),(0,r.kt)("p",null,"Essas s\xe3o as fun\xe7\xf5es de impress\xe3o e leitura do C++! "),(0,r.kt)("p",null,"Em C para usar os famosos printf e scanf era necess\xe1rio dar o ",(0,r.kt)("inlineCode",{parentName:"p"},"#include <stdio.h>"),", agora aqui em C++ para usar o cin (C in) e cout (C out), de ",(0,r.kt)("inlineCode",{parentName:"p"},"#include <iostream>"),"."),(0,r.kt)("p",null,"A fun\xe7\xe3o cin substitui o scanf, com ela podemos pegar dados do nosso teclado e atribui-los a uma vari\xe1vel."),(0,r.kt)("p",null,"A fun\xe7\xe3o cout substitui o printf, com ela podemos imprimir coisas no monitor."),(0,r.kt)("p",null,"Mas pera ai, se o C++ \xe9 um complemento do C, eu ainda posso usar o printf e scanf?? "),(0,r.kt)("p",null,'Sim!! Voc\xea pode continuar usando, mas os desenvolvedores criaram essas novas fun\xe7\xf5es para serem mais intuitvas, pois nelas o fluxo que o dado percorre \xe9 mostrado com o "<<".'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Obs: o "endl" (end line) pula uma linha, assim como o "\\n".')),(0,r.kt)("p",null,"Exemplo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\nusing namespace std;\n        \nint main(){\n    int minhaIdade;\n    cin >> minhaIdade;\n    cout << "Tenho " << minhaIdade << " anos!" << endl;\n}\n\n>>> ./SkyratsIostream.exe\n>>> 19  //deixar de outra cor eh o fuco\n>>> Tenho 19 anos!\n>>> \n')),(0,r.kt)("h3",{id:"22-string"},"2.2 String"),(0,r.kt)("p",null,"Existe uma biblioteca chamada string.h, com ela voc\xea pode representar palavras, frases ou textos, sem ter que usar o tal do Char. A string \xe9 como se fosse um vetor de caracteres, mas muito mais simples, por exemplo, o programa a seguir:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n    string frase = "A skyrats \xe9 a melhor equipe da POLI!";\n    cout << frase << endl;\n}\n\nVai ter como sa\xedda isso:\n>>> ./SkyratsString.exe\n>>> A skyrats \xe9 a melhor equipe da POLI!\n>>>\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Obs: Para usar o "cin e cout" e as "strings" \xe9 necessa\xe1rio al\xe9m da inclus\xe3o das respectivas bibliotecas o uso do namespaece "std" que ser\xe1 explicado mais pra frente do porqu\xea.')),(0,r.kt)("h2",{id:"3-conceitos-b\xe1sicos-de-oo"},"3 Conceitos B\xe1sicos de OO"),(0,r.kt)("p",null,"A programa\xe7\xe3o orientada a objeto veio para abstrair a realidade! Nela transformamos conceitos da vida real em classes e m\xe9todos, visando simplificar a implementa\xe7\xe3o de algumas coisas. "),(0,r.kt)("p",null,"Pra voc\xea que ta criando o c\xf3digo, o trampo ainda \xe9 grande, mas quem for usar ele vai te agradecer bastante."),(0,r.kt)("h3",{id:"31-classe"},"3.1 Classe"),(0,r.kt)("p",null,"A classe vai ser um molde com diversas caracteristicas.\nPor exemplo, podemos criar a classe pizza que ter\xe1 um atributo que indica o seu sabor e outro que indica a quantidade de fatias que ela tem."),(0,r.kt)("h3",{id:"32-objetos"},"3.2 Objetos"),(0,r.kt)("p",null,"O objeto \xe9 a inst\xe2ncia da classe, ou seja, se usarmos o molde(classe) da pizza, podemos criar diversas pizzas(objeto) e todas elas ter\xe3o um sabor(atributo) e uma quantidade de fatias(atributo)."),(0,r.kt)("h3",{id:"33-atributos"},"3.3 Atributos"),(0,r.kt)("p",null,"S\xe3o as propriedades e estados de uma classe."),(0,r.kt)("h3",{id:"34-m\xe9todos"},"3.4 M\xe9todos"),(0,r.kt)("p",null,'S\xe3o a implementa\xe7\xe3o dos servi\xe7os disponibilizados pelos objetos.\nPodemos criar para a classe pizza o met\xf3do "retirar_fatia()", agora podemos diminuir o numero de fatias que ela tem por meio de um m\xe9todo! '),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <string>\nusing namespace std;\n\nclass Pizza{//Classe\npublic:\n    void retirar_fatia(){ //M\xe9todo\n        fatias--;\n    }\n\nprivate:\n    string sabor;//Atributo\n    int fatias;//Atributo\n};\n\n  int main(){\n      Pizza *pizza1;//Cria\xe7\xe3o de um objeto Pizza\n  }\n")),(0,r.kt)("h3",{id:"34-revis\xe3o-de-ponteiros---ou--e-null"},'3.4 Revis\xe3o de Ponteiros ("->" ou "."?, e NULL)'),(0,r.kt)("p",null,'O ponteiro \xe9 uma vari\xe1vel que guarda um endere\xe7o de mem\xf3ria. Por exemplo, um ponteiro para o "int valor", ser\xe1 algo parecido com 0x6453.\nPara declarar um ponteiro, \xe9 so colocar um "*", desse jeito:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int *x;\ncout << x << endl;\n\nSa\xedda:\n>>> ./Ponteiro.exe\n>>> 0x32a57c\n>>>\n")),(0,r.kt)("p",null,'E se quisermos pegar o endere\xe7o de uma vari\xe1vel ja existente? Usa o "&", desse jeito:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int x = 10;\ncout << &x << " - " << x << endl;\n\nSa\xedda:\n>>> ./Ponteiro2.exe\n>>> 0x7b65d2 - 10\n>>>\n')),(0,r.kt)("p",null,'Mas e agora, e se quisermos ir at\xe9 a vari\xe1vel tendo o endere\xe7o dela? Usaremos tamb\xe9m o "*", desse jeito:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int x = 10;\nint* y = &x;\ncout << x << " - " << *y << endl;\n\nSa\xedda:\n>>> ./Ponteiro3.exe\n>>> 10 - 10\n>>>\n')),(0,r.kt)("p",null,"Certo, sabendo disso podemos agora falar como isso tudo de ponteiros interfere em objetos."),(0,r.kt)("p",null,"Um objeto n\xe3o deixa de ser uma vari\xe1vel, ele s\xf3 possui um n\xedvel de abstra\xe7\xe3o a mais. Logo, podemos criar vari\xe1veis para guardar objetos e pegar seus endere\xe7os guardando em ponteiros."),(0,r.kt)("p",null," Tome cuidado, pois ao mesmo tempo que existe coisas para facilitar, de come\xe7o pode confundir um pouco."),(0,r.kt)("p",null,"Quando vamos criar uma vari\xe1vel para guardar um objeto, fazemos igual em um INT, por exemplo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Carro celtinha;\n")),(0,r.kt)("p",null," Desse jeito eu criei uma vari\xe1vel do tipo carro com o nome celtinha."),(0,r.kt)("p",null,"  Mas tem uma coisa, objetos funcionam igual vari\xe1veis, certo? "),(0,r.kt)("p",null,"  SIM! Ent\xe3o saindo de algum escopo ele tamb\xe9m deixa de existir? "),(0,r.kt)("p",null,"  SIM! Mas temos como resolver isso, que \xe9 atrav\xe9s dos ponteiros! Pois se usarmos continuamente o endere\xe7o na qual o objeto est\xe1 ele n\xe3o vai deixar de existir, e assim podemos trabalhar de uma forma mais ampla com ele, podemos fazer assim: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Carro* celtinha;\n")),(0,r.kt)("p",null,'  E nesse ponteiro celtinha, vamos guardar o ponteiro que aponta para o objeto, MAS PRESTE ATEN\xc7\xc3O!!! Devemos tomar MUITO cuidado em como vamo chamar os m\xe9todos e atributos. Assim, se temos apenas um objeto("Carro celtinha;), chamamos os m\xe9todos e atributos usando ".", por exemplo:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'Carro celtinha = Carro(); //Esse m\xe9todo \xe9 um construtor, n\xe3o se preocupe com ele agora, vamos explicar mais para a frente, apenas saiba que estamos colocando um objeto do tipo Carro na vari\xe1vel\nceltinha.buzinar(); // Esse m\xe9todo retorna no terminal a buzina\ncout << "Ano do carro: " << celtinha.ano << endl; // Aqui ele chama o atributo que guarda o ano do carro\n\nSa\xedda:\n>>> ./PonteiroCeltinha.exe\n>>> Biiii Biiiiiii\n>>> Ano do carro: 2006\n>>>\n')),(0,r.kt)("p",null,"Mas agora, se vamos guardar um objeto numa vari\xe1vel de ponteiro, teremos que chamar os m\xe9todos e atributos desreferenciando o ponteiro, assim: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"(*celtinha).buzinar(); \n")),(0,r.kt)("p",null,'Mas em C++ existe uma coisa que facilita muito mais do que ficar desreferenciando o ponteiro toda hora, que \xe9 so usar uma setinha("->"), assim, podemos chamar o m\xe9todo desse jeito:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"celtinha->buzinar();\n")),(0,r.kt)("p",null,"Exemplo completo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'Carro celtinha = Carro();\nCarro *ponteiroCeltinha = &celtinha;\n\n(*ponteiroCeltinha).buzinar();\nponteiroCeltinha->buzinar();\n\ncout << "Ano do carro: " << (*ponteiroCeltinha).ano << endl;\ncout << "Ano do carro: " << ponteiroCeltinha->ano << endl;\n\nSa\xedda:\n>>> ./PonteiroCeltinha.exe\n>>> Biiii Biiiiiii\n>>> Biiii Biiiiiii\n>>> Ano do carro: 2006\n>>> Ano do carro: 2006\n>>>\n')),(0,r.kt)("p",null,'E mais uma \xfaltima coisa! E se quisermos guardar um "nada" dentro de um ponteiro, como fazemos?'),(0,r.kt)("p",null,' Usamos "NULL", assim o ponteiro n\xe3o estar\xe1 apontando para nenhum lugar.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Carro *ponteiroCeltinha = NULL;\nponteiroCeltinha->buzinar();\nSa\xedda:\n>>> ./PonteiroCeltinha.exe\n>>>\n")),(0,r.kt)("h2",{id:"4-encapsulamento"},"4 Encapsulamento"),(0,r.kt)("p",null,"Encapsulamento \xe9 indicar quem tem acesso a um m\xe9todo ou atributo."),(0,r.kt)("h3",{id:"41-private"},"4.1 Private"),(0,r.kt)("p",null,'Os atributos e m\xe9todos "encapsulados" dentro do "private", s\xf3 podem ser acessados dentro de m\xe9todos da pr\xf3pria classe, nem mesmo de classes filhas, coisas que veremos mais para a frente.'),(0,r.kt)("h3",{id:"42-public"},"4.2 Public"),(0,r.kt)("p",null,'Os atributos e m\xe9todos "encapsulados" dentro do "public", podem ser acessados em qualquer lugar, seja na main, em m\xe9todos de outras classes, etc...'),(0,r.kt)("h3",{id:"43-protected"},"4.3 Protected"),(0,r.kt)("p",null,'Os atributos e m\xe9todos "encapsulados" dentro do "protected", tem acesso parecido com os encapsulados em "private", mas neste, m\xe9todos e atributos podem ser acessados apenas por ela mesma e por classes filhas (explicadas mais para frente). '),(0,r.kt)("h3",{id:"44-headersh-e-hpp-e-sourcescpp"},"4.4 Headers(.h e .hpp) e Sources(.cpp)"),(0,r.kt)("p",null,"Uma das grandes vantagens da OO \xe9 a modulariza\xe7\xe3o dos c\xf3digos, ou seja, cada parte pode ser compilada individualmente. Na pr\xe1tica isso significa que caso seja feito uma pequena altera\xe7\xe3o, s\xf3 precisamos compilar o c\xf3digo modificado. "),(0,r.kt)("p",null,"Al\xe9m disso, uma boa pr\xe1tica \xe9 criar arquivos diferentes para a defini\xe7\xe3o e implementa\xe7\xe3o de uma classe."),(0,r.kt)("p",null,"O arquivo de defini\xe7\xe3o \xe9 o Header (.h) e (.hpp)."),(0,r.kt)("p",null,"O arquivo de implementa\xe7\xe3o \xe9 o Source (.cpp)"),(0,r.kt)("p",null,"Ex: Rel\xf3gio.h"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Relogio{\n    private:\n        int hora;\n        int minuto;\n    public:\n        int getHora();\n        int getMinuto();\n};\n\n")),(0,r.kt)("p",null,"Ex: Rel\xf3gio.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include "Relogio.h"\n\nint Relogio::getHora(){\n    return hora;\n}\n\nint Relogio::getMinuto(){\n    return minuto;\n}\n\n')),(0,r.kt)("h3",{id:"45-ifndef---endif-e-define"},'4.5 "#ifndef - #endif" e "#define"'),(0,r.kt)("p",null,"Quando programamos \xe9 normal incluirmos varios arquivos no inicio do programa, por\xe9m no meio desse monte de inclus\xe3o \xe9 muito f\xe1cil acabarmos incluindo o mesmo Header mais de uma vez, pois dentro de classes incluimos outras classes, o que pode ocasionar em um erro de definirmos multiplas vezes a mesma coisa. "),(0,r.kt)("p",null,"Para evitar isso, \xe9 recomendado que sempre que criarmos um Header usarmos o modelo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#ifndef CLASSE_H        // Se a classe n\xe3o estiver definida\n#define CLASSE_H        // Define a classe\n\nclass Classe{\n    ...\n};\n\n#endif                  //Fim do ifndef\n")),(0,r.kt)("h2",{id:"5-getters-e-setter"},"5 Getters e Setter"),(0,r.kt)("p",null,"Normalmente na programa\xe7\xe3o orientada a objetos, os atributos ser\xe3o privados por uma quest\xe3o de seguran\xe7a, e para outras classes poderem acessa-los usaremos os m\xe9todos (normalmente p\xfablicos) getters e setters."),(0,r.kt)("p",null,"Os getter s\xe3os m\xe9todos usados para retornar valores de atributos, e os setters para aplicar valores neles. Como \xe9 bem simples, com o exemplo \xe9 entend\xedvel sua utilidade:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class Carro{\n    public:\n        int getCombustivel(){\n            return combustivel;\n        }\n        void setCombustivel(int valor){\n            combustivel = valor;\n        }\n    private:\n        int combustivel;\n};\n\nint main() {\n    Carro Celtinha = Carro();\n    Celtinha.setCombustivel(30);\n    cout << "Combustivel: " << Celtinha.getCombustivel() << endl;\n}    \n\nTem como sa\xedda:\n>>> ./Celtinha.exe\n>>> Combust\xedvel: 30\n')),(0,r.kt)("h2",{id:"6-construtor-e-destrutor"},"6 Construtor e Destrutor"),(0,r.kt)("h3",{id:"61-construtor"},"6.1 Construtor"),(0,r.kt)("p",null,"O construtor \xe9 a primeira fun\xe7\xe3o que \xe9 executada quando instanciamos um objeto, nela ser\xe3o iniciadas alguns atributos.\nExistem duas principais formas de fazer esse processo:"),(0,r.kt)("p",null,"Aloca\xe7\xe3o Din\xe2mica: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Carro* Celtinha = new Carro();\n")),(0,r.kt)("p",null,'Ele cria um objeto e atribui seu "Ponteiro" dinamicamente, ou seja, a vari\xe1vel ser\xe1 mantida mesmo depois do fechamento de escopo, assim, precisa ser desalocada manualmente. '),(0,r.kt)("p",null,"Aloca\xe7\xe3o Est\xe1tica:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Carro* Celtinha = &(Carro());\n")),(0,r.kt)("p",null,"Aqui a o ponteiro do objeto constru\xeddo \xe9 atribu\xeddo \xe0 vari\xe1vel Celtinha, e por ser aloca\xe7\xe3o est\xe1tica, ele n\xe3o precisa ser destru\xeddo manualmente, embora seja poss\xedvel."),(0,r.kt)("p",null,"Quando estamos fazendo a classe podemos escrever um c\xf3digo para o construtor, e nisso podemos setar valores, criar vari\xe1veis, dar uns couts, uns cins, e fazer todo o poss\xedvel para uma fun\xe7\xe3o normal, para isso devemos criar um m\xe9todo com o nome da pr\xf3pria classe."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Obs: Usamos o "this->" para nos referirmos a um atributo ou m\xe9todo do objeto que o chamou. Podemos assim diferenciar coisas com o mesmo nome.')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class carro{\n    public:\n        carro(string nome, int ano){\n            this->nome = nome; //O "this->nome" se refere ao atributo da classe.\n            this->ano = ano;\n            cout << "Carro " << nome << " do ano " << ano << " constru\xeddo!!!" << endl;\n        }\n\n    private:\n        string nome; //Atributo\n        int ano;\n};\n\nint main() {\n    carro Celtinha = carro("Celta", 2006);\n}  \n\nSa\xedda:\n>>> ./ConstrutorDoCeltinha.exe\n>>> Carro Celta do ano 2006 constru\xeddo!!!\n')),(0,r.kt)("h3",{id:"62-destrutor"},"6.2 Destrutor"),(0,r.kt)("p",null,'Se voc\xea criou um objeto, ele vai ocupar espa\xe7o na mem\xf3ria! Portanto, \xe9 bom sabermos que podemos destru\xed-los, e para isso usamos o comando "delete", e esse comando chama o destrutor, uma fun\xe7\xe3o bemmm parecida com o construtor, s\xf3 que com um til atr\xe1s, "~NomeDaClasse()", ele funciona assim:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class Comida{\n    public:\n        Comida(string nome, bool vencida){\n            this->nome = nome;\n            this->vencida = vencida;\n        }\n        ~Comida(){\n            if(vencida == true)\n                cout << "Parab\xe9ns!, voc\xea jogou sua(seu) " << nome << " vencida(o) fora!" << endl;\n            else\n                cout << "Que feio! voc\xea jogou sua(seu) " << nome << " nova(o) fora! N\xe3o desperdice comida >:"\n        }\n    private:\n        string nome;\n        bool vencida;\n}\n\nint main(){\n    Comida* cenoura = new Comida("Cenoura", true);\n    Comida* beringela = new Comida("Beringela", false);\n    delete cenoura;\n    delete beringela;\n}\n\nSa\xedda:\n>>> ./Comida.exe\n>>> Parab\xe9ns!, voc\xea jogou sua(seu) Cenoura vencida(o) fora!\n>>> Que feio! voc\xea jogou sua(seu) Beringela nova(o) fora! N\xe3o desperdice comida >:\n')),(0,r.kt)("h2",{id:"7-vetor-de-objetos"},"7 Vetor de Objetos"),(0,r.kt)("p",null,"Em C++, podemos criar vetores de vari\xe1veis simples, como: INTs, FLOATs... e PONTEIROS! Mas tamb\xe9m podemos criar um vetor de objetos, guardando em cada posi\xe7\xe3o do vetor um ponteiro para esse objeto, e podemos fazer isso de duas formas, est\xe1ticamente ou dinamicamente:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'Construcao* predios[tamanho]; //Est\xe1tica\npredios[2] = PredioAzul;\nif(predios[2] == PredioAzul) cout << "Deu certo!" << endl;\n\nConstrucao** predios2 = new Construcao*[tamanho];\npredios2[2] = PredioAzul;\nif(predios2[2] == PredioAzul) cout << "Deu certo!" << endl;\n\n>>> ./Predios.exe\n>>> Deu certo!\n>>> Deu certo!\n>>> \n')),(0,r.kt)("p",null,'Obs: Para destruir vetores din\xe2micos, j\xe1 que ele n\xe3o deixa de ser um tipo de objeto, voc\xea usa o "delete[] nomeDoVetor;".'),(0,r.kt)("h2",{id:"8-heran\xe7a-e-polimorfismo"},"8 Heran\xe7a e Polimorfismo"),(0,r.kt)("h3",{id:"81-o-que-\xe9-um-filho"},"8.1 O que \xe9 um filho"),(0,r.kt)("p",null,"Ter filhos... \xc9 quando voc\xea cria uma classe a partir de outra, l\xf3gico..."),(0,r.kt)("p",null,"Lembrem-se: USEM PROTE\xc7\xc3O!!! Coloquem os atributos em private..."),(0,r.kt)("p",null,"Quando voc\xea cria uma classe filha de uma outra, essa classe filha vai herdar todas as caracter\xedsticas da classe pai, m\xe9todos, atributos, etc... E al\xe9m disso voc\xea pode colocar mais coisas ainda. \xc9 mais f\xe1cil de entender com exemplo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <string>\n#include <iostream>\n\nusing namespace std;\n\n    class Pessoa {\n        public:\n            Pessoa(string nome, int idade){\n                this->nome = nome;\n                this->idade = idade;\n            }\n        protected:\n            string nome;\n            int idade;\n    };\n\n    class Bento : public Pessoa { //Para indicarmos que a classe \xe9 Bento \xe9 filha de Pessoa\n        public:\n            Bento(string nome, int idade, bool Politreco) : Pessoa("Bento", idade) { // Colocamos o ":" e chamamos o construtor da classe Pai e mandamos nesse construtor os atributos que v\xe3o para a classe Pai\n                this->Politreco = Politreco;\n            }\n            void bentoPolitreco() {\n                if(Politreco)\n                    cout << "Bento eh politreco" << endl;\n                else\n                    cout << "Bento nao eh politreco" << endl;\n            }\n        private:\n            bool Politreco;\n    };\n\n    int main() {\n        Bento* bento = new Bento("Bento", 19, true);\n        bento->bentoPolitreco();\n    }\n\nSa\xedda:\n>>> ./Bento.exe\n>>> Bento eh politreco\n>>>\n')),(0,r.kt)("h3",{id:"82-princ\xedpio-da-substitui\xe7\xe3o"},"8.2 Princ\xedpio da Substitui\xe7\xe3o"),(0,r.kt)("p",null,"Se F \xe9 filha de P, os objetos  do tipo F devem se comportar com P caso sejam tratados como P."),(0,r.kt)("p",null,"Ou seja, o filho tem tudo que o pai tem, ent\xe3o se usarmos o filho tratando ele como pai, deve se comportar como pai."),(0,r.kt)("p",null,"Pensa assim, se voc\xea usar o C++ pensando que ta programando em C, ele vai se comportar igualzinho como C!"),(0,r.kt)("h3",{id:"83-protected"},"8.3 Protected"),(0,r.kt)("p",null,'Agora que sabemos o que s\xe3o filhos e pais no meio do OO, podemos entender o encapsulamento Protected, que como explicado antes, funciona igual o "Private", mas a diferen\xe7a \xe9 que ele pode ser acessado pelos filhos, por exemplo, se eu tenho uma classe Pai, com um atributo Private Nome e um Protected Idade, e uma classe Filha de Pai, se nela chamarmos o atributo Nome, daria erro de compila\xe7\xe3o, ja se chamassemos o atributo Idade n\xe3o, por outro lado, se estivessemos em uma outra classe, sem rela\xe7\xe3o com as duas, daria erro de compila\xe7\xe3o se chamassemos os dois atributos.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Pai{               //01\n    private:             //02\n        string Nome;     //03\n    protected:           //04\n        int Idade;       //05\n    };                   //06\nclass Filho{             //07\n    public:              //08\n        int getIdade{    //09\n            return idade;//10\n        }                //11\n        string getNome{  //12\n            return nome; //13\n        }                //14\n    };                   //15\nint main(){              //16\n    Pai pai = Pai();     //17\n    cout << pai.Nome << endl; //18\n    cout << pai.Idade << endl;//19\n    return 0;            //20\n}\nSa\xedda:\n>>> gcc -c Protected.c\n>>> Erro nas linhas 10, 18 e 19\n>>>\n")),(0,r.kt)("h2",{id:"9-informa\xe7\xf5es-a-mais"},"9 Informa\xe7\xf5es a mais"),(0,r.kt)("h3",{id:"91-const"},"9.1 Const"),(0,r.kt)("p",null,"\xc9 possivel criar constantes em C++! Isso pode evitar que durante a implementa\xe7\xe3o de um programa alguem mude algo indevidamente.\nEx:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'const float pi = 3.14\n\nou\n\nconst Lampada *L1 = new Lampada("Branca");\n')),(0,r.kt)("p",null,"Dessa forma, caso mudem o valor de PI ou a cor da lampada, um erro de compila\xe7\xe3o ser\xe1 gerado."),(0,r.kt)("h3",{id:"92-virtual"},"9.2 Virtual"),(0,r.kt)("p",null,"Quando declaramos um m\xe9todo como virtual, no momento da execu\xe7\xe3o, chama o m\xe9todo da pr\xf3pria classe."),(0,r.kt)("p",null,"O programa executa o m\xe9todo com base no tipo\nespec\xedfico do objeto!"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Obs: \xc9 sempre bom declarar todos os m\xe9todos como virtuais, e como obriga\xe7\xe3o declarar todos os destrutores como virtuais, por que tem casos em que certos destrutores n\xe3o s\xe3o chamados.")),(0,r.kt)("p",null,"Exemplo (sem virtual):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'    class Passaro {\n        public: void canta() { cout << "Piuu Piuuu" << endl;}\n    };\n    class Arara : public Passaro {\n        public: void canta() { cout << "Araraaa Araraa" << endl;}\n    };\n    int main(){\n        Passaro* passaro = new Passaro();\n        Passaro* arara = new Arara();\n        passaro->canta();\n        arara->canta();\n        return 0;\n    }\n\nSa\xedda:\n>>> ./Passaros.exe\n>>> Piuu Piuuu\n>>> Piuu Piuuu\n>>> \n')),(0,r.kt)("p",null,"Exemplo (com virtual):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'    class Passaro {\n        public: virtual void canta() { cout << "Piuu Piuuu" << endl;}\n    };\n    class Arara : public Passaro {\n        public: virtual void canta() { cout << "Araraaa Araraa" << endl;}\n    };\n    int main(){\n        Passaro* passaro = new Passaro();\n        Passaro* arara = new Arara();\n        passaro->canta();\n        arara->canta();\n        return 0;\n    }\n\nSa\xedda:\n>>> ./Passaros.exe\n>>> Piuu Piuuu\n>>> Araraaa Araraa\n>>> \n')),(0,r.kt)("h3",{id:"93-namespace-e-std"},"9.3 Namespace e STD"),(0,r.kt)("p",null,"Namespaces s\xe3o jeitos de n\xe3o se repetirem nomes ao usar vari\xe1veis, por exemplo, se voc\xea cria um namespace para uma class X, toda vez que voc\xea for usar alguma coisa dessa classe, voc\xea ter\xe1 que indicar o namespace, por exemplo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'namespace UM {\n    class UM {\n        void metodoUm(){}\n    }\n}\n***Em outro arquivo...***\n#include "UM.h"\n\nusing namespace UM; //Aqui voc\xea indica o namespace usado com o "using"\n\nint main(){\n    metodoUm();\n    return 0;\n}\n***Em outro arquivo...***\n#include "UM.h"\n\nint main(){\n    UM::metodoUm(); //Aqui voc\xea indica o namespace usado com o "::"\n    return 0;\n}\n')),(0,r.kt)("p",null,'Por isso que temos que usar o "using namespace std;" pois assim n\xe3o precisamos escrever em cada COUT ou String o "std::" antes, apenas para facilitar.'),(0,r.kt)("h1",{id:"programa\xe7\xe3o-orientada-a-objeto-em-python"},"Programa\xe7\xe3o Orientada a Objeto em Python"),(0,r.kt)("p",null,"Agora vamos falar um pouco sobre como fazer tudo isso que voc\xeas acabaram em python. Mas antes acho bom falar que tem algumas coisas que s\xe3o consideravelmente diferente (e talvez at\xe9 mais f\xe1cil heheh)"),(0,r.kt)("h2",{id:"1-conceitos-b\xe1sicos-de-oo"},"1 Conceitos B\xe1sicos de OO"),(0,r.kt)("p",null,"As classes, objetos, atributos e m\xe9todos continuam tendo o mesmo conceito que em C++, mas a forma como escrevemos \xe9 diferente j\xe1 que estamos em outra linguagem heheh"),(0,r.kt)("h2",{id:"2-criando-a-classe"},"2 Criando a Classe"),(0,r.kt)("p",null,"Vamos usar o primeiro exemplo usado em C++ e fazer alguma an\xe1lises:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"#!/usr/bin/env python\n\nclass Pizza():\n    def __init__(self, sabor = 'sabor', fatias = 0):\n        self._sabor = sabor\n        self._fatias = fatias\n\n    def retirar_fatia(self):\n        self._fatias -= 1\n")),(0,r.kt)("p",null,"Primeiro, conseguimos perceber a cria\xe7\xe3o do construtor dessa classe, obedecemos o padr\xe3o de ",(0,r.kt)("inlineCode",{parentName:"p"},"__init__(self, a, b)"),". Para criar um objeto com essa classe devemos chamar da seguinte forma:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"pizza1 = Pizza(queijo, 8)\n")),(0,r.kt)("p",null,"Dessa forma, temos um objeto Pizza que possui como sabor queijo e 8 fatias, que s\xe3o seus atributos. Para acess\xe1-los, devemos usar a seguinte nota\xe7\xe3o:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"sabor1 = pizza1._sabor\nfatias1 = pizza1._fatias\n")),(0,r.kt)("p",null,'Uma boa pr\xe1tica ao definir atributos que s\xe3o "privados" \xe9 colocar _ antes do nome desse atributo. Assim, voc\xea consegue identificar lugares no c\xf3digo que n\xe3o \xe9 aconselhado alterar o nome rs.'),(0,r.kt)("p",null,"Agora, falando dos m\xe9todos dessa classe , temos o ",(0,r.kt)("inlineCode",{parentName:"p"},"retirar_fatia(self)"),". Para us\xe1-lo, fazemos de maneira an\xe1loga aos atributos:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"pizza1.retirar_fatias()\n")),(0,r.kt)("h2",{id:"3-heran\xe7a"},"3 Heran\xe7a"),(0,r.kt)("p",null,"Vamos ver o mesmo exemplo que fizemos em C++ em python"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Pessoa():\n    def __init__(self, nome = 'pessoa', idade = 0):\n        self._nome = nome\n        self._idade - idade\n\nclass Bento(Pessoa):\n    def __init__(self, nome = 'pessoa', idade = 0, politreco = False):\n        super().__init__(self, nome, idade)\n        self._politreco = politreco\n\n    def bentoPolitreco():\n        if self._politreco:\n            print(\"Bento eh politreco\")\n        else:\n            print(\"Bento nao eh politreco\")\n")),(0,r.kt)("p",null,"No c\xf3digo podemos dizer que ",(0,r.kt)("inlineCode",{parentName:"p"},"super()")," est\xe1 se referindo a classe superior, ou seja, a classe Pessoa. Outra forma de escrever essa linha de c\xf3digo seria:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"Pessoa.__init__(self, nome, idade)\n")),(0,r.kt)("p",null,"Basicamente, essa \xe9 a nota\xe7\xe3o de Orientado a Objeto para python, mas gostaria de introduzir algumas coisas a mais sem comparar com os exemplos acima e que possa fazer voc\xeas entenderem um pouco melhor as diferen\xe7as at\xe9 agora"),(0,r.kt)("h2",{id:"4-organiza\xe7\xe3o-dos-arquivos"},"4 Organiza\xe7\xe3o dos Arquivos"),(0,r.kt)("p",null,"N\xe3o \xe9 uma regra, mas normalmente organizamos os arquivos que possuem classe separadamente do c\xf3digo de fato que a utiliza. Colocamos a classe e criamos tamb\xe9m uma main, a qual s\xf3 \xe9 chamada se s\xf3 existir aquela main."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'#!/usr/bin/env python\n\nclass Carro():\n    def __init__(self, nome, ano):\n        self._nome = nome\n        self._ano = ano\n        print("Carro" + nome + "do ano" + str(ano) + "constru\xeddo!!!")\n\nif __name__ == \'__main__\':\n    celtinha = Carro("Celta", 2006)  \n')),(0,r.kt)("p",null,"Se apenas rodarmos esse c\xf3digo e implementarmos mais o que est\xe1 dentro de ",(0,r.kt)("inlineCode",{parentName:"p"},"if __name__ == '__main__'"),", isso vai ser considerado a main do c\xf3digo. Caso importarmos essa classe para outro c\xf3digo, ele n\xe3o rodar\xe1 o que est\xe1 dentro dessa suposta main."),(0,r.kt)("h2",{id:"5-saiba-mais-hihih"},"5 Saiba Mais hihih"),(0,r.kt)("h3",{id:"51-objetos-em-python"},"5.1 Objetos em python"),(0,r.kt)("p",null,'Uma coisa que eu n\xe3o contei pra voc\xeas \xe9 que python cria objetos todas as vezes que voc\xea atribui um "valor" para uma vari\xe1vel. Mas como assim?'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},">>> a = [1, 2, 3]\n>>> b = a\n>>> a[0] = 0\n>>> b[0]\n[0, 2, 3]\n")),(0,r.kt)("p",null,"Por que o valor de b tamb\xe9m mudou? Isso aconteceu porque, na verdade, a \xe9 uma refer\xeancia para um objeto que \xe9 o mesmo que b est\xe1 se referenciando."),(0,r.kt)("p",null,"Esse foi um exemplo de um objeto mut\xe1vel em python. Existe objetos imut\xe1veis em python, onde ele n\xe3o altera o valor do objeto que est\xe1 apontando, mas altera para onde ele est\xe1 apontando:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'>>> a = 10\n>>> b = a\n>>> a = a + 1\n>>> b\n10\n>>> a is b #olhar id(a) e id(b)\nFalse \n>>> s = "skyrats"\n>>> t = s\n>>> s += "_s2"\n>>> s\nskyrats_s2\n>>> t\nskyrats\n')),(0,r.kt)("p",null,"Podemos ver os m\xe9todos de objetos que criamos ao atribuir vari\xe1veis com ",(0,r.kt)("inlineCode",{parentName:"p"},"dir(a)")),(0,r.kt)("h3",{id:"52-m\xe9todos-especiais"},"5.2 M\xe9todos especiais"),(0,r.kt)("p",null,"N\xe3o sei se de fato posso chamar de m\xe9todos especiais, mas voc\xea deve ter percebido que a nota\xe7\xe3o do iniciador possui uma nota\xe7\xe3o especial, como tamb\xe9m ao chamar ",(0,r.kt)("inlineCode",{parentName:"p"},"dir(a)"),", aparecem m\xe9todos com essa nota\xe7\xe3o:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class Coordenadas():\n  def __init__(self, x, y): #construtor do objeto a\n    self._x = x\n    self._y = y\n\n  def __str__(self): #usado quando chamamos print(a)\n    return "(" + str(self._x) + "," + str(self._y) + ")"\n\n  def __add__(self, outro): #usado quando somamos os objetos\n    return Coordenadas(self._x + outro._x, self._y + outro._y)\n\n  def __getitem__(self, indice): #podemos pegar itens com a[0]...\n    if indice == 0:\n      return self._x\n    elif indice == 1:\n      return self._y\n    else:\n      raise IndexError ("A coordenada n\xe3o tem este componente")\n\n  def __len__(self): #usado quando chamamos len(a)\n    return 2\n')),(0,r.kt)("p",null,"Existem mais m\xe9todos especiais, esses s\xe3o apenas exemplos"),(0,r.kt)("h3",{id:"53-encapsulamento"},"5.3 Encapsulamento"),(0,r.kt)("p",null,"De fato em python, o c\xf3digo n\xe3o obedece o encapsulamento. Por isso, a boa pr\xe1tica que foi comentado anteriormente de colocar o ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," antes de atributos e m\xe9todos que n\xe3o devem ser alterados, apesar de qualquer um poder alter\xe1-los."),(0,r.kt)("p",null,"Esse \xe9 um dos motivos que h\xe1 diverg\xeancia quando se fala que python n\xe3o \xe9 uma linguagem orientada a objetos."))}p.isMDXComponent=!0}}]);