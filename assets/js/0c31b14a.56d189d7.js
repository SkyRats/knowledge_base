"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[9565],{3905:function(e,o,n){n.d(o,{Zo:function(){return c},kt:function(){return p}});var t=n(7294);function a(e,o,n){return o in e?Object.defineProperty(e,o,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[o]=n,e}function r(e,o){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);o&&(t=t.filter((function(o){return Object.getOwnPropertyDescriptor(e,o).enumerable}))),n.push.apply(n,t)}return n}function l(e){for(var o=1;o<arguments.length;o++){var n=null!=arguments[o]?arguments[o]:{};o%2?r(Object(n),!0).forEach((function(o){a(e,o,n[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(o){Object.defineProperty(e,o,Object.getOwnPropertyDescriptor(n,o))}))}return e}function i(e,o){if(null==e)return{};var n,t,a=function(e,o){if(null==e)return{};var n,t,a={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],o.indexOf(n)>=0||(a[n]=e[n]);return a}(e,o);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],o.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=t.createContext({}),d=function(e){var o=t.useContext(s),n=o;return e&&(n="function"==typeof e?e(o):l(l({},o),e)),n},c=function(e){var o=d(e.components);return t.createElement(s.Provider,{value:o},e.children)},u={inlineCode:"code",wrapper:function(e){var o=e.children;return t.createElement(t.Fragment,{},o)}},m=t.forwardRef((function(e,o){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=d(n),p=a,f=m["".concat(s,".").concat(p)]||m[p]||u[p]||r;return n?t.createElement(f,l(l({ref:o},c),{},{components:n})):t.createElement(f,l({ref:o},c))}));function p(e,o){var n=arguments,a=o&&o.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=m;var i={};for(var s in o)hasOwnProperty.call(o,s)&&(i[s]=o[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var d=2;d<r;d++)l[d]=n[d];return t.createElement.apply(null,l)}return t.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2986:function(e,o,n){n.r(o),n.d(o,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return c},default:function(){return m}});var t=n(7462),a=n(3366),r=(n(7294),n(3905)),l=["components"],i={},s="ttt.py",d={unversionedId:"Tello/ttt",id:"Tello/ttt",isDocsHomePage:!1,title:"ttt.py",description:"Essa p\xe1gina tem o objetivo de explicar o funcionamento do c\xf3digo ttt.py, que permite o usu\xe1rio jogar jogo da velha com o drone Tello.",source:"@site/../docs/Tello/ttt.md",sourceDirName:"Tello",slug:"/Tello/ttt",permalink:"/knowledge_base/docs/Tello/ttt",editUrl:"https://github.com/SkyRats/knowledge_base/tree/main/docs/../docs/Tello/ttt.md",tags:[],version:"current",frontMatter:{},sidebar:"docssidebar",previous:{title:"tello_integration.py",permalink:"/knowledge_base/docs/Tello/functions"},next:{title:"ROS1",permalink:"/knowledge_base/docs/Voo autonomo/ros1"}},c=[{value:"tttAI",id:"tttai",children:[],level:2},{value:"<strong>init</strong>()",id:"init",children:[],level:2},{value:"tello_startup()",id:"tello_startup",children:[],level:2},{value:"filter_small()",id:"filter_small",children:[],level:2},{value:"match_shape ()",id:"match_shape-",children:[],level:2},{value:"most_frequent()",id:"most_frequent",children:[],level:2},{value:"get_common()",id:"get_common",children:[],level:2},{value:"get_mask()",id:"get_mask",children:[],level:2},{value:"show_drone_play()",id:"show_drone_play",children:[],level:2},{value:"get_squares()",id:"get_squares",children:[],level:2},{value:"detect_board()",id:"detect_board",children:[],level:2},{value:"read_board()",id:"read_board",children:[],level:2},{value:"print_board()",id:"print_board",children:[],level:2},{value:"play_ttt()",id:"play_ttt",children:[],level:2}],u={toc:c};function m(e){var o=e.components,n=(0,a.Z)(e,l);return(0,r.kt)("wrapper",(0,t.Z)({},u,n,{components:o,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tttpy"},"ttt.py"),(0,r.kt)("p",null,"Essa p\xe1gina tem o objetivo de explicar o funcionamento do c\xf3digo ttt.py, que permite o usu\xe1rio jogar jogo da velha com o drone Tello."),(0,r.kt)("h1",{id:"depend\xeancias"},"Depend\xeancias"),(0,r.kt)("p",null,"O c\xf3digo usa as seguintes depend\xeancias:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"import cv2\nimport numpy as np\nimport time\nfrom tttAI import IA\nfrom djitellopy import Tello\n")),(0,r.kt)("p",null,"Opencv para a manipula\xe7\xe3o e tratamento de imagens, numpy para a cria\xe7\xe3o das m\xe1scaras (em suporte do opencv), time para a fun\xe7\xe3o sleep() e djitellopy para controle do drone."),(0,r.kt)("h2",{id:"tttai"},"tttAI"),(0,r.kt)("p",null,"A depend\xeancia restante \xe9 uma implementa\xe7\xe3o do algoritmo Minimax feita para jogar jogo da velha, criado por Clederson Cruz sob licensa GPL. Foi utilizado para tomar as decis\xf5es das jogadas do drone."),(0,r.kt)("h1",{id:"classe-tttdetection"},"Classe tttDetection"),(0,r.kt)("h2",{id:"init"},(0,r.kt)("strong",{parentName:"h2"},"init"),"()"),(0,r.kt)("p",null,"Inicializa o objeto que representa o tello, bem como o objeto do algoritmo que jogar\xe1 pelo drone e por fim cria os contornos dos jogadores, abrindo suas respectivas imagens que, depois de transformadas em grayscale e aplicado um filtro threshold, retornam os contornos sem usar uma aproxima\xe7\xe3o (tag cv2.CHAIN","_","APPROX_NONE)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'def __init__(self):\n    self.tello = Tello()\n    self.ia = IA()\n    \n    # Contornos do player1 (X)\n    player1 = cv2.imread("./player1.png")\n    player1_gray = 255 - cv2.cvtColor(player1, cv2.COLOR_BGR2GRAY)\n    \n    _, thresh1 = cv2.threshold(player1_gray, 127, 255, 0)\n    contours, _ = cv2.findContours(thresh1, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\n    self.player1_cnt = contours[0]\n\n    # Contornos do player2 (Check mark)\n    player2 = cv2.imread("./player2.png")\n    player2_gray = 255 - cv2.cvtColor(player2, cv2.COLOR_BGR2GRAY)\n\n    _, thresh2 = cv2.threshold(player2_gray, 127, 255, 0)\n    contours, _ = cv2.findContours(thresh2, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\n    self.player2_cnt = contours[0]\n')),(0,r.kt)("h2",{id:"tello_startup"},"tello_startup()"),(0,r.kt)("p",null,"Se conecta ao Tello e come\xe7a a transmiss\xe3o da c\xe2mera."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"def tello_startup(self):\n    self.tello.connect()\n    self.tello.streamon()\n")),(0,r.kt)("h2",{id:"filter_small"},"filter_small()"),(0,r.kt)("p",null,"Dado uma lista de contornos, elimina os que possu\xedrem uma \xe1rea menor do que a \xe1rea limite. Tem o objetivo de limpar as imagens dos quadrantes para uma melhor detec\xe7\xe3o. N\xe3o \xe9 necessariamente importante ou particularmente efetiva, mas n\xe3o afeta significativamente a performance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"def filter_small(self, contours, min_area):\n    \n    filtered_contours = []\n\n    for contour in contours:\n        if cv2.contourArea(contour) >= min_area:\n            filtered_contours.append(contour)\n\n    return filtered_contours\n")),(0,r.kt)("h2",{id:"match_shape-"},"match_shape ()"),(0,r.kt)("p",null,"Dado uma lista de contornos (dos quadrantes do tabuleiro) e uma toler\xe2ncia, verifica se um desses contornos \xe9 pr\xf3ximo o suficiente do modelo dos jogadores."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"def match_shape(self, square_cnts, max_tolerance):\n    for contour in square_cnts:\n                    \n        if cv2.matchShapes(contour, self.player1_cnt, 1, 0.0) < max_tolerance:\n            return 1\n\n        elif cv2.matchShapes(contour, self.player2_cnt, 1, 0.0) < max_tolerance:\n            return -1\n\n    return 0\n")),(0,r.kt)("h2",{id:"most_frequent"},"most_frequent()"),(0,r.kt)("p",null,"Dado uma lista, encontra o valor que mais aparece nela. Usado conjuntamente com get_common()"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"def most_frequent(self, list):\n\n    most_frequent = 0\n    result = list[0]\n \n    for i in list:\n        frequency = list.count(i)\n        if(frequency > most_frequent):\n            most_frequent = frequency\n            result = i\n\n    return result\n")),(0,r.kt)("h2",{id:"get_common"},"get_common()"),(0,r.kt)("p",null,'Fun\xe7\xe3o que recebe a lista de tabuleiros detectados em um ciclo da fun\xe7\xe3o detect_board() e, para cada quadrante, escolhe a jogada que mais prevalesceu e retorna o tabuleiro "comum". Tem o objetivo de fornecer uma redund\xe2ncia para o ciclo de detec\xe7\xe3o.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"def get_common(self, boards):\n\n    board_common = [[], [], []]\n    for i in range(3):\n        for j in range(3):\n            play = []\n            for board in boards:\n                play.append(board[i][j])\n\n            board_common[i].append(self.most_frequent(play))\n    \n    return board_common\n")),(0,r.kt)("h2",{id:"get_mask"},"get_mask()"),(0,r.kt)("p",null,"Cria uma m\xe1scara, usando um par\xe2metro maior e um par\xe2metro menor e retorna a m\xe1scara."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"def get_mask(self, hsv , lower_color , upper_color):\n    lower = np.array(lower_color)\n    upper = np.array(upper_color) \n    mask = cv2.inRange(hsv , lower, upper)\n    return mask\n")),(0,r.kt)("h2",{id:"show_drone_play"},"show","_","drone_play()"),(0,r.kt)("p",null,'Processo que realiza a "representa\xe7\xe3o" f\xedsica da jogada do drone. Por exemplo, se a jogada escolhida for no canto superior esquerdo, o drone voa para a esquerda, para cima e depois retorna a posi\xe7\xe3o.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"def show_drone_play(self,drone_play):\n    dist = 40\n    wait = 1\n    wait_after = 2\n    if(drone_play == 1):\n        self.tello.move_left(dist)\n        time.sleep(wait)\n        self.tello.move_up(dist)\n        time.sleep(wait_after)\n        \n        self.tello.move_down(dist)\n        time.sleep(wait)\n        self.tello.move_right(dist)\n\n    elif(drone_play == 2):\n        \n        self.tello.move_up(dist)\n        time.sleep(wait_after)\n        self.tello.move_down\n\n    elif(drone_play == 3):\n        self.tello.move_right(dist)\n        time.sleep(wait)\n        self.tello.move_up(dist)\n        time.sleep(wait_after)\n\n        self.tello.move_down(dist)\n        time.sleep(wait)\n        self.tello.move_left(dist)\n        \n    elif(drone_play == 4):\n        self.tello.move_left(dist)\n        time.sleep(wait_after)\n        self.tello.move_right(dist)\n\n    elif(drone_play == 5):\n        self.tello.move_forward(dist)\n        time.sleep(wait_after)\n        self.tello.move_back(dist)\n    \n    elif(drone_play == 6):\n        self.tello.move_right(dist)\n        time.sleep(wait_after)\n        self.tello.move_left(dist)\n        \n    elif(drone_play == 7):\n        self.tello.move_left(dist)\n        time.sleep(wait)\n        self.tello.move_down(dist)\n        time.sleep(wait_after)\n\n        self.tello.move_up(dist)\n        time.sleep(dist)\n        self.tello.move_right(dist)\n\n    elif(drone_play == 8):\n        self.tello.move_down(dist)\n        time.sleep(wait_after)\n        self.tello.move_up(dist)\n        \n    elif(drone_play == 9):\n        self.tello.move_right(dist)\n        time.sleep(wait)\n        self.tello.move_down(dist)\n        time.sleep(wait_after)\n\n        self.tello.move_up(dist)\n        time.sleep(wait)\n        self.tello.move_left(dist)\n")),(0,r.kt)("h2",{id:"get_squares"},"get_squares()"),(0,r.kt)("p",null,"Fun\xe7\xe3o que recebe uma imagem, aplica uma m\xe1scara azul (para detectar a borda do tabuleiro) e, dos contornos da imagem, verifica se um deles \xe9 um quadrado com uma \xe1rea suficiente para ser o tabuleiro."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"def get_squares (self, image):\n\n    lower_blue = [ 99, 89, 53]\n    upper_blue = [ 119, 255, 255]\n\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    blue_mask = self.get_mask(hsv, lower_blue, upper_blue)\n    blue_result = cv2.bitwise_and(image , image , mask= blue_mask)\n\n    erode_size = 5\n    dilate_size = 5\n\n    erode_kernel = np.ones((erode_size, erode_size), np.float32)\n    dilate_kernel = np.ones((dilate_size, dilate_size), np.float32)\n    \n    blue_result = cv2.dilate(blue_result, dilate_kernel)\n    blue_result = cv2.erode(blue_result, erode_kernel)\n\n    # Retorna uma lista com os quadrados que tem area maior ou igual a min_area\n    square_detected = 0\n\n    min_area = 6000 # Area minima para um quadrado ser contabilizado\n\n    contours, _ = cv2.findContours(blue_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n    \n    for contour in contours:\n        area = cv2.contourArea(contour)\n        if area >= min_area:\n\n            x,y,w,h=cv2.boundingRect(contour)\n            square_detected = [x,y,w,h]\n\n    return square_detected, blue_result\n")),(0,r.kt)("h2",{id:"detect_board"},"detect_board()"),(0,r.kt)("p",null,"Uma das fun\xe7\xf5es essenciais. Abre uma imagem da vis\xe3o do drone na tela, bem como a vis\xe3o da m\xe1scara, para permitir que o usu\xe1rio decida quando come\xe7ar o ciclo de detec\xe7\xf5es (apertando espa\xe7o no teclado). Isto posto, o ciclo de detec\xe7\xf5es come\xe7a: uma imagem da c\xe2mera do drone \xe9 selecionada, processada usando a fun\xe7\xe3o get_squares() e se o tabuleiro for detectado, \xe9 executada a fun\xe7\xe3o read board(), que divide a imagem do tabuleiro em quadrantes e verifica para cada um deles qual a jogada."),(0,r.kt)("p",null,"Esse processo \xe9 executado v\xe1rias vezes (o n\xfamero exato \xe9 definido pelo par\xe2metro tries) com um pequeno per\xedodo de espera entre processamentos. Isso significa que mesmo que a detec\xe7\xe3o possua algum erro em algum quadrante, por meio da fun\xe7\xe3o get_common(), a leitura que melhor prevalescer \xe9 a escolhida."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'def detect_board(self, tries, wait_time = 0.05, max_tolerance = .6):\n    boards = []\n    print("\\nQuando encontrar o tabuleiro, aperte espa\xe7o com a janela selecionada.")\n    while(True):\n        \n        self.tello.send_control_command("command")\n        self.frame = self.tello.get_frame_read().frame \n        board, self.blue_img = self.get_squares(self.frame)\n        frame_gray = cv2.cvtColor(self.frame, cv2.COLOR_BGR2GRAY)\n        _, frame_thresh = cv2.threshold(frame_gray, 127, 255,0)\n        cv2.imshow("frame threshold", frame_thresh)\n        cv2.imshow("blue", self.blue_img)\n\n        if(cv2.waitKey(1) == ord(" ")):\n            break\n\n    for _ in range(tries):\n        #_, self.frame = self.capture.read(0)\n        self.frame = self.tello.get_frame_read().frame \n\n        board, self.blue_img = self.get_squares(self.frame)\n        if board != 0:\n\n            boards.append(self.read_board(board, max_tolerance))\n\n        time.sleep(wait_time)\n\n    return self.get_common(boards)\n')),(0,r.kt)("h2",{id:"read_board"},"read_board()"),(0,r.kt)("p",null,"Fun\xe7\xe3o que recebe a imagem de um tabuleiro, divide os quadrantes e os analisa individualmente (fun\xe7\xe3o get_squares()) a fim de identificar a jogada. Por fim, retorna uma matriz que representa o tabuleiro."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'def read_board(self, board, max_tolerance = 1):\n\n    x,y,w,h = board\n    board_simple = [[], [], []]\n\n    frame_gray = cv2.cvtColor(self.frame, cv2.COLOR_BGR2GRAY)\n    _, frame_thresh = cv2.threshold(frame_gray, 127, 255, 0)\n\n    cv2.imshow("frame threshold", frame_thresh)\n    cv2.imshow("blue", self.blue_img)\n\n    for i in range(3):\n        for j in range(3):\n            \n            square = frame_thresh[(y + h * (j)//3) : (y + h * (j + 1)//3), (x + w * (i)//3) : (x + w * (i + 1)//3)]\n            square_cnts, _ = cv2.findContours(square, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\n            square_cnts = self.filter_small(square_cnts, 15)\n\n            board_simple[j].append(self.match_shape(square_cnts, max_tolerance))\n    \n    return board_simple\n')),(0,r.kt)("h2",{id:"print_board"},"print_board()"),(0,r.kt)("p",null,"Processo que representa no terminal o estado do tabuleiro depois de um turno."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'def print_board(self, board):\n    print(f" {board[0][0]} | {board[0][1]} | {board[0][2]}")\n    print("-----------")\n    print(f" {board[1][0]} | {board[1][1]} | {board[1][2]}")\n    print("-----------")\n    print(f" {board[2][0]} | {board[2][1]} | {board[2][2]}")\n    print()\n    print()\n    print("###########################################")\n')),(0,r.kt)("h2",{id:"play_ttt"},"play_ttt()"),(0,r.kt)("p",null,"Processo que realiza por completo o jogo com o drone. Depois de se conectar com o Tello e faz\xea-lo realizar um takeoff, pergunta por meio do terminal quem vai jogar primeiro. Depois disso, inicia um loop at\xe9 que o jogo termine ou que o usu\xe1rio escreva q."),(0,r.kt)("p",null,"Nesse loop, a fun\xe7\xe3o detect_board() \xe9 chamada e retorna o estado do tabuleiro, que \xe9 fornecido para a IA, que joga pelo drone. A jogada do drone \xe9 representada fisicamente pelo movimento do drone e o loop continua."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'def play_ttt(self):\n    self.tello_startup()\n    self.tello.takeoff()\n    board_state = []\n    start_detetection = False\n\n    c_choice = "X"\n    h_choice = "V"\n\n    print("Come\xe7ando o jogo da velha!!")\n    print("-------------------------------")\n\n    first = input("Voc\xea que come\xe7ar? [S/N] ")\n\n    # Rodando o loop enquanto o tabuleiro n\xe3o estiver preenchido nem ganho        \n    while len(self.ia.empty_cells(self.ia.board)) > 0 and not self.ia.game_over(self.ia.board):\n        self.tello.send_control_command("command")\n\n        if first in\'Nn\':\n            jogada_ia = self.ia.ai_turn(c_choice, h_choice)\n            self.show_drone_play(jogada_ia)\n            print(f"Jogada do drone : {jogada_ia}")\n            first = \'nothing\'\n\n        start_detetection = input("\\nDigite qualquer coisa para iniciar uma detec\xe7\xe3o (se quiser sair do jogo, aperte q)  \\n")\n\n        if start_detetection in "Qq":\n            break\n\n        board_state = self.detect_board(tries = 25)\n        print("Tabuleiro encontrado!\\n")\n        print("\\nSitua\xe7\xe3o atual do jogo:")\n        self.ia.board = board_state\n        self.ia.render(board_state, c_choice, h_choice)\n\n        jogada_ia = self.ia.ai_turn(c_choice, h_choice)\n        self.show_drone_play(jogada_ia)\n\n        print(f"Jogada do drone : {jogada_ia}")\n        # drone indica a jogada\n    self.tello.land()\n')))}m.isMDXComponent=!0}}]);